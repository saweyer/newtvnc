// VERSION STUFFconstant /*String*/ VERSIONMSG := "RFB 003.003\u000A"; // end with unicodeLF (\u000A) rather than unicodeCR (\n)// AUTHENTICATIONconstant /*int*/ ConnFailed := 0, NoAuth := 1, VncAuth := 2;constant /*int*/ VncAuthOK := 0, VncAuthFailed := 1, VncAuthTooMany := 2;// VIEWER (input) STATESconstant /*int*/ FramebufferUpdate := 0, SetColourMapEntries := 1, Bell := 2, ServerCutText := 3;constant kViewerMessageNames := '["UpdateRequest",  "ColourMap", "Bell", "Cut", "?"];	// for debuggingconstant VIEWER_STATES		 := '[GetUpdateRectsNum, ColourMap,	 GetBell, GetServerCutLen, UnknownMsg];// SERVER (input) STATESconstant /*int*/ SetPixelFormat := 0, FixColourMapEntries := 1,	SetEncodings := 2, FramebufferUpdateRequest := 3, KbdEvent := 4, // was KeyEvent	PointerEvent := 5, ClientCutText := 6;constant kServerMessageNames := '["SetPixelFormat", "ColourMap", "SetEncodings",  "UpdateRequest",  "Kbd", "Pointer", "Cut", "?"];	// for debuggingconstant SERVER_STATES		 := '[GetClientFormat,	ColourMap,	 GetEncodingsLen, GetUpdateRequest, GetKbdEvent, GetPointerEvent, GetClientCutLen, UnknownMsg];// ENCODINGS constant /*int*/ EncodingRaw := 0, EncodingCopyRect := 1, EncodingRRE := 2,	EncodingCoRRE := 4, EncodingHextile := 5, EncodingZlib := 6, EncodingZlibHex := 8;constant kNumZibFlaters := 2;// use slot if including Tight (otherwise compile flag -- see :close)/*constant EncodingTight := 7;constant TightExplicitFilter := 0x04, TightFill := 0x08,	TightMaxSubencoding := 0x08, TightFilterCopy := 0x00,	TightFilterPalette := 0x01, TightFilterGradient := 0x02;constant TightMinToCompress := 12;	// not supported	EncodingCompressLevel0 := 0xFFFFFF00, EncodingXCursor := 0xFFFFFF10,	EncodingRichCursor := 0xFFFFFF11, EncodingLastRect := 0xFFFFFF20;*/DefineGlobalConstant(/*string[]*/ 'kEncodingNames, [	LocObj("Raw",		'raw),	LocObj("CopyRect", 	'copyRect),	LocObj("RRE", 		'RRE),	"3",	LocObj("CoRRE", 	'CoRRE),	LocObj("Hextile", 	'Hextile),	LocObj("Zlib", 		'zlib),	LocObj("Tight", 	'tight),	LocObj("ZlibHex",	'zlibHex),	]);constant /*int*/ HextileRaw					:= (1 << 0);constant /*int*/ HextileBackgroundSpecified	:= (1 << 1);constant /*int*/ HextileForegroundSpecified	:= (1 << 2);constant /*int*/ HextileAnySubrects			:= (1 << 3);constant /*int*/ HextileSubrectsColoured	:= (1 << 4);//constant /*int*/ HextileZlibRaw			:= (1 << 5);//constant /*int*/ HextileZlibHex			:= (1 << 6);// PENconstant /*int*/ kBut1 	:= 1;constant /*int*/ kBut2 	:= 2;constant /*int*/ kBut3 	:= 4;constant /*int*/ kButOff := 0;constant /*int*/ kButNone := -1;// for InsertTabletSampleconstant kPenDownSample := 13;	// Flag for a pen down in the bufferconstant kPenUpSample   := 14;  // Flag for a pen up in the buffer//constant kInvalidSample := 15;// KEY STUFFconstant KEY_PRESS 	 		:= 1;	// "down"constant KEY_RELEASE 		:= 0;constant /*int*/ chDEL := 127;constant /*int*/ kOptionsModifier 	:= 1 << 28;	// should have been defined in platform fileDefineGlobalConstant('kAnyModifier, kControlModifier + kCommandModifier + kOptionsModifier+ kShiftModifier + kCapsLockModifier);DefineGlobalConstant('MODIFIERS_VNC, [0xffe3, 			0xffe1, 		0xffe7, 			0xffe9]);DefineGlobalConstant('MODIFIERS_NWT, [kControlModifier, kShiftModifier, kOptionsModifier, 	kCommandModifier]);DefineGlobalConstant('MODIFIERS_KC,  [kControlKeyCode,	kShiftKeyCode,	kOptionKeyCode,		kCommandKeyCode]);DefineGlobalConstant('F_KEYS_NWT, [	Ord($\uF721), Ord($\uF722), Ord($\uF723), Ord($\uF724), Ord($\uF725), Ord($\uF726),	//F1-F6	Ord($\uF727), Ord($\uF728), Ord($\uF729), Ord($\uF72A), Ord($\uF72B), Ord($\uF72C),	//F7-12	//Ord($\uF72D), Ord($\uF72E), Ord($\uF72F)	//F13-F15 ???	]);constant F_KEYS_VNC := 0xffbe;	//=F1constant F_KEYS_KC  := nil;		// ??? don't know these keyCodesDefineGlobalConstant('ARROW_KEYS_VNC, [0xff51, 	0xff52, 0xff53, 0xff54, 0xffff]);DefineGlobalConstant('ARROW_KEYS_NWT, [chFS, 	chRS, 	chGS, 	chUS,	chDEL]);	//left, up, right, down arrows. del incl. here for convenienceDefineGlobalConstant('ARROW_KEYS_KC,  [123,		nil,	124,	nil,	51]);		// ??? keycodes: up,downDefineGlobalConstant('SPEC_KEYS_VNC, [0xff08, 	0xff09, 0xff0d, 0xff1b, 0xff0d]);DefineGlobalConstant('SPEC_KEYS_NWT, [chBS, 	chHT, 	chCR, 	chESC, 	chETX]);	// bs, tab, cr, esc, enter(cr)DefineGlobalConstant('SPEC_KEYS_KC,  [51, 		48, 	36, 	nil, 	36]);		// ??? Escconstant CHALLENGE_LEN  := 16;constant CHALLENGE_LEN2 :=  8;constant MSG_TYPE_LEN := 1;constant kInvalidRectColor := 173;DefineGlobalConstant('kRefreshNames, [	LocObj("full", 'full),	LocObj("incr", 'incremental),	]);// -1 are set dynamically (:nextInputLen); 0 are transition states;// otherwise fixed lens (:nextInput)// since these are constants, compiler appears to substitute at build time// also used to check that necessary states exist at build-time// these are basically in sequence, with alternatives nestedDefineGlobalConstant('STATE_LEN, {//NotRunning:						-1,// VIEWER// handshakingGetServerVersion:				12, //(string) = StrLen(VERSIONMSG)SendVersionMsg:					0,	GetAuth:					4,  //(int)	GetConnFailLen:				4,  //(int)	GetConnFailReason:			-1, //(string)=GetConnFailLen	GetServerChallenge:			CHALLENGE_LEN, //(bytes)	GetServerChallengeResponse:	 4, //(int)SendClientInit:					1,	//bGetServerFormat:				24, //w(s2),h(s2),bpp(b),d(b),e(b),c(b),rx(s2),gx(s2),bx(s2),r(b),g(b),b(b),pad(3),nameLen(4)GetServerName:					-1, //(string)=nameLenSendFormat:						20,	//b,pad(3),....,-nameLen// requests to serverSendUpdateRequest:				10,	//b,b,w,w,w,wSendCutText:					8,	//b,pad(3),long,str// responses from serverGetServerMessageType:			MSG_TYPE_LEN,  //(byte)	GetServerCutLen:			7,  //pad(3),cutLen(int)	GetServerCutText:			-1, //(string): @GetServerCutLen	ColourMap:					0,	//error	UnknownMsg:					0,	//error	GetBell:					0,	//no data needed	GetUpdateRectsNum:			3,  //pad(1), rectsNum(short)	GetUpdateRects:				12, //x(s),y(s),w(s),h(s),enc(int)	//GetRawRect:				-1, //w*h	GetRawRectN:				-1, //w*16|h	GetCopyRect:				4,  //x(s),y(s)	GetSubRectsRRENum:			5,  //subrects(int),bg(b)	GetSubRectsCoRRENum:		5,  //subrects(int),bg(b)	GetSubRectsRREN:			9,  //nSubRects * pixel(b),x(s),y(s),w(s),h(s)	GetSubRectsCoRREN:			5,  //nSubRects * pixel(b),x(b),y(b),w(b),h(b)	GetHexSubEncoding:			1,  //(byte)	GetHexSubEncodingRaw:		-1, //tw*th	GetHexSubEncoding3:			-1, //b?,b?,b?	GetHexSubEncodingSubrectN:	2,	//nSubRects*b,b: 2	GetHexSubEncodingSubrectFGN:3,	//nSubRects*b,b,b: 3	GetHexSubEncodingNext:		0,  //(transition). ok to inline rather than via :nextInput()	GetUpdateRectsNext:			0,  //(transition)	GetZlibNum:					4,	//long	GetZlibBytes:				-1,	// @GetZlibNum// ADD_SERVER// handshaking//SendVersionMsgGetClientVersion:				12, // GetServerVersion	GetClientChallenge:			CHALLENGE_LEN, // GetServerChallengeGetClientInit:					 1, // SendClientInit//SendFormat// requests from viewerGetClientMessageType:			MSG_TYPE_LEN,	//b(msgType),pad(1)	GetClientFormat:			19,	//SendServerFormat-1	GetEncodingsLen:			3,	//w	GetEncodings:				-1,	//4*len	GetClientCutLen:			7,	//SendCutText-1	GetClientCutText:			-1,	//len	GetUpdateRequest:			9,	//SendUpdateRequest-1	SendUpdateRect:				4+17,	//SendBell:					1,	// events	GetPointerEvent:			5,	//b,w,w	GetKbdEvent:				7,	//b,pad(2),long	//SendCutText});DefineGlobalConstant('rfbProto, {/*Socket*/ sock: null,/*boolean*/ inNormalProtocol: false,/*vncview*/ v: nil,/*vncCanvas*/ vc: nil,/*boolean*/ server: nil,/*int*/ updateNRects: nil,/*int*/ nSubRects: nil,/*Area*/ updateArea: nil,/*string*/ password: nil,challenge: nil,/*array*/ _refreshArgs: [INCR_REFRESH, INCR_DELAY, nil],new: func(/*String*/ h, int p, /*String*/ pw, /*vncview*/ v1)	{_proto: self,	v: v1,	vc: v1.vc,	host: h,	port: p,	sock: nil,    password: pw,  // save    // for viewer, initially big enough for writeKeyEvent: <= 32*3 + 2*8    // for server, big enough to send bitmap: full width * 18 + raw header(=12)    eventBuf: byte:new(if StrFilled(h) then 112 else VBO_LEN+12),    server: not StrFilled(h),    refreshArgs: _refreshArgs,    },connect: func()begin	// this is async	sock := Socket:new(host, port, self);end,setSize: func(int w, int h)	// ADD_SERVERbegin	framebufferWidth  := w;	framebufferHeight := h;end,setName: func(/*string*/ s)	// ADD_SERVER	serverName := s,/*int*/ framebufferWidth:  0,/*int*/ framebufferHeight: 0,// these are the default settings Newton server uses. sent by viewer&server -- see checkFormat// values from viewer checked by newtVNC server; server values ignored by newtVNC viewer/*int*/ bpp: 		8,/*int*/ depth: 		8,/*int*/ bigEndian:  1,	// NA for depth=8/*int*/ trueColour: 1,	// interp pixel via max/shift rather than colourtable (which isn't supported anyway)???/*int*/ redMax:   	7,/*int*/ greenMax: 	7,/*int*/ blueMax:  	3,/*int*/ redShift:   0,/*int*/ greenShift: 3,/*int*/ blueShift:  6,/*string*/ serverName: nil,/*boolean*/ isOpen: func()	// note: rfb:?isOpen() returns nil if rfb=nil	inNormalProtocol,disconnected: func()	v:disconnected(),status: func(/*string*/ msg, arg, /*boolean*/ doLog)	v:status(msg, arg, doLog),/*boolean*/ error: func(/*string*/ msg, earg, /*boolean*/ fatal)	// fr = currentException()begin	// earg: string, int, nil or frame=currentException()	local errCode := earg, pos;	if IsFrame(earg) 	then if not (errCode := earg.error)		then if IsFrame(earg.data)			then errCode := earg.data.errorCode;	if IsInteger(errCode)	then if pos := SetContains(ROM_errorTable, errCode)		then errCode := errCode && ROM_errorTable[pos+1]		else if errCode <= -60000 and GetGlobalFnExists('InetGetErrorString)		then errCode := errCode && InetGetErrorString(errCode);	msg := $: && _inState && msg & $: && errCode;if DEBUG then Print("error" & msg);	v:status(LocObj("error", 'error), msg, DO_LOG);	if fatal	then begin		//GetRoot():Notify(kNotifyMessage, kAppName, LocObj("disconnected", 'disconnected) & msg);		PlaySound(ROM_soundOff.gongBeep);		v:disconnect(nil);		end;    nil;	// currently not used (by state machine)end,connected: func()begin	if ADD_SERVER and server and IsArray(sock._address) and Length(sock._address)=5	then begin//if DEBUG then Print(['connected, sock._address]);		sock.port := sock._address[4];		SetLength(sock._address, 4);		sock.host := InetIPAddressToString(sock._address);		end;	v:status(LocObj("connected", 'connected), sock.host & $: & sock.port, NO_LOG); // ??? _address, esp. for server	// socket has successfully connected	// server starts by sending version	// viewer starts by reading version	if ADD_SERVER and server	then :SendVersionMsg('GetClientVersion)	else :nextInputLen('GetServerVersion, STATE_LEN.GetServerVersion);end,close: func()begin	zlibFlater := zlibFlater:?close();	inNormalProtocol := _inState := _outState := nil;    sock := sock:?close();	// in case already closed    nil;end,// most transitions use :nextInputLen directly// if length is computed, or to avoid extra method call (if length lookup inlined by compiler)///*boolean*/ nextInput: func(/*symbol*/ next) :nextInputLen(next, STATE_LEN.(next)),/*symbol*/ _inState: nil,/*byte*/ _inBuf: nil,	// used only in nextInputLen/*int*/  _inLen: nil,	// set in nextInputLen, used by states -- Length(_inBuf) might be > _inLen/*boolean*/ nextInputLen: func(/*symbol*/ next, int len)begin	if not len and next	then len := STATE_LEN.(next);	//if DEBUG then Print(next && $[ & len & $]);if PROFILE then vc:testFreq(next, 1);if PROFILE then vc:testFreq('readBytes, len);if TIMING then bytesR := bytesR + len;	// record in advance    _inState := next;    if (len = _inLen)    then return true;				// SAME (still active) inputSpec (no need for readBytes)    _inLen := len;    if (len <= 0)	// a 'next' (or not running) state -- no new data needed    then return Perform(self, _inState, nil); // go immediately (no data arg)    if (_inBuf = nil)    then _inBuf := byte:new(len)	// alloc first    else if (Length(_inBuf) < len)    then if len > VBO_LEN    then _inBuf := GetDefaultStore():NewVBO('bytes, len)    else SetLength(_inBuf, len);	// make bigger	sock:?readBytes(_inBuf,0,len);    true;end,_outLen: 	nil,_outState: 	nil,_outBuf:	nil,/*byte[]*/ getOutputBuf: func(int len)begin	_outLen := len;	// reuse eventBuf when possible to avoid extra allocation	// but if Output is busy, assume eventBuf might still be in use	if _outState or len > Length(eventBuf)		then byte:new(len)		else eventBuf;end,OutputCallback: func()	// generic callback. flushes queue (if any)begin	if _outBuf	then sock:?writeBytes(_outBuf, 0, _outBuf := nil)	// _outState remains set	else _outState := nil;end,nextOutput: func(/*symbol*/ next, /*byte[]*/ data, int len)beginif TIMING then bytesW := bytesW + len;	// record in advance//if PROFILE then vc:testFreq(next, 1);	if _outState and data	// Output in progress. so queue	then beginif PROFILE then vc:testFreq('writeBytesQ, len);		if _outBuf		then BinaryMunger(_outBuf,Length(_outBuf),nil, data,0,len)		else _outBuf := ExtractBytes(data, 0, len, ClassOf(data));		end	else beginif PROFILE then vc:testFreq('writeBytes, len);		_outState := if next then next else 'OutputCallback;		if data		then sock:?writeBytes(data, 0, len)		else :OutputCallback();	// to flush, e.g. at end of SendBitmapRect		end;end,/*int*/ progRect: 	0,		// used for 'countdowns' for setGauge/*int*/ progHt:		0,		// used for 'countdowns' for setGauge// ===== STATESSendVersionMsg: func(/*symbol*/ next)	// Write our protocol version messagebegin	local /*byte*/ data := :getOutputBuf(STATE_LEN.GetServerVersion + 1);	// same as GetClientVersion	StuffCString(data, 0, VERSIONMSG);	:nextOutput(nil, data, _outLen-1);	// allocated extra for StuffCString null    :nextInputLen(next, nil);end,//GetClientVersion:	***					// ADD_SERVER.  SendVersionMsg already occurred in :connectedGetServerVersion: func(/*byte[]*/ data)	// VIEWERbegin	local c4 := ExtractChar(data,4), c5 := ExtractChar(data,5), c6  := ExtractChar(data,6);	local c8 := ExtractChar(data,8), c9 := ExtractChar(data,9), c10 := ExtractChar(data,10);	// NS note: ok to do char comparisons, but not char arithmetic	if (   (ExtractChar(data,0) <> $R) or (ExtractChar(data,1) <> $F)		or (ExtractChar(data,2) <> $B) or (ExtractChar(data,3) <> $ )        or (c4                   < $0) or (c4            		> $9)        or (c5            		 < $0) or (c5            		> $9)        or (c6            		 < $0) or (c6            		> $9)        or (ExtractChar(data,7) <> $.)        or (c8            		 < $0) or (c8            		> $9)        or (c9            		 < $0) or (c9            		> $9)		or (c10           		 < $0) or (c10           		> $9)		or (ExtractChar(data,11)<> unicodeLF) // $\0A		)	then return :error(LocObj("incompat VNC version", 'incompatVersion), :ExtractString(data,0,_inLen), FATAL_ERROR);    local /*string*/ ver := :ExtractString(data,4,7);	if ADD_SERVER and server	then beginif DEBUG then Print([_inState, ver]);    	v:status(LocObj("VNC viewer", 'vncViewer), ver, DO_LOG);		local int pwlen := StrLen(password), i;		if pwlen=0		then begin			data := :getOutputBuf(STATE_LEN.GetAuth);			StuffLong(data, 0, NoAuth);			:nextOutput(nil, data, _outLen);			:nextInputLen('GetClientInit, STATE_LEN.GetClientInit);			end		else begin			data := :getOutputBuf(STATE_LEN.GetAuth + STATE_LEN.GetServerChallenge);			StuffLong(data, 0, VncAuth);			for i := 4 to _outLen-1		// create random 16-byte challenge			do StuffByte(data, i, Random(0,255));			challenge := ExtractBytes(data, 4, CHALLENGE_LEN, 'bytes);	// save to encrypt and compare			:nextOutput(nil, data, _outLen);			:nextInputLen('GetClientChallenge, STATE_LEN.GetClientChallenge);			end;		end	else begin   		v:status(LocObj("VNC server", 'vncServer), ver, DO_LOG);		:SendVersionMsg('GetAuth);		end;end,GetClientChallenge: func(/*byte[]*/ data)	// ADD_SERVER. read the client responsebegin	local /*boolean*/ ok := BinEqual(:encryptChallenge(challenge,password), ExtractBytes(data,0,CHALLENGE_LEN,'bytes));	challenge := nil;	data := :getOutputBuf(STATE_LEN.GetServerChallengeResponse);	StuffLong(data, 0, if ok then VncAuthOK else VncAuthFailed);	:nextOutput(nil, data, _outLen);	if ok	then :nextInputLen('GetClientInit, STATE_LEN.GetClientInit)	else :error(LocObj("Authentication failed", 'authFailed), nil, FATAL_ERROR);end,GetAuth: func(/*byte[]*/ data) // readAuthSchemebegin	local int authScheme := ExtractLong(data,0);	if (authScheme = VncAuth)	then begin		v:status(LocObj("Authentication needed", 'authNeeded), nil, DO_LOG);		:nextInputLen('GetServerChallenge, STATE_LEN.GetServerChallenge);		end	else if (authScheme = NoAuth)	then begin		v:status(LocObj("No authentication needed", 'authNotNeeded), nil, NO_LOG);		:SendClientInit(nil);		end	else if (authScheme = ConnFailed)	then :nextInputLen('GetConnFailLen, STATE_LEN.GetConnFailLen)	else //default:		:error(LocObj("Unknown authentication scheme", 'authScheme), authScheme, FATAL_ERROR);end,GetServerChallenge: func(/*byte[]*/ data)begin	//In case of VncAuth the authentication scheme used is simple	//challenge/response scheme, i.e. server sends the challenge which client	//encrypts using a shared key and then waits for response from the server.	challenge := :encryptChallenge(ExtractBytes(data,0,_inLen,'bytes), password);    :nextOutput(nil, challenge, Length(challenge));	:nextInputLen('GetServerChallengeResponse, STATE_LEN.GetServerChallengeResponse);end,GetServerChallengeResponse: func(/*byte[]*/ data)begin	local int authResult := ExtractLong(data,0);	if (authResult = VncAuthOK)	then begin		v:status(LocObj("Authentication succeeded", 'authSuccess), nil, DO_LOG);		:SendClientInit(nil);		end	else if (authResult = VncAuthFailed)	then begin		v.authenticator:open();		:error(LocObj("Authentication failed", 'authFailed), nil, FATAL_ERROR);		end	else if (authResult = VncAuthTooMany)	then :error(LocObj("Authentication failed: too many tries", 'authTooMany), nil, FATAL_ERROR);	else //default:		:error(LocObj("unknown VNC auth result", 'authResult), authResult, FATAL_ERROR);end,GetConnFailLen: func(/*byte[]*/ data)	// VIEWER	:nextInputLen('GetConnFailReason, ExtractLong(data,0)),GetConnFailReason: func(/*byte[]*/ data)	// VIEWER	:error(LocObj("VNC connection failed", 'vncConnFailed), :ExtractString(data,0,_inLen), FATAL_ERROR),GetClientInit: func(/*byte[]*/ data)	// ADD_SERVER. read the client initialisation messagebegin	local int sharing := ExtractByte(data,0);if DEBUG then Print([_inState, sharing]);	v:status(LocObj("Share Desktop", 'shareDesktop), kYesNo[1-sharing], DO_LOG); // ignore....	:SendFormat('GetClientMessageType);	inNormalProtocol := true;	v:connected(sock.host & $: & sock.port, nil, nil);	//host:port cached in rfb:connectedend,SendClientInit: func(/*byte[]*/ data)	// VIEWER. write the client initialisation messagebegin	local int sharing := if v.options.shareDesktop then 1 else 0;	data := :getOutputBuf(STATE_LEN.SendClientInit);	v:status(LocObj("Share Desktop", 'shareDesktop), kYesNo[1-sharing], DO_LOG);    StuffByte(data, 0, sharing);    :nextOutput(nil, data, _outLen);    v:?disableShareDesktop();	// ?? undef for now	:nextInputLen('GetServerFormat, STATE_LEN.GetServerFormat);end,GetServerFormat: func(/*byte[]*/ data)	// VIEWERbegin	framebufferWidth  := ExtractWord(data,0);    framebufferHeight := ExtractWord(data,2);	// don't bother to check/report; assume server will conform to later viewer request    //local msg := :checkFormat(data, 4, {});    //if msg then v:status(LocObj("incompat formats", 'incompatFormats), msg, DO_LOG);  	:nextInputLen('GetServerName, ExtractLong(data,20)); // name lenend,/*boolean*/ checkFormat: func(/*byte[]*/ data, int offset, /*frame*/ checkFrame)if checkFramethen begin    checkFrame.bpp			:= ExtractByte(data, offset);    checkFrame.depth 		:= ExtractByte(data, offset+1);	checkFrame.bigEndian  	:= ExtractByte(data, offset+2);		// NA for single-byte pixels    checkFrame.trueColour 	:= ExtractByte(data, offset+3);    checkFrame.redMax 		:= ExtractWord(data, offset+4);    checkFrame.greenMax 	:= ExtractWord(data, offset+6);    checkFrame.blueMax 		:= ExtractWord(data, offset+8);    checkFrame.redShift 	:= ExtractByte(data, offset+10);    checkFrame.greenShift 	:= ExtractByte(data, offset+11);    checkFrame.blueShift 	:= ExtractByte(data, offset+12);	// ignore pad(3) at end	local slot, val, msg;	foreach slot,val in checkFrame	do if val <> self.(slot)		then beginif DEBUG then Print([slot, val, self.(slot)]);			msg := msg && slot;			end;	msg;	endelse nil,GetClientFormat: func(/*byte[]*/ data)	// ADD_SERVERbegin	// store in local frame, then compare against server preferences	local msg := :checkFormat(data, 3, {});		// msgType read in GetClientMessageType	// for now, warn if there are differences, or :error???. later try to be nicer and adjust...	if msg	then v:status(LocObj("incompat formats", 'incompatFormats), msg, DO_LOG);	:nextInputLen('GetClientMessageType, STATE_LEN.GetClientMessageType);end,SendFormat: func(/*symbol*/ next)	// VIEWER & ADD_SERVERbegin	local int offset;	local /*byte[]*/ data := :getOutputBuf(		(if ADD_SERVER and server		then STATE_LEN.GetServerFormat + StrLen(serverName)		else STATE_LEN.SendFormat) + 1);    if ADD_SERVER and server    then begin//v:status("SendFormat", serverName & $; && framebufferWidth & $x & framebufferHeight, DO_LOG);if DEBUG then Print(['SendFormat, _outLen-1, bpp, depth, framebufferWidth, framebufferHeight, serverName]);		StuffWord(data,0, framebufferWidth);	// pad: 1		StuffWord(data,2, framebufferHeight);		StuffLong(data,20, StrLen(serverName));		StuffCString(data, 24, serverName);		end    else beginif DEBUG then Print(['SendFormat, _outLen-1, bpp, depth]);		StuffByte(data,0, SetPixelFormat);  // pad: 3		end;    offset := 4;    // currently, these are rfbProto (default values)//v:status("SendFormat", bpp && depth && bigEndian && trueColour, DO_LOG);    StuffByte(data, offset, 	bpp);    StuffByte(data, offset+1, 	depth);    StuffByte(data, offset+2,	bigEndian);    StuffByte(data, offset+3,	trueColour);    StuffWord(data, offset+4,	redMax);    StuffWord(data, offset+6,	greenMax);    StuffWord(data, offset+8,	blueMax);    StuffByte(data, offset+10,	redShift);    StuffByte(data, offset+11,	greenShift);    StuffByte(data, offset+12,	blueShift);    //pad: 3//v:status("SendFormat", "output:" && _outLen-1, DO_LOG);    :nextOutput(nil, data, _outLen-1);	// -1 for StuffCString null//v:status("SendFormat", next, DO_LOG);    :nextInputLen(next, nil);end,GetServerName: func(/*byte[]*/ data)	// VIEWERbegin	serverName := :ExtractString(data,0,_inLen);	:SendFormat('GetServerMessageType);	// assume not overwritten in earlier GetServerInit ???	inNormalProtocol := true;	// this calls setEncodings, processNormalProtocolInit w/ full refresh request	v:connected(serverName, framebufferWidth, framebufferHeight);end,SetEncodings: func (/*int[]*/ array encodings)  // VIEWER. Write a SetEncodings messageif inNormalProtocolthen begin	local int len := Length(encodings);    local /*byte[]*/ data := :getOutputBuf(4 + (4 * len));//if DEBUG then Print(['setEncodings, len, _outLen]);    //StuffLong(data,0, 0);	// 0 padding    StuffByte(data,0, SetEncodings);    StuffWord(data,2, len);	local /*string*/ msg;    local int offset := 4, encoding;    foreach encoding in encodings    do begin		msg := msg && kEncodingNames[encoding] & $,;		StuffLong(data, offset, encoding);		offset := offset+4		end;     	v:status(LocObj("SetEncodings", 'setEncodings), msg, DO_LOG);    :nextOutput(nil, data, _outLen);end,SendUpdateRequest: func(/*frame*/ bnds, int refresh) // VIEWERbeginif PROFILE then vc:testFreq('writeFramebufferUpdateRequest, 1);	v:status(kRefreshNames[refresh], call kBoundsString with (bnds), NO_LOG);    local /*byte[]*/ data := :getOutputBuf(STATE_LEN.SendUpdateRequest);    StuffByte(data, 0, FramebufferUpdateRequest);    StuffByte(data, 1, refresh);    :StuffUpdateRequest(data, 2, bnds, nil);    :nextOutput(nil, data, _outLen);end,GetUpdateRequest: func(/*byte[]*/ data)	// ADD_SERVERbegin	local int refresh := ExtractByte(data,0), offset := 1;	// ignore incremental requests (basically redundant)	if refresh = FULL_REFRESH	then begin		local /*frame*/ bnds := RelBounds(			ExtractWord(data, offset),			ExtractWord(data, offset+2),			ExtractWord(data, offset+4),			ExtractWord(data, offset+6));		//if not vc.incrUpdates then	// ?? first time kludge		// v:status(kRefreshNames[refresh], call kBoundsString with (bnds), DO_LOG);		//if not :RectEqual(bnds, vc.localBounds)	// if not actually full screen, do 'incremental' on area		//then refresh := INCR_REFRESH;		vc:Refresh(refresh, if DEBUG then 'GetUpdateRequest else NO_DELAY, bnds);	// actually some delay until viewIdleScript		end;	:nextInputLen('GetClientMessageType, STATE_LEN.GetClientMessageType);end,SendCutText: func(/*string*/ text) 	// VIEWER, ADD_SERVERif inNormalProtocolthen beginif DEBUG then Print(['SendCutText, text]);    local int len := StrLen(text);    local /*byte[]*/ data := :getOutputBuf(STATE_LEN.SendCutText + len +1); // allow 1 for null for StuffCString    //StuffLong(data,0, 0);	// 0 padding    StuffByte(data,0, if server then ServerCutText else ClientCutText);    StuffLong(data,4,len);    StuffCString(data,8,text); // write unnec null    :nextOutput(nil, data, _outLen);end,ColourMap: func(/*byte[]*/ data)	:error(LocObj("Can't handle Fix/Set ColourMapEntries", 'colorMap), nil, FATAL_ERROR),UnknownMsg: func(/*byte[]*/ data)	:error(LocObj("Unknown RFB msg type", 'rfbMsgType), ExtractByte(data,0), FATAL_ERROR),// SERVERGetKbdEvent: func(/*byte*/ data)		// ADD_SERVERbegin	local int updown := ExtractByte(data,0), key := ExtractLong(data,3), i, keyCode;	local msg, modKey;	if i := SetContains(MODIFIERS_VNC, key)	then keyCode := modKey := MODIFIERS_KC[i]	else if i := SetContains(SPEC_KEYS_VNC, key)	// kStringToKeyCodesFunc does work for bs,tab,cr	then keyCode := SPEC_KEYS_KC[i]	else if i := SetContains(ARROW_KEYS_VNC, key)	then keyCode := ARROW_KEYS_KC[i]	else if 0 <= (i := key - F_KEYS_VNC) and i < 12	then keyCode := F_KEYS_KC	// note: unknown key codes	else try		begin			i := call kStringToKeyCodesFunc with ("" & Chr(key));			if IsArray(i) and Length(i)=2			then keyCode := i[1]			else if IsArray(i) and Length(i)=4			then keyCode := i[2]			else msg := i;		end		onexception |evt.ex|		do msg := "kStringToKeyCodesFunc";if DEBUG then Print(['key, (if updown=KEY_PRESS then "down" else "up"), key, keyCode, (if msg then msg else if not keyCode then "no mapping")]);	if keyCode	then begin		if updown=KEY_PRESS		then begin			keyCode := Bor(keyCode, 128);			if not modKey then PlaySound(ROM_typewriter);			end;		HandleKeyEvents([keyCode]);		end;	:nextInputLen('GetClientMessageType, STATE_LEN.GetClientMessageType);end,/*int*/ lastBut: kButOff,/*int[]*/ butX:	nil,/*int[]*/ butY:	nil,//samples: nil,GetPointerEvent: func(/*byte*/ data)	// ADD_SERVERbegin	local int but := ExtractByte(data,0);	// ...up, [down, down,...down, up],...	if but = kButOff	then begin		if lastBut <> kButOff		then begin	// sequence end//if DEBUG then Print(['Pen, Length(butX), butX, butY]);			// InsertTabletSample 'all at once' -- avoid interference with comms etc./*			local fn := GetGlobalFn('InsertTabletSample);			local array sample;			AddArraySlot(samples, [0,0, kPenUpSample,ticks()]);			foreach sample in samples			do Apply(fn, sample);			samples := nil;*/			local int i;			InsertTabletSample(0,0, kPenDownSample, 0);			for i:=0 to Length(butX)-1			do InsertTabletSample(butX[i], butY[i], 7, 0);			InsertTabletSample(0,0, kPenUpSample, 0);					butX := butY := nil;			vc:Refresh(IMMED_REFRESH, nil, nil);			end;		end	else begin		if lastBut = kButOff		then begin	// sequence start			butX := []; butY := [];			//samples := [[0,0, kPenDownSample,ticks()]];			end;		// sequence: add a point		local int x := ExtractWord(data,1), y := ExtractWord(data,3);		//AddArraySlot(samples, [x,y,7,ticks()]);		AddArraySlot(butX, x); AddArraySlot(butY, y);		end;	lastBut := but;	:nextInputLen('GetClientMessageType, STATE_LEN.GetClientMessageType);end,/*call func(x,y)beginInsertTabletSample(0,0,13, 0);	//kPenDownSampleInsertTabletSample(x,y,7, 0);InsertTabletSample(0,0,14, 0);	//kPenUpSampleend with (5,5)*/GetEncodingsLen: func(/*byte*/ data)	// ADD_SERVER	:nextInputLen('GetEncodings, 4*ExtractWord(data,1)),GetEncodings: func(/*byte*/ data)		// ADD_SERVERbegin	local int len := _inLen div 4, encoding;	local array encodings := v.encodings := Array(len,0);	local /*string*/ msg;    for i:=0 to len-1    do begin		encodings[i] := encoding := ExtractLong(data, i*4);		msg := msg && (if encoding < 0 or encoding >= Length(kEncodingNames)			then encoding			else kEncodingNames[encoding]) & $,;		end;    v:status(LocObj("Encoding", 'encoding), msg, DO_LOG);	:nextInputLen('GetClientMessageType, STATE_LEN.GetClientMessageType);end,/*int*/ preferredEncoding: func(array supported, array encodings) // ADD_SERVERbegin	local int encoding;	foreach encoding in encodings	// viewer prefs	do  if SetContains(supported, encoding)		then return encoding;	return supported[0];	// might be nilend,SendUpdateRect: func(/*frame*/ bnds)	// ADD_SERVERif sock and _inStatethen begin	if _outState 	// output busy? it generally shouldn't be since vc sends updates only after DONE_REFRESH	then begin		//things a lot simpler if it's done. so wait a littleif DEBUG then Print(['SendUpdateRect, "WARNING", _outState]);		return AddDelayedSend(self, 'SendUpdateRect, [bnds], 100);		end;  	// already clipped, non-empty	local int x := bnds.left, y := bnds.top, w := bnds.right - x, h := bnds.bottom - y;//if DEBUG then Print(['SendUpdateRect, x,y,w,h]);	// make it easier. adjust x&w to even boundaries. assume bpp=4	if Band(x,0x1)=1	then begin		x := x-1;		w := w+1;		end;		if Band(w,0x1)=1	then w := w+1;	updateArea := Area:new(x, y, w, h, w, h);	// use viewer preferences -- if supported by newtVNC	local int encoding := updateArea.encoding := EncodingRaw;		//:preferredEncoding([EncodingRaw, EncodingHextile, /*if v.options.encoding = EncodingZlib then EncodingZlib*/], v.encodings);	updateNRects := 1;	local int fillEncoding := updateArea.fillEncoding :=		if v.options.encoding <> EncodingRaw then :preferredEncoding([nil, EncodingRRE, EncodingCoRRE], v.encodings);	local /*sym*/ next;	/*if encoding = EncodingHextile	then begin		next := 'SendHextileRect;		updateArea:setNextSize(16,16);		updateNRects := updateArea:rows();	// entire row of hextiles at a time (otherwise too slow)		if fillEncoding and updateNRects > 2		then updateNRects := updateNRects+1		else fillEncoding := nil;		end	else*/ begin // Raw (or Zlib?)		next := 'SendBitmapRect;		local int ht := h;		if (w*h > VBO_LEN)	// Raw or Zlib [big]		then begin			updateArea:setNextSize(nil, ht := VBO_LEN div w);			updateNRects := updateArea:totalRects();	// send as separate rects			if fillEncoding then updateNRects := updateNRects+1;			end		else fillEncoding := nil;	// no prog if single bm		//tmpBitmap := MakeBitmap(w, ht, {depth: _BPP});	// can't be reused, e.g., modeOr problems in datePicker		end;	local int offset := 4; 	local /*byte[]*/ data := :getOutputBuf(offset + (if fillEncoding then 17 else 0));	StuffByte(data, 0, FramebufferUpdate);	//  & pad	StuffWord(data, 2, updateNRects);	if fillEncoding	then begin // clear area when longer refresh, e.g., multiple bitmap slices		:StuffUpdateRequest(data, offset, bnds, fillEncoding);		//+5. RRE or CoRRE		StuffLong(data, offset+12, 0);	// no subrects		StuffByte(data, offset+16, kInvalidRectColor);		//offset := offset+17;		end;	//if encoding=EncodingHextile then :StuffUpdateRequest(data, offset, x, y, w, h, encoding);if DEBUG then Print(['SendUpdateRect, kEncodingNames[encoding], x,y,w,h]);if TIMING then bytesW := 0;	:nextOutput(next, data, _outLen);	//data follows incrementally via SendBitmapRect (or other encoding, e.g., SendHextileRect?)end,StuffUpdateRequest: func(/*byte[]*/ data, int offset, /*frame*/ bnds, int encoding)begin	local int x, y;	StuffWord(data, offset,    x := bnds.left);	StuffWord(data, offset+2,  y := bnds.top);	StuffWord(data, offset+4,  bnds.right - x);	StuffWord(data, offset+6,  bnds.bottom - y);	if encoding	then StuffLong(data, offset+8,  encoding);end,//tmpBitmap: nil,SendUpdateRectDone: func()		// ADD_SERVERbegin//if DEBUG then Print('SendUpdateRectDone);	// this flushes in case anything arrived during refresh. and resets _outState	//tmpBitmap := nil;	:nextOutput(nil,nil,0);	vc:Refresh(DONE_REFRESH,nil,true); // this allows updates to resumes	//input spec never stopped runningend,SendBitmapRect: func()		// ADD_SERVERbegin	local int w := updateArea.width, h := updateArea.height; //x := updateArea.left, y := updateArea.topif DEBUG then Print(['SendBitmapRect, updateArea]);	local int encoding := updateArea.encoding;	local int offset := 12 /*if encoding = EncodingRaw then 12 else 0*/, len := (w*h) + offset;	_outState := nil;	// avoid realloc buf	local /*byte[]*/ data := :getOutputBuf(len);	local int color := vc:bitmapToRaw(data, offset, updateArea); //tmpBitmap, 	if color and updateArea.fillEncoding		// area all same color (and viewer can handle RRE or CoRRE)	then begin		encoding := updateArea.fillEncoding;	// for :StuffUpdateRequest below		StuffLong(data, offset,   0);			// no subrects		StuffByte(data, offset+4, color);		len := offset+5;		end;/*	if encoding = EncodingZlib	then begin	// (inLevel) or (inLevel, inMethod, inWindowBits, inMemLevel, inStrategy)		local zlibFlater := :getZlibFlater(0, Deflater, [nil,nil,nil,v.zlibMemory,nil]);		if zlibFlater		then begin			zlibFlater:setInput(data, 0, _outLen);			offset := 16;			local zdata := byte:new(offset + (_outLen div 2)); // assume at least 2x compression			if zlibFlater:flate(zdata, offset, Length(zdata))			then begin				len := zlibFlater:length();	// incl. 16 offset				StuffLong(data := zdata, offset-4, len-offset); // zlib compressed len				end			else return NIL;			end		else return NIL;		// Deflate already reported init error		end;*/	// add update header	:StuffUpdateRequest(data, 0, updateArea, encoding);	:nextOutput(if updateArea:next() then 'SendBitmapRect else 'SendUpdateRectDone, data, len);	// since _outState=nilend,/*SendBell: func()	// ADD_SERVERbegin	local data := :getOutputBuf(STATE_LEN.SendBell);	StuffByte(data, 0, Bell);	:nextOutput(nil, data, _outLen);end,*/// VIEWER// GetClientMessageType:			// *** ADD_SERVERGetServerMessageType: func(/*byte[]*/ data)	// MAIN DISPATCH LOOP FOR VIEWERbegin	local array states := if ADD_SERVER and _inState = 'GetClientMessageType then SERVER_STATES else VIEWER_STATES;	local int msgType := min(ExtractByte(data,0), Length(states)-1);//if DEBUG then Print([_inState, (if _inState = 'GetClientMessageType then kServerMessageNames else kViewerMessageNames)[msgType]]);	:nextInputLen(states[msgType], nil);end,GetBell: func(/*byte[]*/ data)begin//if DEBUG then Print("msgType: Bell");	PlaySound(ROM_simpleBeep); // ??ROM_plinkBeep	//:nextInputLen('GetServerMessageType, STATE_LEN.GetServerMessageType)	// same state&lenend,//GetClientCutLen:			// *** ADD_SERVERGetServerCutLen: func(/*byte[]*/ data)begin	:nextInputLen(		if ADD_SERVER and _inState='GetClientCutLen then 'GetClientCutText else 'GetServerCutText,		ExtractLong(data,3));end,//GetClientCutText: func(/*byte*/ data)	// *** ADD_SERVERGetServerCutText: func(/*byte[]*/ data)begin	v.clipboard:?setCutText(:ExtractString(data,0,_inLen));	:nextInputLen(		if ADD_SERVER and _inState = 'GetClientCutText then 'GetClientMessageType else 'GetServerMessageType,		nil);end,GetUpdateRectsNum: func(/*byte[]*/ data)begin	if TIMING then bytesR := 0;	vc:setGauge(0);	progRect := updateNRects := ExtractWord(data,1); //readFramebufferUpdate;//if DEBUG then Print(_inState && "rects#" & updateNRects);	if (updateNRects = 0)		// shouldn't happen?		then :GetUpdateRectsNext();		else :nextInputLen('GetUpdateRects, STATE_LEN.GetUpdateRects);end,GetUpdateRects: func(/*byte[]*/ data) // called only by GetUpdateRectsNext or GetUpdateRectsNumbegin	updateArea := Area:new(		ExtractWord(data, 0),		ExtractWord(data, 2),		ExtractWord(data, 4),		ExtractWord(data, 6),		nil,nil);	if (updateArea.right > framebufferWidth) or (updateArea.bottom > framebufferHeight)	then return :error(LocObj("Update rectangle too large", 'largeRect),		updateArea:toString(), FATAL_ERROR);    local int updateRectEncoding := /*updateArea.encoding :=*/ ExtractLong(data, 8);	local /*string*/ ename := LocObj("Encoding", 'encoding) & $: &&		(if updateRectEncoding < 0 or updateRectEncoding >= Length(kEncodingNames)			then updateRectEncoding			else kEncodingNames[updateRectEncoding]);	v:status(ename && LocObj("rect", 'rect), updateNRects, NO_LOG);//if DEBUG then Print([ename, updateArea:toString()]);   	local int viewOriginY := vc.viewOriginY;	if (updateRectEncoding = EncodingHextile) //or (updateRectEncoding = EncodingZlibHex)	then begin		progHt := updateArea.bottom - viewOriginY;		updateArea:setNextSize(16, 16);		:nextInputLen('GetHexSubEncoding, STATE_LEN.GetHexSubEncoding);		end	else if (updateRectEncoding = EncodingRaw)	then begin		progHt := updateArea.bottom - viewOriginY;		if (updateArea:area() > VBO_LEN)		then updateArea:setNextSize(nil,16);		:nextInputLen('GetRawRectN, updateArea:area());		end	else if (updateRectEncoding = EncodingCoRRE)	then begin		local int diff := progRect-updateNRects;		if diff > 0 and Band(diff,0x3)=0	// every ~4		then vc:setGauge(diff / progRect);		:nextInputLen('GetSubRectsCoRRENum, STATE_LEN.GetSubRectsCoRRENum);		end	else if (updateRectEncoding = EncodingRRE)	then :nextInputLen('GetSubRectsRRENum, STATE_LEN.GetSubRectsRRENum);	else if (updateRectEncoding = EncodingCopyRect)	then :nextInputLen('GetCopyRect, STATE_LEN.GetCopyRect)	else if (updateRectEncoding = EncodingZlib)	then begin		if (updateArea:area() > VBO_LEN)		then updateArea:setNextSize(nil, 18);		progHt := vc.viewHeight;		:nextInputLen('GetZlibNum, STATE_LEN.GetZlibNum);		end/*	else if (updateRectEncoding = EncodingTight)	then begin		progHt := vc.viewHeight;		:nextInputLen('GetTightRectControl, STATE_LEN.GetTightRectControl);		end*/	else	 // default		:error(LocObj("Unknown rect encoding", 'rectEncoding), updateRectEncoding, FATAL_ERROR);end,GetUpdateRectsNext: func()begin	if ((updateNRects := updateNRects-1) <= 0)	then begin		v:status("", nil, NO_LOG);		vc:setGauge(1);							// update finished		Perform(vc, 'Refresh, refreshArgs); 	// setup next incremental update (now or later)		refreshArgs := _refreshArgs;			// reset (CopyRect might have changed)		:nextInputLen('GetServerMessageType, STATE_LEN.GetServerMessageType);		end	else :nextInputLen('GetUpdateRects, STATE_LEN.GetUpdateRects);end,GetZlibNum: func(/*byte[]*/ data)	:nextInputLen('GetZlibBytes, ExtractLong(data, 0)),GetZlibBytes: func(/*byte[]*/ data)begin	if (zlibFlater or zlibFlater := Inflater:new(self,nil)) and	//:getZlibFlater(0, Inflater, nil)		:drawZlibRect(zlibFlater, data, _inLen)	then begin		local fval := (updateArea.top - vc.viewOriginY) / progHt;		if fval > 0 and fval < 1		then vc:setGauge(fval);		:GetUpdateRectsNext();		end;	//else return NIL;	// Inflate(in drawZlibRect) already reported errorend,zlibFlater: 		nil,		// used in GetZlibBytes, close/*byte[]*/ tempData: nil,		// used by drawZlibRect, GetTightFilter3getTempBuf: func(int size)begin	if tempData	then if size <= Length(tempData)		then tempData		else SetLength(tempData, size)	else tempData := byte:new(size);end,Inflater: {	// more compatible with Java API and hides more zlib details	_proto: UR(kZLibSymbol, 'ProtoInflateStream),	obj: 		nil,	zstreamf: 	{},	// created by init	// a few params so code can be shared with Deflater	initMsg: 	'InflateInit,	initLen:	0,				// length of args for initMsg	initMsg2:	'InflateInit2,	initLen2:	1,				// length of args for initMsg2	flateMsg:	'Inflate,	endMsg:		'InflateEnd,	//resetMsg:	'InflateReset,		new: func(obj, array args)	// [-15] for no zlib header (e.g., .zip)		begin			local inf :=				{_proto: self,				obj: obj,		// for status, error				closed: nil,				};			local int argLen := if args then Length(args) else 0;			//or could use GetFunctionArgCount			local /*symbol*/ msg := if argLen=initLen then initMsg else if argLen=initLen2 then initMsg2;			local int err := if msg then Perform(inf, msg, args) else "#args:" & argLen;			if err			then inf:error(msg, err, FATAL_ERROR)			else inf;		end,	error: func(/*symbol*/ msg, earg, /*boolean*/ fatal)		obj:?error(msg && zstreamf.msg, earg, fatal),	close: func()		begin			local err;			if not closed			then try begin					closed := true;					err := Perform(self, endMsg, nil);					end				onexception |evt.ex|				do err := currentException();			if err			then :error(endMsg, err, IGNORE_ERROR);			nil;		end,	setInput: func(/*byte[]*/ data, int offset, int len)		begin			zstreamf.bin_in 	:= data;			zstreamf.next_in 	:= offset;			zstreamf.avail_in 	:= len;		end,	flate: func(/*byte[]*/ data, int offset, int len)		begin			zstreamf.bin_out 	:= data;			zstreamf.next_out 	:= offset;			zstreamf.avail_out 	:= len;			local int err := Perform(self, flateMsg, ['sync]);	// 'finish ??? does Perform(inherited, work?)			if err and (err <> Z_STREAM_END or zstreamf.avail_out <> 0)			then :error(flateMsg, err, FATAL_ERROR);			else true;		end,},  // bitmap is compressed/*boolean*/ drawZlibRect: func(/*Inflater*/ zlibFlater, /*byte[]*/ data, int len)begin//if DEBUG then Print(['drawZlibRect, 'data, data, len, updateArea:area(), updateArea]);	zlibFlater:setInput(data, 0, len);			local /*byte[]*/ rowData := :getTempBuf(updateArea:area());	repeat begin		len := updateArea:area();//if DEBUG then Print(['drawZlibRect, 'rowData, rowData, len, updateArea]);		if zlibFlater:flate(rowData, 0, len)		then vc:drawRawRect(rowData, updateArea)		else return NIL;	// Inflate already reported error		end	until not updateArea:next();	//zlibFlater:reset();	TRUE;end,// else nil = no inflater// for Tight, see rfbProto_Tight.txt (it works, but looks slower than Zlib)GetRawRectN: func(/*byte[]*/ data)begin//if DEBUG then Print([_inState, updateArea]);	vc:drawRawRect(data, updateArea);	local int y := updateArea:next();	if y	then begin		if y > 0 and y < progHt	// should always be true, but just in case...		then vc:setGauge(y / progHt);		:nextInputLen(_inState, updateArea:area());		end	else :GetUpdateRectsNext();end,RectEqual: kRectEqual,GetCopyRect: func(/*byte[]*/ data)begin	local int sx := ExtractWord(data,0), sy := ExtractWord(data,2);	local int dx := updateArea.left,  dy := updateArea.top;	local int w  := updateArea.width, h  := updateArea.height;	local /*frame*/ vbnds := vc.remoteBounds, sbnds := RelBounds(sx, sy, w, h);	local /*frame*/ dbnds := updateArea, dibnds;	if not :RectEqual(dibnds := SectRect(vbnds,dbnds), kRect0)	then begin	// dest is at least partially on screen		refreshArgs := Clone(refreshArgs);		refreshArgs[1] := NO_DELAY; // start next update asap (since there might be holes)			if :RectEqual(sbnds, SectRect(vbnds,sbnds))		then begin			if not :RectEqual(dbnds, dibnds)			then begin // dest not entirely on screen. adjust bounds				local int left := dibnds.left, top := dibnds.top;				local int dim  := dibnds.right - left;				if dx < left				then begin // moved left off screen					dx := left;					sx := sx + w - dim;					end;				w := dim;				dim := dibnds.bottom - top;				if dy < top				then begin // moved up off screen					dy := top;					sy := sy + h - dim;					end;				h := dim;if DEBUG then Print([_inState, "adjust (clip src,dst)", sx, sy, dx, dy, w, h]);				dbnds := RelBounds(dx, dy, w, h);				end			else if DEBUG then Print([_inState, "normal", dx, dy, w, h]);			vc:copyRect(sx, sy, dbnds);			end				else begin // source not entirely on screen. so, do a full refresh on destination rectangle			// this assumes only one copyRect per update ???if DEBUG then Print([_inState, "full refresh (src partly off)", sx, sy, dbnds]);			refreshArgs[0] := FULL_REFRESH;			refreshArgs[2] := dbnds;			// no copy			end;		end	else if DEBUG then Print([_inState, "no copy (dest off screen)", dbnds]);	:GetUpdateRectsNext();end,//GetSubRectsRRENum:GetSubRectsCoRRENum: func(/*byte[]*/ data)begin	updateArea.color := ExtractByte(data,4);	vc:fillRectA(updateArea);	nSubRects := ExtractLong(data,0);	if _inState = 'GetSubRectsRRENum	then progRect := nSubRects; // use updateNRects for CoRRE//if DEBUG then Print([_inState, "subrects#", nSubRects, $@, updateArea:toString()]);if PROFILE then vc:testFreq('nSubRects, nSubRects);	if (nSubRects = 0) // unlikely?	then return :GetUpdateRectsNext();	local /*symbol*/ next := if (_inState = 'GetSubRectsCoRRENum) then 'GetSubRectsCoRREN else 'GetSubRectsRREN;	local int itemSize := STATE_LEN.(next);	// pre-a1 = 1 rect at a time; a2 = all rects; a3 = intermediate # to avoid heap/VBO problems and show progress	:nextInputLen(next, itemSize*min(nSubRects, VBO_LEN div itemSize));end,fillSubrects: func(/*byte[]*/ data, int inc, int nrects, /*boolean*/ getColor, /*func*/ fn)begin // shared by GetHexSubEncodingSubrectN, ...FGN; GetSubRectsRREN, ...CoRREN	local /*frame*/ vbnds := vc.remoteBounds;	local x := vbnds.left, y := vbnds.top;	local int left := updateArea.left, top := updateArea.top, w := updateArea.width, h := updateArea.height;	if left < x	then begin		w := w - (x - left);		left := x;		end;	if top < y	then begin		h := h - (y - top);		top := y;		end;	if w <= 0 or h <= 0	then return if DEBUG then Print([_inState, "skipping rects#", nrects, $@, updateArea:toString()]);	local int hstate := 0;	// for Hextile: x=0,y=1,w=2,h=3	if inc = 0	then fn := func(/*byte[]*/ d, int off)	// get 1/2 byte for Hextile		begin // define here to get closure access to hstate and inc			local int val := ExtractByte(d, off);			val := if (inc := Band(hstate,0x1)) = 1		// inc =1 y,h; =0 x,w				then Band(val, 0xF);				else val div 16;			if hstate >= 2	// w,h			then val := val+1;			hstate := if hstate >= 3 then 0 else hstate+1;			val;		end;	local int i, color, offset := 0;	for i:=1 to nrects	do begin		if getColor		then begin			color := ExtractByte(data, offset);			offset := offset+1;			end;		// else color=nil in :setColor means keep using current color		x := left + call fn with (data, offset);		offset := offset+inc;		y := top + call fn with (data, offset);		offset := offset+inc;		w := call fn with (data, offset);		offset := offset+inc;		h := call fn with (data, offset);		offset := offset+inc;		vc:fillRect(color, x, y, w, h); // clips w,h if nec		end;end,//GetSubRectsRREN:  // *** share with GetSubRectsCoRRENGetSubRectsCoRREN: func(/*byte[]*/ data)begin	local /*boolean*/ short := (_inState = 'GetSubRectsCoRREN);	local int itemSize := STATE_LEN.(_inState);	local int trects := _inLen div itemSize;	:fillSubrects(data, if short then 1 else 2, trects, true, GetGlobalFn(if short then 'ExtractByte else 'ExtractWord));	if (nSubRects := nSubRects - trects) <= 0	then return :GetUpdateRectsNext();	vc:setGauge((progRect-nSubRects) / progRect);	:nextInputLen(_inState, min(_inLen, nSubRects*itemSize));end,//GetHexSubEncodingSubrectFGN:  // *** share with GetHexSubEncodingSubrectNGetHexSubEncodingSubrectN: func(/*byte[]*/ data)begin	:fillSubrects(data, 0, nSubRects, _inState = 'GetHexSubEncodingSubrectFGN, nil);	:GetHexSubEncodingNext();end,GetHexSubEncoding: func(/*byte[]*/ data) // called only by GetHexSubEncodingNext or GetUpdateRectsbegin	local int len := 0, subencoding := updateArea.encoding := ExtractByte(data,0);	if (Band(subencoding, HextileRaw) <> 0)	then return :nextInputLen('GetHexSubEncodingRaw, updateArea:area());/*	if (Band(subencoding, HextileZlibRaw) <> 0)	then return :nextInputLen('GetHexSubEncodingZlibRawNum, STATE_LEN.GetHexSubEncodingZlibRawNum);	if (Band(subencoding, HextileZlibHex) <> 0)	then return :nextInputLen('GetHexSubEncodingZlibHexNum, STATE_LEN.GetHexSubEncodingZlibHexNum);*/	if (Band(subencoding, HextileBackgroundSpecified) <> 0)	then len := len+1;    if (Band(subencoding, HextileForegroundSpecified) <> 0)	then len := len+1;	if (Band(subencoding, HextileAnySubrects) <> 0)	then len := len+1;	if (len = 0)	then begin // just fill in background rect		vc:fillRectA(updateArea);		:GetHexSubEncodingNext();		end	else :nextInputLen('GetHexSubEncoding3, len);end,GetHexSubEncoding3: func(/*byte[]*/ data)begin	// basically repeat latter logic in GetHexSubEncoding now that up to 3 bytes of data is here	local int offset := 0, subencoding := updateArea.encoding;	if (Band(subencoding, HextileBackgroundSpecified) <> 0)	then begin		updateArea.color := ExtractByte(data, offset);		offset := offset+1;		end;	vc:fillRectA(updateArea);	if (Band(subencoding, HextileForegroundSpecified) <> 0)	then begin		updateArea.fcolor := ExtractByte(data, offset);		offset := offset+1;		end;	if (Band(subencoding, HextileAnySubrects) = 0)	then return :GetHexSubEncodingNext();	nSubRects := ExtractByte(data, offset);if PROFILE then vc:testFreq('nSubRects, nSubRects);	local /*symbol*/ next := 'GetHexSubEncodingSubrectN;	if (Band(subencoding, HextileSubrectsColoured) <> 0)	then next := 'GetHexSubEncodingSubrectFGN	else vc:setColor(updateArea.fcolor);	:nextInputLen(next, nSubRects * STATE_LEN.(next));end,GetHexSubEncodingNext: func()begin	local int y := updateArea:next();	if y	then begin		if y > 0 and y < progHt and Band(y,0x3)=0	// just every ~4 ??		then vc:setGauge(y / progHt);		// only at beginning of a row. ?? might go backwards		:nextInputLen('GetHexSubEncoding, STATE_LEN.GetHexSubEncoding);		end	else :GetUpdateRectsNext();end,GetHexSubEncodingRaw: func(/*byte[]*/ data)begin	vc:drawRawRect(data, updateArea);	:GetHexSubEncodingNext();end,// =====		encryptChallenge: func(/*byte[]*/ challenge, /*string*/ pw)begin    local int pwlen := StrLen(pw), i;    local /*byte[]*/ key := :getOutputBuf(CHALLENGE_LEN2);    for i:=0 to CHALLENGE_LEN2-1    do StuffChar(key, i, if (i < pwlen) then pw[i] else 0);//if DEBUG then call kPrintBytes with (challenge, 0,nil, "challenge(orig)");//if DEBUG then call kPrintBytes with (key, 0,nil, "key");    local /*DesCipher*/ des := DesCipher:new(key);    des:encrypt(challenge,0,challenge,0);    des:encrypt(challenge,CHALLENGE_LEN2,challenge,CHALLENGE_LEN2);//if DEBUG then Print("auth: writing challenge");//if DEBUG then call kPrintBytes with (challenge, 0,nil, "challenge(des)");	challenge;end,// A buffer for putting pointer and keyboard events before being sent.  This// is to ensure that multiple RFB events generated from a single Java Event// will all be sent in a single network packet.  The maximum possible// length is 4 modifier down events, a single key event followed by 4// modifier up events i.e. 9 key events or 72 bytes./*byte[]*/ eventBuf: nil, // reused for temp output by non-event methods too/*int*/ eventBufLen: nil,///*int*/ pointerMask: 0,// Write a pointer event message.  We may need to send modifier key events// around it to set the correct modifier state.  Also buttons 2 and 3 are// represented as having ALT and META modifiers respectively. ???/*int*/ writeButtonEvent: func(/*byte*/ data, int offset, int but, int x, int y)begin	StuffByte(data, offset,   PointerEvent);	StuffByte(data, offset+1, but);	StuffWord(data, offset+2, x);	StuffWord(data, offset+4, y);	offset+6;end,/*boolean*/ writePointerEvent: func(int modifiers, int but1, int x1, int y1, int but2, int x2, int y2)if inNormalProtocolthen begin // assume no kbd modifiersif PROFILE then vc:testFreq('writePointerEvent2, 1);	// but1, but2 are pointerMask(s)    local /*byte[]*/ data := :getOutputBuf(		(if modifiers=0 then 0 else 64) + (if but2=kButOff then 12 else 6));    eventBufLen := 0;    if (modifiers <> kNoModifiers)    then eventBufLen := :writeModifierKeyEvents(data, eventBufLen, modifiers);	eventBufLen := :writeButtonEvent(data, eventBufLen, but1, x1, y1);	// down (or up for move)	if (but2 = kButOff)	// immediately send 'up' event ?	then eventBufLen := :writeButtonEvent(data, eventBufLen, but2, x2, y2);    if (modifiers <> kNoModifiers)	// if on, release    then eventBufLen := :writeModifierKeyEvents(data, eventBufLen, 0);    :nextOutput(nil, data, eventBufLen);end,// Write a key event message.  We may need to send modifier key events// around it to set the correct modifier state.  Also we need to translate// from the Java key values to the X keysym values used by the RFB protocol./* Newton key flags:0 to 7	The keycode.8 to 23	The 16-bit character that would be inserted if none of the modifier keys were pressed.24	Indicates whether the key was delivered from an on-screen keyboard. (kIsSoftKeyboard)25	Indicates that the Command key was down. (kCommandModifier)26	Indicates that the Shift key was down. (kShiftModifier)27	Indicates that the Caps Lock key was down. (kCapsLockModifier)28	Indicates that the Option key was down. (kOptionsModifier)29	Indicates that the Control key was down. (kControlModifier)*/// used by statusView.keydown/up; send-ctrl-Alt-Del; gesture(BS)/*boolean*/ writeKeyEvent: func(int updown, int key, int modifiers)if inNormalProtocolthen beginif PROFILE then vc:testFreq('writeKeyEvent, 1);	// A 'normal' key press.  Ordinary ASCII & Latin-1 characters go straight	// through.  For CTRL-<letter>, CTRL is sent separately so just send	// <letter>.  Backspace, tab, return, escape and delete have special	// keysyms.  Anything else we ignore.	local int i;	if i := SetContains(ARROW_KEYS_NWT, key)	then key := ARROW_KEYS_VNC[i]	else if i := SetContains(F_KEYS_NWT, key)	then key := F_KEYS_VNC+i	else if (key < 32)	then begin		if (Band(modifiers, kControlModifier) <> 0)		then begin	  		key := key + 96;	  		if (key = 127) // CTRL-_			then key := 95;			end	    else if i := SetContains(SPEC_KEYS_NWT, key)	    then key := SPEC_KEYS_VNC[i];		end;/* // mapped in 'ARROW_KEYS'	else if (key < 256) then		// For Latin-1, Unicode and X keysyms should be the same...		if (key = chDEL) // except delete		then key := 0xffff;*/    eventBuf := :getOutputBuf(112); 	// <= 32*3 + 2*8. this will realloc if necessary    eventBufLen := :writeModifierKeyEvents(eventBuf, 0, modifiers);    eventBufLen := :writeKeyEventBytes	  (eventBuf, eventBufLen, key, updown); // KEY_PRESS    // also write out 'up'    eventBufLen := :writeModifierKeyEvents(eventBuf, eventBufLen, modifiers);    eventBufLen := :writeKeyEventBytes	  (eventBuf, eventBufLen, key, updown := KEY_RELEASE);    // Always release all modifiers after an 'up' Event    //if (updown = KEY_RELEASE) then     eventBufLen := :writeModifierKeyEvents(eventBuf, eventBufLen, 0);    :nextOutput(nil, eventBuf, eventBufLen);end,// Add a raw key event with the given X keysym to eventBuf./*int*/ writeKeyEventBytes: func(/*byte[]*/ data, int offset, int keysym, int updown)begin    StuffByte(data, offset,   KbdEvent);    StuffByte(data, offset+1, updown);    //StuffWord(data, offset+2, 0);	//padding    StuffLong(data, offset+4, keysym);    offset+8;end,// Write key events to set the correct modifier state./*int*/ oldModifiers: 0,/*int*/ writeModifierKeyEvents: func(/*byte[]*/ data, int offset, int newModifiers)begin    local int i, mask, nmask; // options=meta, command=alt ??    foreach i,mask in MODIFIERS_NWT    do  if (nmask := Band(newModifiers, mask)) <> Band(oldModifiers, mask)		then offset := :writeKeyEventBytes(data, offset, MODIFIERS_VNC[i], if nmask <> 0 then KEY_PRESS else KEY_RELEASE);    oldModifiers := newModifiers;    offset;end,// 8-bit chars/*string*/ ExtractString: func(/*byte[]*/ data, int offset, int len)begin	local int i;	local /*binary*/ s := MakeBinary((len*2)+2, 'string);	for i := 0 to len-1	do StuffByte(s, (i*2)+1, ExtractByte(data, offset+i));	s;end,});// *** share some methodsrfbProto.GetSubRectsRREN			:= rfbProto.GetSubRectsCoRREN;rfbProto.GetSubRectsRRENum 			:= rfbProto.GetSubRectsCoRRENum;rfbProto.GetHexSubEncodingSubrectFGN:= rfbProto.GetHexSubEncodingSubrectN;//rfbProto.GetTightNonMono			:= rfbProto.GetRawRect;if ADD_SERVERthen begin	rfbProto.GetClientVersion 		:= rfbProto.GetServerVersion;	rfbProto.GetClientCutText		:= rfbProto.GetServerCutText;	rfbProto.GetClientCutLen		:= rfbProto.GetServerCutLen;	rfbProto.GetClientMessageType	:= rfbProto.GetServerMessageType;	endelse begin	RemoveSlot(rfbProto, 'setSize);	RemoveSlot(rfbProto, 'setName);	end;if TIMINGthen begin	rfbProto.bytesR := 0;	rfbProto.bytesW := 0;	end;/*if not ADD_SERVERthen begin		call func(fr1, fr2, removeSlots)	begin		local slot;		foreach slot in removeSlots		do begin			RemoveSlot(fr1, slot);			RemoveSlot(fr2, slot);			end;	end with (STATE_LEN, rfbProto, '[SendUpdateRect,SendBitmapRect, SendBitmapRectNext		GetClientVersion, GetClientChallenge, GetClientInit,		GetClientMessageType, GetEncodingsLen, GetEncodings,		GetClientCutLen, GetClientCutText, GetUpdateRequest,		GetPointerEvent, GetKbdEvent]);	end;*/	// a little doublechecking (make sure states exist)call func(fr1, fr2)begin	local slot,val;	foreach slot,val in Clone(fr1)	do begin		if not fr2.(slot)		then Print("rfbProto missing: " & slot);		if val <= 0	// unused  (only for doc/checking)		then RemoveSlot(fr1, slot);		end;end with (STATE_LEN, rfbProto);