// some of these used elsewhereDeclareGlobalFn('ClearVBOCache, 1);DeclareGlobalFn('InetOpenConnectionSlip, 3);DeclareGlobalFn('InetGrabLink, 3);DeclareGlobalFn('InetGrabLinkVerbose, 3);DeclareGlobalFn('InetIsValidIPAddressStr, 1);DeclareGlobalFn('InetIPStringToAddress, 1);DeclareGlobalFn('DNSGetAddressFromName, 3);DeclareGlobalFn('InetReleaseLink, 3);DeclareGlobalFn('InetReleaseLinkVerbose, 3);DeclareGlobalFn('InetCancelLink, 3);DeclareGlobalFn('GetGlobalFnExists, 1);DeclareGlobalFn('InetGetErrorString, 1);DeclareGlobalFn('InetGetIPAddress, 1);DeclareGlobalFn('InetIPAddressToString, 1);constant kEventDisconnect	:= 2;constant kEventRelease		:= 3;DefineGlobalConstant('kSetClone, func(obj, array path, val)begin // used for patching options	if isReadonly(obj)	then obj := Clone(obj);	local nobj := obj;	local int i, last := Length(path)-1;	foreach i,path1 in path	do nobj := nobj.(path1) := if i=last then val else Clone(nobj.(path1));	obj;end);// modify /**/ via SetClone//DefineGlobalConstant('Socket, {_proto: protoBasicEndPoint,instantiateOptions: [	{label:	"inet",	type:	'service,	opCode:	opSetRequired,	result:	nil,	},	{label:	"ilid",			// set the link id	type:	'option,	opCode:	opSetRequired,	result:	nil,	form:	'template,	data:	{		arglist: [nil],		// linkID /**/		typelist:	[			'struct,			'ulong,			],		},	},			{label:	"itsv",			// set the transport protocol (TCP or UCP)	type:	'option,	opCode:	opSetRequired,	result:	nil,	form:	'template,	data: {		arglist: [1],		// protocol (== TCP)		typelist: [			'struct,			'ulong,			],		},	}],bindOptions: [	{label:		"ilpt",		// set the local port	type:		'option,	opCode:		opSetRequired,	result:		nil,	form:		'template,	data:	{		arglist: [			0,				// local port number			true,			// use default port	 /**/			],		typelist:	[			'struct,			'short,			'boolean,			],		},	}],connectOptions: [	{label:	"itrs",			// set the TCP remote socket	type:	'option,	opCode:	opSetRequired, //***	result:	nil,	form:	'template,	data:	{		arglist: [0,0,0,0,0],		/**/		/*	[			remoteAddr[0],	// remote host addr - byte 1			remoteAddr[1],	// remote host addr - byte 2			remoteAddr[2],	// remote host addr - byte 3			remoteAddr[3],	// remote host addr - byte 4			remotePort,		// remote port number 			],			*/				typelist: [			'struct,			'byte,			'byte,			'byte,			'byte,			'short,			],		},	}],exceptionHandler: func(/*frame*/ ex)begin	rfb:?error(LocObj("ep:exceptionHandler",'exceptionHandler) & $: & ex.name, ex.debug && ex.data, IGNORE_ERROR);end,//http://www.unna.org/unna/apple/Newton_Development/tech_info/QAs/html/e36006.htmeventHandler: func(/*frame*/ ev)begin	if ev.eventCode <> kEventDisconnect	then rfb:?error(LocObj("ep:eventHandler",'eventHandler), ev.eventCode, IGNORE_ERROR);end,OutputSpec: {	async:		true,	form:		'binary,	CompletionScript: func(ep, options, result)	// no context	begin		// note: rfb local to this outputSpec		if result		then AddDeferredSend(rfb, 'error, [LocObj("ep:output", 'epOutput), result, FATAL_ERROR])		else if rfb._outState		then AddDeferredSend(rfb, rfb._outState, nil);	// doesn't need to stay in this context (like input)	end,},InputSpec: {	async:		true,	reqTimeout:	kNoTimeout, 	form: 		'binary,	InputScript: func(ep, data, terminator, options)	// no context	begin		// note: _inLen, rfb are local to this inputSpec		local /*symbol*/ _inState := rfb._inState;		if _inLen = terminator.byteCount		then begin			if _inState			then Perform(rfb, _inState, [data]); 		// rfb does :SetInputSpec w/in this context			end		else rfb:error(LocObj("ep:input", 'epInput), _inState && _inLen, FATAL_ERROR);	end,	CompletionScript: func(ep, options, result)	begin		if result <> -16005	// expected from disconnect		then AddDeferredSend(rfb, 'error, [LocObj("ep:input", 'epInput), result, FATAL_ERROR]);	end,},new: func(/*String*/ h, int p, rfb)begin	local sock := {_proto: self, host: h, port: p, rfb: rfb};	//AddDeferredSend(sock, '_getConnection, nil);	rfb:status(sock._status := LocObj("NIE:Connect", 'NIE_Connect), nil, DO_LOG);	AddDeferredCall(GetGlobalFn('InetOpenConnectionSlip), [nil, sock, '_getConnectionCallback]);	sock;end,rfb: 			nil,host: 			nil,		// if empty/nil, then Listen (i.e., server mode)port: 			nil,_linkID: 		nil,_status: 		nil,_address: 		nil,_closeCallback: nil,/*_getConnection: func()begin	rfb:status(_status := LocObj("NIE:Connect", 'NIE_Connect), nil, DO_LOG);	InetOpenConnectionSlip(nil, self, '_connectionSlipCallback);end,*/_getConnectionCallback: func(/*symbol*/ what)begin	if what = 'connect	then begin		//AddDeferredSend(self, '_grabLink, nil);		_status := LocObj("NIE:GrabLink", 'NIE_GrabLink);		local fn := GetGlobalFn('InetGrabLinkVerbose);		AddDeferredCall(if fn then fn else GetGlobalFn('InetGrabLink), [_linkID, self, '_grabLinkCallback]);		end	else if what = 'close	then rfb:error(_status, LocObj("no connection", 'NIE_noConnect), FATAL_ERROR);	//else if what <> _status	//then rfb:status(LocObj("NIE:Connect", 'NIE_Connect), _status := what, DO_LOG);end,/*_grabLink: func()begin	_status := LocObj("NIE:GrabLink", 'NIE_GrabLink);	//rfb:status(_status := LocObj("NIE:GrabLink", 'NIE_GrabLink), nil, DO_LOG);	local fn := GetGlobalFn('InetGrabLinkVerbose);	call (if fn then fn else GetGlobalFn('InetGrabLink)) with (_linkID, self, '_grabLinkCallback);end,*/_grabLinkCallback: func(int linkID, /*frame*/ status, result)begin	_linkID := linkID;//if DEBUG then Print("grabLink:" && _linkID);	if result	then begin		rfb:error(_status, result, IGNORE_ERROR);	// cancel first		InetCancelLink(_linkID, self, '_cancelLinkCallback);		end	else if (status := status.linkStatus) = 'connected	then begin		_closeCallback := '_releaseLink;		AddDeferredSend(self, if StrFilled(host) then '_getDNS else '_Instantiate, nil);		end;	//else if status <> _status	//then rfb:status(LocObj("NIE:GrabLink", 'NIE_GrabLink), _status := status, DO_LOG);end,_cancelLinkCallback: func(int linkID, /*frame*/ status, result)begin	rfb:error(LocObj("NIE:CancelLink", 'NIE_CancelLink), result, FATAL_ERROR); // this should trigger releaseLink via :closeend,_getDNS: func()	// viewer onlybegin	if InetIsValidIPAddressStr(host)	// e.g., 205.134.252.158	then :_getDNScallback([{resultIPAddress: InetIPStringToAddress(host)}], nil)	else begin		rfb:status(_status := LocObj("DNS:Lookup", 'DNS_Lookup), host, DO_LOG);		DNSGetAddressFromName(host, self, '_getDNScallback);		end;end,_getDNScallback: func(array addr, result)	// viewer onlybegin	if result		or not addr		or Length(addr) < 1	then return rfb:error(_status, result, FATAL_ERROR);	_address := addr[0].resultIPAddress;	rfb:status(LocObj("DNS:Found", 'DNS_Found),		if InetIsValidIPAddressStr(host)		then host		else host & $: && InetIPAddressToString(_address), DO_LOG);	:_Instantiate();end,_Instantiate: func() // can be called directly from grablink (for server skipping DNS)begin	rfb:status(_status := LocObj("ep:Instantiate", 'epInstantiate), nil, DO_LOG);	local array options := call kSetClone with (instantiateOptions, '[pathExpr: 1,data,arglist], [_linkID]);	try :Instantiate(self, options);	onexception |evt.ex|	do return rfb:error(_status, currentException(), FATAL_ERROR);	_closeCallback := '_Dispose;	//:_Bind();	rfb:status(_status := LocObj("ep:Bind", 'epBind), nil, DO_LOG);	options := call kSetClone with (bindOptions, '[pathExpr: 0,data,arglist,1], port);	try :Bind(options, _bindCallback)	onexception |evt.ex|	do _bindCallback:CompletionScript(self, nil, currentException());	end,_bindCallback: {	// no contextasync: true,CompletionScript: func(ep, options, result)begin	//local rfb := ep.rfb;	if result then return ep.rfb:error(ep._status, result, FATAL_ERROR);	ep._closeCallback := '_Cancel;	if ep._address	then ep:_Connect()	else ep:_Listen();	// :_option()end,},_Connect: func()	// viewer onlybegin	rfb:status(_status := LocObj("ep:Connect", 'epConnect), LocObj("Viewer", 'viewer), DO_LOG);	local options := call kSetClone with (connectOptions, '[pathExpr: 0,data,arglist],		SetAdd(Clone(_address), port, nil));	try :Connect(options, _connectCallback);	onexception |evt.ex|	do _connectCallback:CompletionScript(self, nil, currentException());end,_connectCallback: {	// no context. also used by Acceptasync: true,CompletionScript: func(ep, options, result)begin	local rfb := ep.rfb;	if result then return rfb:error(ep._status, result, FATAL_ERROR);	AddDeferredSend(rfb, 'connected, nil);end,},_Listen: func()	// ADD_SERVERbegin	rfb:status(LocObj("ep:Listen", 'epListen), LocObj("Server", 'server), DO_LOG);	_status := 'waiting;	try :Listen(connectOptions, _listenCallback)	onexception |evt.ex|	do _status := currentException; //_listenCallback:CompletionScript(self, nil, currentException());	local progressOptions := {		closeBox: nil,		statusText: kAppName & unicodeCR & LocObj("Local IP", 'localIP) & $: && InetIPAddressToString(InetGetIPAddress('localAddress)),       	barber: true,		titleText: 	LocObj("Waiting for viewer to connect", 'waitingConnect),		};	if _status = 'waiting	then DoProgress('vBarber, progressOptions, func(progressView)		while _status = 'waiting		do begin			try progressView:SetStatus('vBarber, progressOptions)			onexception |evt.ex.cancel|			do break _status := LocObj("Stopped by user", 'userStop);			Sleep(20);			end;		);	// here via _listenCallback or Stop	if _status	then return rfb:error(LocObj("ep:Listen", 'epListen), _status, FATAL_ERROR);	//:_Accept();	rfb:status(_status := LocObj("ep:Accept", 'epAccept), nil, DO_LOG);	try :Accept(nil, _connectCallback)	onexception |evt.ex|	do _connectCallback:CompletionScript(self, nil, currentException());end,_listenCallback: {	// ADD_SERVER. no contextasync: true,CompletionScript: func(ep, array options, result)begin	//local rfb := ep.rfb;	if not (ep._status := result)	then ep._address := options[0].data.arglist; // for 'serverName', etc. later	// now exit DoProgress in _listen...end,},/*_Accept: func()	// ADD_SERVERbegin	rfb:status(_status := LocObj("ep:Accept", 'epAccept), nil, DO_LOG);	try :Accept(nil, _connectCallback)	onexception |evt.ex|	do _connectCallback:CompletionScript(self, nil, currentException());end,*/close: func()begin	if _closeCallback	then Perform(self, _closeCallback, nil);	NIL;end,_Cancel: func()		// _closeCallbackbegin	rfb:status(_status := LocObj("ep:Cancel", 'epCancel), nil, DO_LOG);	try :Cancel(_cancelCallback)	onexception |evt.ex|	do _cancelCallback:CompletionScript(self, nil, currentException());end,_cancelCallback: {	// no contextasync: true,CompletionScript: func(ep, options, result)begin	local rfb := ep.rfb;	if result and result <> -36003	then rfb:error(ep._status, result, IGNORE_ERROR);	// continue cleanup//	try ep:setInputSpec(nil) onexception |evt.ex|//	do rfb:error(LocObj("ep:setInputSpec", 'epSetInput), nil, IGNORE_ERROR);	//:_Disconnect();	rfb:status(ep._status := LocObj("ep:Disconnect", 'epDisconnect), nil, DO_LOG);	try ep:Disconnect(nil, ep._disconnectCallBack)	onexception |evt.ex|	do ep._disconnectCallBack:CompletionScript(ep, nil, currentException());end,},_disconnectCallBack: {	// no contextasync: true,CompletionScript: func(ep, options, result)begin	local rfb := ep.rfb;	if result	then begin		rfb:error (ep._status, result, IGNORE_ERROR);		AddDelayedSend(ep, '_Unbind, nil, 1000);		end	else ep:_Unbind();end,},_Unbind: func()	// _closeCallbackbegin	rfb:status(_status := LocObj("ep:Unbind", 'epUnbind), nil, DO_LOG);	try :UnBind(_UnbindCallback);	onexception |evt.ex|	do _UnbindCallback:CompletionScript(self, nil, currentException());end,_UnbindCallback: {	// no contextasync: true,CompletionScript: func(ep, options, result)begin	//local rfb := ep.rfb;	if result	then ep.rfb:error(ep._status, result, IGNORE_ERROR);	ep:_Dispose();end,},_Dispose: func()		// _closeCallbackbegin	rfb:status(_status := LocObj("ep:Dispose", 'epDispose), nil, DO_LOG);	try :Dispose()	onexception |evt.ex|	do rfb:error(_status, currentException(), IGNORE_ERROR);	:_releaseLink();end,_releaseLink: func()	// _closeCallbackbegin	rfb:status(_status := LocObj("NIE:ReleaseLink", 'NIE_ReleaseLink), _linkID, DO_LOG);	local fn := GetGlobalFn('InetReleaseLinkVerbose);	call (if fn then fn else GetGlobalFn('InetReleaseLink)) with (_linkID, self, '_releaseLinkCallback);end,//InetReleaseLinkVerbose(179601, {cb: func(linkID, status, result) nil}, 'cb)_releaseLinkCallback: func(int linkID, status, result)begin	_linkID := nil;	if result	then rfb:error(_status, result, IGNORE_ERROR);	// ?? figure we're disconnected whether in progress, error or done	rfb:disconnected();end,readBytes: func(/*byte[]*/ buf, int start, int count)	:setInputSpec({		_proto: InputSpec,		target: {data: buf, offset: start},		termination: {byteCount: count},		_inLen: count, // add these for convenience. not _inState since it might change for same len		rfb: rfb,		}),writeBytes: func(/*byte[]*/ buf, int start, int count)begin	:Output(buf, nil, {		_proto: OutputSpec,		target: {offset: start, length: if count then count else Length(buf)},		rfb: rfb		});end,});// *** remove items unused by viewer/serverif not ADD_SERVERthen begin // viewer	RemoveSlot(Socket, '_Listen);	RemoveSlot(Socket, '_listenCallback);	end;