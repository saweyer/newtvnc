// Text of project newtVNC.ntk written on 11/29/01 at 11:27 AM// Beginning of text file ZLib.unit/*	File:		ZLib.unit	Project:	ZLib - Public NewtonScript Interface*/DefConst( 'kZLibVersionStr, "1.1.3" );DefConst( 'kZLibSymbol, '|ZLib:Kallisys| );DefConst( 'kZLibMajor, 1 );DefConst( 'kZLibMinor, 0 );DeclareUnit( kZLibSymbol, kZLibMajor, kZLibMinor,{// GetZLibVersion: func ()// You may want to compare the result of this function with kZLibVersion	GetZLibVersion:	0,// ProtoDeflateStream: frame with five slots//	DeflateInit: func( inLevel ),//	DeflateInit2: func( inLevel, inMethod, inWindowBits, inMemLevel, inStrategy ),//	Deflate: func( inFlush ),//	DeflateEnd: func(),//	DeflateReset: func()// Cf doc.	ProtoDeflateStream: 1,// ProtoInflateStream: frame with five slots//	InflateInit: func(),//	InflateInit2: func( inWindowBits ),//	Inflate: func( inFlush ),//	InflateEnd: func(),//	InflateReset: func()// Cf doc.	ProtoInflateStream: 2} );// End of text file ZLib.unit// Beginning of text file LanguageData.txtDefineGlobalConstant('kLocalizationFrame, {});SetLocalizationFrame(kLocalizationFrame); // use with LocObj(defaultStr, 'symbol)kLocalizationFrame.English := {// aboutabout:				"About",vnc:				"Virtual Network Computer",aboutTextC:			"use your Newton\n\tto view & control a remote system.",aboutTextS:			"view & control your Newton\n\tfrom a remote system.",newton:				"Newton",// clipboard/logclipboard:			"ClipBoard",log:				"Log",clear:				"Clear",saveServer:			"Save to Server",// actionhide:				"Hide",refresh:			"Refresh",//rotate:			"Rotate",//open:				"Open",copy:				"Copy",cut:				"Cut",paste:				"Paste",undo:				"Undo",selectAll:			"Select All",cad:				"Ctrl-Alt-Del",overview:			"Overview",quit:				"Quit",//close/quit??// Socket.ns.  	ep = EndPoint. NIE = Newton Internet Enabler. DNS=Domain Name Service(?)error:				"error",check:				"check",NIE_Connect:		"NIE:Connect",NIE_noConnect:		"no connection",NIE_GrabLink:		"NIE:GrabLink",NIE_CancelLink:		"NIE:CancelLink",NIE_ReleaseLink:	"NIE:ReleaseLink",DNS_Lookup:			"DNS:Lookup",DNS_Found:			"DNS:Found",eventHandler:		"ep:eventHandler",exceptionHandler:	"ep:exceptionHandler",epOutput:			"ep:output", epInput:			"ep:input",epCreate:			"ep:Create",epInstantiate:		"ep:Instantiate",epBind:				"ep:Bind",epConnect:			"ep:Connect",//epOption:			"ep:Option",epListen:			"ep:Listen",epAccept:			"ep:Accept",waitingConnect:		"Waiting for viewer to connect",userStop:			"Stopped by user",epCancel:			"ep:Cancel",epSetInput:			"ep:setInputSpec",epDisconnect:		"ep:Disconnect",epUnbind:			"ep:Unbind",epDispose:			"ep:Dispose",// rfbProto.ns	also encodingsconnected:			"connected",	// host:portvncServer:			"VNC server",	// version [from server]vncViewer:			"VNC viewer",	// version [from viewer]incompatVersion:	"incompat VNC version",incompatFormats:	"incompat formats",authNeeded:			"Authentication needed",authNotNeeded:		"No authentication needed",authScheme:			"Unknown authentication scheme",authSuccess:		"Authentication succeeded",authFailed:			"Authentication failed",authRetry:			"Authentication failed. retry",authTooMany:		"Authentication failed: too many tries",authResult:			"unknown VNC auth result",vncConnFailed:		"VNC connection failed",colorMap:			"Can't handle Fix/Set ColourMapEntries",rfbMsgType:			"Unknown RFB msg type",		// #rect:				"rect",		// rectangle	// #rectEncoding:		"Unknown rect encoding",	// #largeRect:			"Update rectangle too large",	// x,y,w,hincremental:		"incr",		// updatesetPixelFormat:		"SetPixelFormat",setEncodings:		"SetEncodings",// Connectconnect:			"Connect",listen:				"Listen",disconnect:			"Disconnect",general:			"General",viewer:				"Viewer",server:				"Server",host:				"Host",display:			"Display",password:			"Password",port:				"Port",serverName:			"Server Name",remoteSize:			"Remote Size",	// statusmissing:			"missing",// Options/Prefs (viewer)prefs:				"Prefs",//options:			"Options",grayLevel:			"Gray Level",bw:					"b&w (1+ bpp)",gray4:				"4 gray (2 bpp)",gray16:				"16 gray (4 bpp)",useCopyRect:		"Use CopyRect",yes:				"Yes",no:					"No",encoding:			"Encoding",raw:				"Raw",copyRect:			"CopyRect",RRE:				"RRE",CoRRE:				"CoRRE",Hextile:			"Hextile",ifRemove:			"If you remove",zlib:				"Zlib",disableEncodings:	"will disable Zlib encoding",zlibHex:			"ZlibHex",//tight:			"Tight",//disableEncodings:	"will disable Zlib & Tight encodings",hwr:				"Handwriting On",keyboard:			"Keyboard",standardKbd:		"Standard",//mouse:			"Mouse Buttons 2&3",//normal:			"Normal",//reversed:			"Reversed",rightClickPref:		"Right Click",button1:			"ctrl-Button 1 (Mac)",button2:			"Button 2",button3:			"Button 3 (Win)",refreshSec:			"Refresh(sec)",shareDesktop:		"Share Desktop",displaySize:		"Display Size",full:				"full",		// also for update (vs. incr)fullBar:			"full+bar",localUI:			"Local UI",expanded:			"Expanded",compactBot:			"Compact",compactTop:			"Compact(top)",compactFloat:		"Compact(float)",scrollInc:			"Scroll Increment",createOverView:		"Create Overview",//confirmOverview:	"Are you sure you want to create an overview?",//create:				"Create",//cancel:				"Cancel",//remove:				"Remove",apply:				"Apply",// keyboard (pref, patch, status)cmd:				"cmd",	// soft keyboard, statusctrl:				"ctrl",meta:				"meta",opt:				"opt",alt:				"alt",shift:				"sh",bs:					"bs",key:				"key",skbd:				"skbd",	// soft kbdhkbd:				"hkbd",	// hardware kbdrec:				"rec",	// recognizerdrop:				"drop",	// drag&dropgest:				"gest",	// gesturemenu:				"menu",	// action menu//??? other keys -- paraView.writeKey// penleftClick:			"left-click",doubleClick:		"double-click",move:				"move",rightClick:			"right-click",scroll:				"scroll",disconnected:		"disconnected",};// End of text file LanguageData.txt// Beginning of text file initVNC.txt// NOTE: *** indicate shared methods/objectsconstant /*boolean*/ DEBUG 			:= NIL;  	// true for lots of printingconstant /*boolean*/ PROFILE		:= NIL;constant /*boolean*/ FILL_RECT		:= TRUE;	// see vc.fillRectconstant /*boolean*/ DRAW_RECT		:= TRUE;	// see vc.drawRawRectconstant /*boolean*/ TIMING			:= NIL;		// see vc.setGauge, rfb.nextInputLen; vc.Refresh, rfb.nextOutputconstant /*boolean*/ ADD_SERVER		:= TRUE;	// don't need all for viewerconstant /*boolean*/ nos21			:= TRUE;constant /*String*/ kFileName 		:= "nvnc";constant /*String*/ kBetaVersion 	:= "b1";constant /*String*/ kVersionInt		:= "33";constant /*String*/ kVersionNum 	:= "3.3";DefineGlobalConstant(/*String*/ 'titleLabel, kAppName && kVersionNum & kBetaVersion);Write(kFileName & kVersionInt & kBetaVersion & 	(if DEBUG then $D) & (if PROFILE then $P) & (if TIMING then $T)	// & (if DRAW_RECT then $R) & (if FILL_RECT then $F)	& ".pkg" && DateNTime(Time()) & unicodeCR);Write("breakonthrows:=nil;\n");Write("vnc:?close();vnc:=nil\n");Write("vnc:=GetRoot().|vnc:TKnollSys|;nil;vnc:open()\n");/*- fixed Disconnect bug- removed NOS 2.0 compatibility- overlay rather than remove button bar- clipboard support, keyboard Fn & ESC keys (emate?)- added server*/DeclareGlobalFn('GetClipboard,0);DeclareGlobalFn('SetClipboard,1);//DeclareGlobalFn('HandleKeyEvents, 1);// =====// aboutconstant kvncURL	:= "http://www.kagi.com/weyer/#VNC";constant kvncMail	:= "mailto:weyer@kagi.com";constant kAuthor 	:= "  Steve Weyer";constant kNewtsCapeSymbol := '|NewtsCape:NewtsCape|;DefineGlobalConstant('/*string*/ ABOUT_TEXT,kAppName & $: && LocObj("Virtual Network Computer", 'vnc) & unicodeCR &LocObj("Viewer", 'viewer) & $: && LocObj("use your Newton\n\tto view & control a remote system.", 'aboutTextC) & unicodeCR &if ADD_SERVER thenLocObj("Server", 'server) & $: && LocObj("view & control your Newton\n\tfrom a remote system.", 'aboutTextS));   // DateNTime(Time())// =====// based on Zlib-2001101-1721constant kZlibName		:= "zlib";constant Z_STREAM_END 	:= 1;SetPartFrameSlot('RemovalApproval, func(/*symbol*/ unitName, int major, int minor)if unitName = kZlibSymbolthen return	LocObj("If you remove",'ifRemove) && kZlibName & $, &&	kAppName && LocObj(		"will disable Zlib encoding",	//"will disable Zlib & Tight encodings",		'disableEncodings););SetPartFrameSlot('ImportDisabled, func(/*symbol*/ unitName, int major, int minor)if unitName = kZlibSymbolthen begin	local vnc := GetRoot().(kAppSymbol);	vnc.zlib := nil;	vnc.optionsFrame:?close();	vnc:?setEncodings();	end;);// =====constant null 	:= nil;				// for Java compatibility/convenienceconstant false	:= nil;constant /*String*/ connLabel 		:= LocObj("Connect", 'connect);constant /*String*/ discLabel 		:= LocObj("Disconnect", 'disconnect);constant /*String*/ optionsLabel 	:= LocObj("Options", 'options);constant /*String*/ clipLabel 		:= LocObj("ClipBoard", 'clipboard);constant /*String*/ logLabel 		:= LocObj("Log", 'log);constant /*int*/ DEFAULT_PORT_INT 	:= 5900;constant /*int*/ HOST_LENGTH		:= 5;		// # of hosts/passwords to saveconstant /*int*/ _BPP 				:= 4;	// bits per pixel. used only here for bpp=4 (not DRAW_RECT, ADD_SERVER)constant /*int*/ _PPB 				:= 2;	// 8 div bpp; pixels per byte. used only here for bpp=4constant /*int*/ BITMAP_OFFSET		:= 28;	// length of headerDefineGlobalConstant('BM_STYLE,		{transferMode: modeCopy, fillPattern: vfWhite, penPattern: vfNone});DefineGlobalConstant('GAUGE_STYLE,	{transferMode: modeXor,  fillPattern: vfBlack, penPattern: vfNone});constant /*int*/ VBO_LEN			:= 480*18;	// curBuf/drawRawRect (enough to handle 'landscape row') [18 for zlib]constant /*int*/ kVBOFlush			:= 32*1024;DefineGlobalConstant('kNilFunc, 	func() nil);	// for v.disconnectDefineGlobalConstant('kOptionsOpen,	func() optionsFrame:open());	// share w/ DoPrefs, Prefs buttonconstant FATAL_ERROR				:= true;constant IGNORE_ERROR				:= nil;constant DO_LOG						:= true;constant NO_LOG						:= nil;// AddProcrastinatedX symbolsconstant /*symbol*/ EVENT_PEN		:= 'vncPen;constant /*symbol*/ EVENT_SCR		:= 'vncScr;// these are in ticks (1/60)constant /*int*/ EVENT_SCR2D_DELAY	:= 20;	// msec between steps of incremental scrollersconstant /*int*/ SLIDER_DELAY		:=  1;	// :TrackSliderconstant /*int*/ SLIDER_CLICK_DELAY	:=  2;	// TBslider:viewClickScriptconstant /*int*/ UPDATE_SCR_DELAY	:= 20;	// :viewScrollDownScript, viewScrollUpScriptconstant /*int*/ MOVE_DELAY			:= 30;	// :viewGestureScript (between move pts)// these are in msec (1/1000)constant /*int*/ EVENT_SCR_DELAY	:= 500;		// :viewScrollDownScript, viewScrollUpScriptconstant /*int*/ NO_DELAY			:= 0;constant /*int*/ KEY_DELAY			:= 1200;constant /*int*/ DOUBLE_CLICK_DELAY	:= 1000;	// :viewGestureScript (tap before doubletap)constant /*int*/ INCR_DELAY			:= nil;		// use refresh*1000constant NO_SOUND := nil;constant NO_MSG := nil;constant /*int[]*/ SCREEN_SIZE_X	:= '[128,192,240,256];constant /*int[]*/ SCREEN_SIZE_Y	:= SCREEN_SIZE_X;DefineGlobalConstant('kFullSize,	Length(SCREEN_SIZE_X));DefineGlobalConstant('kFullBarSize,	Length(SCREEN_SIZE_X)+1);constant kGridSize					:= 16; // for server//DeclareGlobalFn('KillStdButtonBar, 1);DefineGlobalConstant('noButtonBar,	0); //Array(4,{buttonBarPosition: 'none}));constant restoreButtonBar			:= nil;constant sameButtonBar				:= true;constant kLowerCase := "`1234567890-=[]\\;',./";	// note: \\constant kUpperCase := "~!@#$%^&*()_+{}|:\"<>?";	// note: \"DefineGlobalConstant('AaDiff, Ord($a)-Ord($A));DefineGlobalConstant('kYesNo,		[LocObj("Yes",'yes), LocObj("No",'no)]);// =====constant kExpanded 	 := 0;constant kCompactBot := 1;constant kCompactTop := 2;constant kCompactFloat := 3;constant DISPLAY_RADIO 	:= 1;constant PORT_RADIO 	:= 2;constant VIEWER_RADIO 	:= 1;constant SERVER_RADIO	:= 2;DefineGlobalConstant('kDefaultPrefs, {tag: kPackageName,hosts: 			[],				// e.g. "192.168.1.104"display: 		0,port: 			DEFAULT_PORT_INT,passwords: 		[],dpRadio:		DISPLAY_RADIO,encoding: 		5,				// Hextile (=rfbProto.EncodingHextile)useCopyRect: 	nil,			// NorightClick:		4,				// = rfbProto.kBut3shareDesktop: 	nil,			// Norefresh: 		5,				// secdisplaySize:	0,				// SCREEN_SIZE_X[0]bpp:			4,kbdMode:		0,noHWR:			nil,			// EnabledminUI:			kExpanded,scrollInc:		16,overview:		nil,serverName:		nil,serverPassword:	"",vsRadio:		VIEWER_RADIO,//drawEachPixelForRawRects: nil,// Fast (vc:DrawRawRect)//reverseMouseButtons2And3: nil,	// Normal//copyRectFast: false,		// Reliable});DefineGlobalConstant('kRect0, SetBounds(0,0,0,0));constant /*int*/ kFullOffset := 40;DefineGlobalConstant('kRectNIE, SetBounds(kFullOffset,kFullOffset,-kFullOffset,-kFullOffset)); // e.g., Clipboard/Log// used as viewSetupFormScript by info,kbd,action,close// also used or called by optionsFrame, authenticator, aboutDefineGlobalConstant('kShiftView,func()	// ***begin	viewFlags 	:= _proto.viewFlags;	viewJustify := _proto.viewJustify;	//Band(viewJustify, Bnot(vjParentBottomV))	viewBounds  := _proto.viewBounds;	local int minUI := options.minUI;	if minUI = uiHide	// in vnc, true for minUI=kCompactFloat	then viewFlags := Band(viewFlags, Bnot(vVisible))	else if minUI = kCompactTop	// non-default	then begin		viewJustify := viewJustify - vjParentBottomV; // vjParentTopV=0		viewBounds  := Clone(viewBounds);		local int top 	:= viewBounds.top;		viewBounds.top 	:= -viewBounds.bottom;		viewBounds.bottom := -top;		end;	if HasVariable(self, 'tempOptions)	// kludge so optionsFrame can share	then self.tempOptions := {};	inherited:?viewSetupFormScript();end);// =====DefineGlobalConstant('kFrameMunger, func(/*frame*/ destFrame, /*frame*/ srcFrame, /*symbol*/ add, array syms)begin // add: nil -> remove;  syms like range; nil -> all	local /*symbol*/ sym, val;	if IsArray(syms)	then begin		foreach sym in syms		do if add			then destFrame.(EnsureInternal(sym)) := srcFrame.(sym)			else RemoveSlot(destFrame, sym);		end	else foreach sym,val in srcFrame	// all		do if add			then destFrame.(EnsureInternal(sym)) := val			else RemoveSlot(destFrame,sym);end);DefineGlobalConstant('kRectEqual, func(/*frame*/ bnds1, /*frame*/ bnds2)begin	bnds1.left   = bnds2.left  and	bnds1.top    = bnds2.top   and	bnds1.right  = bnds2.right and	bnds1.bottom = bnds2.bottom;end);// for vc:Refreshconstant NO_REFRESH 	:= nil;			// viewDrawScript blocking, also writeMouseconstant FULL_REFRESH	:= 0;constant INCR_REFRESH	:= 1;constant HOLD_REFRESH	:= 2;			// used by viewIdleScript to sync updatesconstant DONE_REFRESH	:= 3;constant IMMED_REFRESH	:= 5;			// also used as a DELAY(msec)DefineGlobalConstant('kGetSymbol, /*symbol*/ func(/*frame*/ obj) // for debuggingif obj.preallocatedContextthen obj.preallocatedContextelse if obj.appSymbolthen obj.appSymbolelse begin	local /*symbol*/ sym;	local /*frame*/ root := GetRoot();	foreach sym in '[notification, notifyIcon, calculator, alarm, stylePalette, preferenceRoll,		handwritingpractice, |InternetSetup:Newton|, OutOfMemoryAlert, findDrawer, assistant,		alphaKeyboard, phoneKeyboard, dateKeyboard, numericKeyboard, TinyTim, SleepScreen,]	do  if obj = root.(sym)		then return sym;	if obj.pickItems and obj.callbackContext	then return 'aPopupPicker;	NIL;	end);DefineGlobalConstant('kRefreshPatch, {viewDrawScript: func()	// *** shared by newtVNCbegin	GetRoot().(kAppSymbol):?Refresh(self, 'viewDrawScript, :GetDrawBox());	inherited:?viewDrawScript();end,viewQuitScript: func()begin	GetRoot().(kAppSymbol):?Refresh(self, 'viewQuitScript, :GlobalOuterBox());	inherited:?viewQuitScript();end,viewChangedScript: func(slot,view)	// for clParagraphView, clGaugeViewbegin	GetRoot().(kAppSymbol):?Refresh(self, if DEBUG then 'viewChangedScript & $: & slot, :GlobalOuterBox());	inherited:?viewChangedScript(slot,view);end,monthChangedScript: func()	// for clMonthviewbegin	GetRoot().(kAppSymbol):?Refresh(self, 'monthChangedScript, :GlobalOuterBox());	inherited:?monthChangedScript();end,Dirty: func()		// for clMonthviewbegin	GetRoot().(kAppSymbol):?Refresh(self, 'Dirty, :GlobalOuterBox());	inherited:?Dirty();end,newTime: func(arg)begin	GetRoot().(kAppSymbol):?Refresh(self, 'newTime, :GlobalOuterBox());	inherited:?newTime(arg);end,clusterChanged: func()	// for protoRadioClusterbegin	GetRoot().(kAppSymbol):?Refresh(self, 'clusterChanged, :GlobalBox());	inherited:?clusterChanged();end,valueChanged: func()	// for protoCheckboxbegin	GetRoot().(kAppSymbol):?Refresh(self, 'valueChanged, :GlobalBox());	inherited:?valueChanged();end,});DefineGlobalConstant('kIsProto, func(/*frame*/ obj, /*frame*/ proto)begin	while (obj := obj._proto)	do  if obj = proto		then return true;	return nil;end);// used in v.installRefreshPatch. param to kFrameMungerDefineGlobalConstant('kGetPatchSlots, func(/*frame*/ obj)try begin	local int viewClass := obj.viewClass;	if viewClass = clParagraphView or viewClass = clGaugeView	then '[viewChangedScript]	//viewQuitScript	else if viewClass = clMonthView	then '[monthChangedScript, Dirty]	else if call kIsProto with (obj, protoDatePicker)	then '[newTime]	else if obj.valueChanged	then '[valueChanged]	else if obj.clusterChanged	then '[clusterChanged]		else '[viewDrawScript];		// default	endonexception |evt.ex| do return '[];	// in case bad ref, don't do any patch/unpatch);/*xx := getroot():childviewframes(); length(xx);xx[?].viewDrawScript := func() begin Print(:GetDrawBox()); inherited:?viewDrawScript(); endgetroot().xxx := func() begin inherited:?xxx(); Print(['xxx, :globalouterbox()]); end;removeslot(getroot(), 'xxx); nilcall func(children, draw)begin	local child;	foreach child in children	do child.viewDrawScript := draw;end with (xx[8]:childviewframes(), vnc.viewDrawScript)DoDrawing: func(sym, params)begin	local vnc;	if sym='DrawShape and (vnc := GetRoot().(kAppSymbol)) and vnc.vc.refreshAccept	then AddDeferredSend(vnc.vc, 'Refresh, [			INCR_REFRESH, if DEBUG then ['DoDrawing, call kGetAppSymbol with(self)] else NO_DELAY, ShapeBounds(params[0])]);	inherited:?DoDrawing(sym,params);end*/// =====DefineGlobalConstant('byte, {new: func(x) // x = int or arraybegin	if IsInteger(x)	then return MakeBinary(x, 'bytes)	else if IsString(x)	then return MakeBinaryFromHex(x,'bytes) // only at dev-time	else if IsArray(x)	then begin		local int i, len := Length(x);		local /*byte[]*/ obj := MakeBinary(len, 'bytes);		for i:=0 to len-1		do StuffByte(obj, i, x[i]);		return obj;		end;end,	});DefineGlobalConstant('int, {new: func(int len)	return byte:new(len*4),	//Array(len,0),});// for debugging (or use StrHexDump)DefineGlobalConstant('kPrintBytes, func(/*byte[]*/ b, int offset, int len, /*string*/ name)begin	if not len	then len := Length(b)-offset;	local shex := "0123456789ABCDEF";	local int i, val;	Write(name & $[ & len & "]: ");	for i:=0 to len-1	do begin		val := ExtractByte(b,offset+i);		Write("0x" & shex[val >> 4] & shex[Band(val, 0xF)] & $,) 		end;	Write(unicodeCR);end);/*Binary	Dec	Hex0000	 0	0x00001	 1	0x10010	 2	0x20011	 3	0x30100	 4	0x40101	 5	0x50110	 6	0x60111	 7	0x71000	 8	0x81001	 9	0x91010	10	0xA1011	11	0xB1100	12	0xC1101	13	0xD1110	14	0xE1111	15	0xF*//*call func(n)begin	local x;	local i, t := ticks();	for i:=1 to n	do begin		x :=		//do x := 		end;	ticks()-t;end with (100)*/// End of text file initVNC.txt// Beginning of text file Socket.ns// some of these used elsewhereDeclareGlobalFn('ClearVBOCache, 1);DeclareGlobalFn('InetOpenConnectionSlip, 3);DeclareGlobalFn('InetGrabLink, 3);DeclareGlobalFn('InetGrabLinkVerbose, 3);DeclareGlobalFn('InetIsValidIPAddressStr, 1);DeclareGlobalFn('InetIPStringToAddress, 1);DeclareGlobalFn('DNSGetAddressFromName, 3);DeclareGlobalFn('InetReleaseLink, 3);DeclareGlobalFn('InetReleaseLinkVerbose, 3);DeclareGlobalFn('InetCancelLink, 3);DeclareGlobalFn('GetGlobalFnExists, 1);DeclareGlobalFn('InetGetErrorString, 1);DeclareGlobalFn('InetGetIPAddress, 1);DeclareGlobalFn('InetIPAddressToString, 1);constant kEventDisconnect	:= 2;constant kEventRelease		:= 3;DefineGlobalConstant('kSetClone, func(obj, array path, val)begin // used for patching options	if isReadonly(obj)	then obj := Clone(obj);	local nobj := obj;	local int i, last := Length(path)-1;	foreach i,path1 in path	do nobj := nobj.(path1) := if i=last then val else Clone(nobj.(path1));	obj;end);// modify /**/ via SetClone//DefineGlobalConstant('Socket, {_proto: protoBasicEndPoint,instantiateOptions: [	{label:	"inet",	type:	'service,	opCode:	opSetRequired,	result:	nil,	},	{label:	"ilid",			// set the link id	type:	'option,	opCode:	opSetRequired,	result:	nil,	form:	'template,	data:	{		arglist: [nil],		// linkID /**/		typelist:	[			'struct,			'ulong,			],		},	},			{label:	"itsv",			// set the transport protocol (TCP or UCP)	type:	'option,	opCode:	opSetRequired,	result:	nil,	form:	'template,	data: {		arglist: [1],		// protocol (== TCP)		typelist: [			'struct,			'ulong,			],		},	}],bindOptions: [	{label:		"ilpt",		// set the local port	type:		'option,	opCode:		opSetRequired,	result:		nil,	form:		'template,	data:	{		arglist: [			0,				// local port number			true,			// use default port	 /**/			],		typelist:	[			'struct,			'short,			'boolean,			],		},	}],connectOptions: [	{label:	"itrs",			// set the TCP remote socket	type:	'option,	opCode:	opSetRequired, //***	result:	nil,	form:	'template,	data:	{		arglist: [0,0,0,0,0],		/**/		/*	[			remoteAddr[0],	// remote host addr - byte 1			remoteAddr[1],	// remote host addr - byte 2			remoteAddr[2],	// remote host addr - byte 3			remoteAddr[3],	// remote host addr - byte 4			remotePort,		// remote port number 			],			*/				typelist: [			'struct,			'byte,			'byte,			'byte,			'byte,			'short,			],		},	}],exceptionHandler: func(/*frame*/ ex)begin	rfb:?error(LocObj("ep:exceptionHandler",'exceptionHandler) & $: & ex.name, ex.debug && ex.data, IGNORE_ERROR);end,//http://www.unna.org/unna/apple/Newton_Development/tech_info/QAs/html/e36006.htmeventHandler: func(/*frame*/ ev)begin	if ev.eventCode <> kEventDisconnect	then rfb:?error(LocObj("ep:eventHandler",'eventHandler), ev.eventCode, IGNORE_ERROR);end,OutputSpec: {	async:		true,	form:		'binary,	CompletionScript: func(ep, options, result)	// no context	begin		// note: rfb local to this outputSpec		if result		then AddDeferredSend(rfb, 'error, [LocObj("ep:output", 'epOutput), result, FATAL_ERROR])		else if rfb._outState		then AddDeferredSend(rfb, rfb._outState, nil);	// doesn't need to stay in this context (like input)	end,},InputSpec: {	async:		true,	reqTimeout:	kNoTimeout, 	form: 		'binary,	InputScript: func(ep, data, terminator, options)	// no context	begin		// note: _inLen, rfb are local to this inputSpec		local /*symbol*/ _inState := rfb._inState;		if _inLen = terminator.byteCount		then begin			if _inState			then Perform(rfb, _inState, [data]); 		// rfb does :SetInputSpec w/in this context			end		else rfb:error(LocObj("ep:input", 'epInput), _inState && _inLen, FATAL_ERROR);	end,	CompletionScript: func(ep, options, result)	begin		if result <> -16005	// expected from disconnect		then AddDeferredSend(rfb, 'error, [LocObj("ep:input", 'epInput), result, FATAL_ERROR]);	end,},new: func(/*String*/ h, int p, rfb)begin	local sock := {_proto: self, host: h, port: p, rfb: rfb};	//AddDeferredSend(sock, '_getConnection, nil);	rfb:status(sock._status := LocObj("NIE:Connect", 'NIE_Connect), nil, DO_LOG);	AddDeferredCall(GetGlobalFn('InetOpenConnectionSlip), [nil, sock, '_getConnectionCallback]);	sock;end,rfb: 			nil,host: 			nil,		// if empty/nil, then Listen (i.e., server mode)port: 			nil,_linkID: 		nil,_status: 		nil,_address: 		nil,_closeCallback: nil,/*_getConnection: func()begin	rfb:status(_status := LocObj("NIE:Connect", 'NIE_Connect), nil, DO_LOG);	InetOpenConnectionSlip(nil, self, '_connectionSlipCallback);end,*/_getConnectionCallback: func(/*symbol*/ what)begin	if what = 'connect	then begin		//AddDeferredSend(self, '_grabLink, nil);		_status := LocObj("NIE:GrabLink", 'NIE_GrabLink);		local fn := GetGlobalFn('InetGrabLinkVerbose);		AddDeferredCall(if fn then fn else GetGlobalFn('InetGrabLink), [_linkID, self, '_grabLinkCallback]);		end	else if what = 'close	then rfb:error(_status, LocObj("no connection", 'NIE_noConnect), FATAL_ERROR);	//else if what <> _status	//then rfb:status(LocObj("NIE:Connect", 'NIE_Connect), _status := what, DO_LOG);end,/*_grabLink: func()begin	_status := LocObj("NIE:GrabLink", 'NIE_GrabLink);	//rfb:status(_status := LocObj("NIE:GrabLink", 'NIE_GrabLink), nil, DO_LOG);	local fn := GetGlobalFn('InetGrabLinkVerbose);	call (if fn then fn else GetGlobalFn('InetGrabLink)) with (_linkID, self, '_grabLinkCallback);end,*/_grabLinkCallback: func(int linkID, /*frame*/ status, result)begin	_linkID := linkID;//if DEBUG then Print("grabLink:" && _linkID);	if result	then begin		rfb:error(_status, result, IGNORE_ERROR);	// cancel first		InetCancelLink(_linkID, self, '_cancelLinkCallback);		end	else if (status := status.linkStatus) = 'connected	then begin		_closeCallback := '_releaseLink;		AddDeferredSend(self, if StrFilled(host) then '_getDNS else '_Instantiate, nil);		end;	//else if status <> _status	//then rfb:status(LocObj("NIE:GrabLink", 'NIE_GrabLink), _status := status, DO_LOG);end,_cancelLinkCallback: func(int linkID, /*frame*/ status, result)begin	rfb:error(LocObj("NIE:CancelLink", 'NIE_CancelLink), result, FATAL_ERROR); // this should trigger releaseLink via :closeend,_getDNS: func()	// viewer onlybegin	if InetIsValidIPAddressStr(host)	// e.g., 205.134.252.158	then :_getDNScallback([{resultIPAddress: InetIPStringToAddress(host)}], nil)	else begin		rfb:status(_status := LocObj("DNS:Lookup", 'DNS_Lookup), host, DO_LOG);		DNSGetAddressFromName(host, self, '_getDNScallback);		end;end,_getDNScallback: func(array addr, result)	// viewer onlybegin	if result		or not addr		or Length(addr) < 1	then return rfb:error(_status, result, FATAL_ERROR);	_address := addr[0].resultIPAddress;	rfb:status(LocObj("DNS:Found", 'DNS_Found),		if InetIsValidIPAddressStr(host)		then host		else host & $: && InetIPAddressToString(_address), DO_LOG);	:_Instantiate();end,_Instantiate: func() // can be called directly from grablink (for server skipping DNS)begin	rfb:status(_status := LocObj("ep:Instantiate", 'epInstantiate), nil, DO_LOG);	local array options := call kSetClone with (instantiateOptions, '[pathExpr: 1,data,arglist], [_linkID]);	try :Instantiate(self, options);	onexception |evt.ex|	do return rfb:error(_status, currentException(), FATAL_ERROR);	_closeCallback := '_Dispose;	//:_Bind();	rfb:status(_status := LocObj("ep:Bind", 'epBind), nil, DO_LOG);	options := call kSetClone with (bindOptions, '[pathExpr: 0,data,arglist,1], port);	try :Bind(options, _bindCallback)	onexception |evt.ex|	do _bindCallback:CompletionScript(self, nil, currentException());	end,_bindCallback: {	// no contextasync: true,CompletionScript: func(ep, options, result)begin	//local rfb := ep.rfb;	if result then return ep.rfb:error(ep._status, result, FATAL_ERROR);	ep._closeCallback := '_Cancel;	if ep._address	then ep:_Connect()	else ep:_Listen();	// :_option()end,},_Connect: func()	// viewer onlybegin	rfb:status(_status := LocObj("ep:Connect", 'epConnect), LocObj("Viewer", 'viewer), DO_LOG);	local options := call kSetClone with (connectOptions, '[pathExpr: 0,data,arglist],		SetAdd(Clone(_address), port, nil));	try :Connect(options, _connectCallback);	onexception |evt.ex|	do _connectCallback:CompletionScript(self, nil, currentException());end,_connectCallback: {	// no context. also used by Acceptasync: true,CompletionScript: func(ep, options, result)begin	local rfb := ep.rfb;	if result then return rfb:error(ep._status, result, FATAL_ERROR);	AddDeferredSend(rfb, 'connected, nil);end,},_Listen: func()	// ADD_SERVERbegin	rfb:status(LocObj("ep:Listen", 'epListen), LocObj("Server", 'server), DO_LOG);	_status := 'waiting;	try :Listen(connectOptions, _listenCallback)	onexception |evt.ex|	do _status := currentException; //_listenCallback:CompletionScript(self, nil, currentException());	local progressOptions := {		closeBox: nil,		statusText: kAppName & unicodeCR & LocObj("Local IP", 'localIP) & $: && InetIPAddressToString(InetGetIPAddress('localAddress)),       	barber: true,		titleText: 	LocObj("Waiting for viewer to connect", 'waitingConnect),		};	if _status = 'waiting	then DoProgress('vBarber, progressOptions, func(progressView)		while _status = 'waiting		do begin			try progressView:SetStatus('vBarber, progressOptions)			onexception |evt.ex.cancel|			do break _status := LocObj("Stopped by user", 'userStop);			Sleep(20);			end;		);	// here via _listenCallback or Stop	if _status	then return rfb:error(LocObj("ep:Listen", 'epListen), _status, FATAL_ERROR);	//:_Accept();	rfb:status(_status := LocObj("ep:Accept", 'epAccept), nil, DO_LOG);	try :Accept(nil, _connectCallback)	onexception |evt.ex|	do _connectCallback:CompletionScript(self, nil, currentException());end,_listenCallback: {	// ADD_SERVER. no contextasync: true,CompletionScript: func(ep, array options, result)begin	//local rfb := ep.rfb;	if not (ep._status := result)	then ep._address := options[0].data.arglist; // for 'serverName', etc. later	// now exit DoProgress in _listen...end,},/*_Accept: func()	// ADD_SERVERbegin	rfb:status(_status := LocObj("ep:Accept", 'epAccept), nil, DO_LOG);	try :Accept(nil, _connectCallback)	onexception |evt.ex|	do _connectCallback:CompletionScript(self, nil, currentException());end,*/close: func()begin	if _closeCallback	then Perform(self, _closeCallback, nil);	NIL;end,_Cancel: func()		// _closeCallbackbegin	rfb:status(_status := LocObj("ep:Cancel", 'epCancel), nil, DO_LOG);	try :Cancel(_cancelCallback)	onexception |evt.ex|	do _cancelCallback:CompletionScript(self, nil, currentException());end,_cancelCallback: {	// no contextasync: true,CompletionScript: func(ep, options, result)begin	local rfb := ep.rfb;	if result and result <> -36003	then rfb:error(ep._status, result, IGNORE_ERROR);	// continue cleanup//	try ep:setInputSpec(nil) onexception |evt.ex|//	do rfb:error(LocObj("ep:setInputSpec", 'epSetInput), nil, IGNORE_ERROR);	//:_Disconnect();	rfb:status(ep._status := LocObj("ep:Disconnect", 'epDisconnect), nil, DO_LOG);	try ep:Disconnect(nil, ep._disconnectCallBack)	onexception |evt.ex|	do ep._disconnectCallBack:CompletionScript(ep, nil, currentException());end,},_disconnectCallBack: {	// no contextasync: true,CompletionScript: func(ep, options, result)begin	local rfb := ep.rfb;	if result	then begin		rfb:error (ep._status, result, IGNORE_ERROR);		AddDelayedSend(ep, '_Unbind, nil, 1000);		end	else ep:_Unbind();end,},_Unbind: func()	// _closeCallbackbegin	rfb:status(_status := LocObj("ep:Unbind", 'epUnbind), nil, DO_LOG);	try :UnBind(_UnbindCallback);	onexception |evt.ex|	do _UnbindCallback:CompletionScript(self, nil, currentException());end,_UnbindCallback: {	// no contextasync: true,CompletionScript: func(ep, options, result)begin	//local rfb := ep.rfb;	if result	then ep.rfb:error(ep._status, result, IGNORE_ERROR);	ep:_Dispose();end,},_Dispose: func()		// _closeCallbackbegin	rfb:status(_status := LocObj("ep:Dispose", 'epDispose), nil, DO_LOG);	try :Dispose()	onexception |evt.ex|	do rfb:error(_status, currentException(), IGNORE_ERROR);	:_releaseLink();end,_releaseLink: func()	// _closeCallbackbegin	rfb:status(_status := LocObj("NIE:ReleaseLink", 'NIE_ReleaseLink), _linkID, DO_LOG);	local fn := GetGlobalFn('InetReleaseLinkVerbose);	call (if fn then fn else GetGlobalFn('InetReleaseLink)) with (_linkID, self, '_releaseLinkCallback);end,//InetReleaseLinkVerbose(179601, {cb: func(linkID, status, result) nil}, 'cb)_releaseLinkCallback: func(int linkID, status, result)begin	_linkID := nil;	if result	then rfb:error(_status, result, IGNORE_ERROR);	// ?? figure we're disconnected whether in progress, error or done	rfb:disconnected();end,readBytes: func(/*byte[]*/ buf, int start, int count)	:setInputSpec({		_proto: InputSpec,		target: {data: buf, offset: start},		termination: {byteCount: count},		_inLen: count, // add these for convenience. not _inState since it might change for same len		rfb: rfb,		}),writeBytes: func(/*byte[]*/ buf, int start, int count)begin	:Output(buf, nil, {		_proto: OutputSpec,		target: {offset: start, length: if count then count else Length(buf)},		rfb: rfb		});end,});// *** remove items unused by viewer/serverif not ADD_SERVERthen begin // viewer	RemoveSlot(Socket, '_Listen);	RemoveSlot(Socket, '_listenCallback);	end;// End of text file Socket.ns// Beginning of text file DesCipher.ns// Newton version S. Weyer//// NOTE: NewtonScript can only handle integers up to 29-30 bits (including sign).// to avoid problems with 2 inaccessible high bits and sign bit,// this version usually operates on integers as sequence of 4 bytes// though optimizations are sometimes possible. only true int[] is 'totrot'// 0x1FFFFFFF is max pos #; 1<<29 is neg; )// although slow/ugly, this is really only used for initial authentication// so it shouldn't be a major problem (and probably not worth major rewriting)// //// This DES class has been extracted from package Acme.Crypto for use in VNC.// The bytebit[] array has been reversed so that the most significant bit// in each byte of the key is ignored, not the least significant.  Also the// unnecessary odd parity code has been removed.//// These changes are://  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.//// This software is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.//// DesCipher - the DES encryption method//// The meat of this code is by Dave Zimmerman <dzimm@widget.com>, and is://// Copyright (c) 1996 Widget Workshop, Inc. All Rights Reserved.//// Permission to use, copy, modify, and distribute this software// and its documentation for NON-COMMERCIAL or COMMERCIAL purposes and// without fee is hereby granted, provided that this copyright notice is kept// intact.//// WIDGET WORKSHOP MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY// OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED// TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A// PARTICULAR PURPOSE, OR NON-INFRINGEMENT. WIDGET WORKSHOP SHALL NOT BE LIABLE// FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR// DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.//// THIS SOFTWARE IS NOT DESIGNED OR INTENDED FOR USE OR RESALE AS ON-LINE// CONTROL EQUIPMENT IN HAZARDOUS ENVIRONMENTS REQUIRING FAIL-SAFE// PERFORMANCE, SUCH AS IN THE OPERATION OF NUCLEAR FACILITIES, AIRCRAFT// NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE// SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF THE// SOFTWARE COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR SEVERE// PHYSICAL OR ENVIRONMENTAL DAMAGE ("HIGH RISK ACTIVITIES").  WIDGET WORKSHOP// SPECIFICALLY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR// HIGH RISK ACTIVITIES.////// The rest is://// Copyright (C) 1996 by Jef Poskanzer <jef@acme.com>.  All rights reserved.//// Redistribution and use in source and binary forms, with or without// modification, are permitted provided that the following conditions// are met:// 1. Redistributions of source code must retain the above copyright//    notice, this list of conditions and the following disclaimer.// 2. Redistributions in binary form must reproduce the above copyright//    notice, this list of conditions and the following disclaimer in the//    documentation and/or other materials provided with the distribution.//// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF// SUCH DAMAGE.//// Visit the ACME Labs Java page for up-to-date versions of this and other// fine Java utilities: http://www.acme.com/java/// import java.io.*;/// The DES encryption method.// <P>// This is surprisingly fast, for pure Java.  On a SPARC 20, wrapped// in Acme.Crypto.EncryptedOutputStream or Acme.Crypto.EncryptedInputStream,// it does around 7000 bytes/second.// <P>// Most of this code is by Dave Zimmerman <dzimm@widget.com>, and is// Copyright (c) 1996 Widget Workshop, Inc.  See the source file for details.// <P>// <A HREF="/resources/classes/Acme/Crypto/DesCipher.java">Fetch the software.</A><BR>// <A HREF="/resources/classes/Acme.tar.Z">Fetch the entire Acme package.</A>// <P>// @see Des3Cipher// @see EncryptedOutputStream// @see EncryptedInputStreamDefineGlobalConstant('Hxaaaaaaaa, 	byte:new("aaaaaaaa")); // for desDefineGlobalConstant('Hx33333333, 	byte:new("33333333"));DefineGlobalConstant('DesCipher, {    new: func(/*byte[]*/ key)	// Constructor, byte-array key.begin	local obj := {		_proto: self,		/*int[]*/ encryptKeys:	int:new(32),		///*int[]*/ decryptKeys:	int:new(32),	// UNUSED		/*int[]*/ tempInts: 	int:new(2),		};	obj:setKey(key);	return obj;end,setKey: func(/*byte[]*/ key )	// Set the key.begin	:deskey( key, true,  encryptKeys );//if (DEBUG) then call kPrintBytes with (encryptKeys, 0,nil,"encryptKeys");	//:deskey( key, false, decryptKeys );	// UNUSED//if (DEBUG) then call kPrintBytes with (decryptKeys, 0,nil,"decryptKeys");end,// Turn an 8-byte key into internal keys.deskey: func(/*byte[]*/ keyBlock, /*boolean*/ encrypting, /*int[]*/ KnL )begin	local int i, j, l, m, n;	local /*int[]*/ pc1m 	:= int:new(56);	local /*int[]*/ pcr  	:= int:new(56);	local /*int[]*/ kn 		:= int:new(32);	for j:=0 to 55	do begin		l := ExtractByte(pc1,j); //pc1[j];	    m := Band(l, 0x7);	// m = l & 07	    //pc1m[j] := ( (keyBlock[l >>> 3] & bytebit[m]) != 0 )? 1: 0;	    :StuffInt(pc1m,j,	    	(if (Band(ExtractByte(keyBlock, l div 8), ExtractByte(bytebit,m)) <> 0 ) //l >> 3	    	then 1 else 0), 0);	    end;	for i := 0 to 15	do begin		m := if ( encrypting ) then i*2 else (15-i)*2;	//i << 1 else (15-i) << 1;	    n := m+1;	    :StuffInt(kn,m, 0,0); :StuffInt(kn,n, 0,0); //kn[m] := kn[n] := 0;		for j:=0 to 55		do begin			l := j+totrot[i];			:StuffInt(pcr,j, pc1m, if (if j<28 then l<28 else l<56) then l else l-28);			end;		for j:=0 to 23		do begin			if (not :EqualInt(pcr, ExtractByte(pc2,j), 0,0)) //(pcr[pc2[j]] <> 0 )		    then //kn[m] |= bigbyte[j]		    	:BorInt(kn,m, kn,m, bigbyte,j);			if (not :EqualInt(pcr, ExtractByte(pc2,j+24), 0,0)) //(pcr[pc2[j+24]] <> 0 )		    then //kn[n] |= bigbyte[j];		    	:BorInt(kn,n, kn,n, bigbyte,j);			end;	    end;	:cookey( kn, KnL );end,cookey: func(/*int[]*/ raw, /*int[]*/ KnL )begin	local int raw0, raw1, KnLx, i;	local int rawi := KnLi := 0;	local tmp := int:new(1);	for i:=0 to 15	do begin		//raw0 := raw[rawi];		raw0 := rawi;	// NS note: raw0,raw1 are used here as just 'indices' into raw		rawi := rawi+1;		//raw1 := raw[rawi];		raw1 := rawi;		rawi := rawi+1;	    //KnL[KnLi]  = (raw0 & 0x00fc0000) <<   6;		:BandInt(KnL,KnLi, raw,raw0, 0x00fc0000,0);		:LShiftInt(KnL,KnLi, KnL,KnLi, 6);	    //KnL[KnLi] |= (raw0 & 0x00000fc0) <<  10;	    :BandInt(tmp,0, raw,raw0, 0x00000fc0,0);	    :LShiftInt(tmp,0, tmp,0, 10);	    :BorInt(KnL,KnLi, KnL,KnLi, tmp,0);	    	    //KnL[KnLi] |= (raw1 & 0x00fc0000) >>> 10;	    :BandInt(tmp,0, raw,raw1, 0x00fc0000,0);	    :RShiftInt(tmp,0, tmp,0, 10, false);	    :BorInt(KnL,KnLi, KnL,KnLi, tmp,0);	    //KnL[KnLi] |= (raw1 & 0x00000fc0) >>>  6;	    :BandInt(tmp,0, raw,raw1, 0x00000fc0,0);	    :RShiftInt(tmp,0, tmp,0, 6, false);	    :BorInt(KnL,KnLi, KnL,KnLi, tmp,0);	    //++KnLi;	    KnLi := KnLi+1;	    //KnL[KnLi]  = (raw0 & 0x0003f000) <<  12;		:BandInt(KnL,KnLi, raw,raw0, 0x0003f000,0);		:LShiftInt(KnL,KnLi, KnL,KnLi, 12);	    //KnL[KnLi] |= (raw0 & 0x0000003f) <<  16;	    :BandInt(tmp,0, raw,raw0, 0x0000003f,0);	    :LShiftInt(tmp,0, tmp,0, 16);	    :BorInt(KnL,KnLi, KnL,KnLi, tmp,0);	    //KnL[KnLi] |= (raw1 & 0x0003f000) >>>  4;	    :BandInt(tmp,0, raw,raw1, 0x0003f000,0);	    :RShiftInt(tmp,0, tmp,0, 4, false);	    :BorInt(KnL,KnLi, KnL,KnLi, tmp,0);	    //KnL[KnLi] |= (raw1 & 0x0000003f);	    :BandInt(tmp,0, raw,raw1, 0x0000003f,0);	    :BorInt(KnL,KnLi, KnL,KnLi, tmp,0);	    //++KnLi;	    KnLi := KnLi+1;		end;end,// Block encryption routines.// Encrypt a block of eight bytes.encrypt: func(/*byte[]*/ clearText, int clearOff, /*byte[]*/ cipherText, int cipherOff )begin	:squashBytesToInts(clearText, clearOff, tempInts, 0, 2 );	:des( tempInts, tempInts, encryptKeys );	:spreadIntsToBytes( tempInts, 0, cipherText, cipherOff, 2 );end,// Decrypt a block of eight bytes	// UNUSED/*decrypt: func(cipherText, int cipherOff, clearText, int clearOff )begin	:squashBytesToInts( cipherText, cipherOff, tempInts, 0, 2 );	:des( tempInts, tempInts, decryptKeys );	:spreadIntsToBytes( tempInts, 0, clearText, clearOff, 2 );end,*/// The DES function.des: func(/*int[]*/ inInts, /*int[]*/ outInts, /*int[]*/ keys )begin	local int round, keysi := 0;	//leftt = inInts[0];	//right = inInts[1];	local leftt := inInts, right := inInts;	// use index: 0 for leftt, 1 for right	local fval := int:new(1), work := int:new(1);	//work   = ((leftt >>>  4) ^ right) & 0x0f0f0f0f;	:RShiftInt(work,0, leftt,0, 4, false);	:BxorInt(work,0, work,0, right,1);	:BandInt(work,0, work,0, 0x0f0f0f0f,0);	//right ^= work;	:BxorInt(right,1, right,1, work,0);	//leftt ^= (work << 4);	:LShiftInt(work,0, work,0, 4); // ok to overwrite work	:BXorInt(leftt,0, leftt,0, work,0);	//work   = ((leftt >>> 16) ^ right) & 0x0000ffff;	:RShiftInt(work,0, leftt,0, 16, false);	:BxorInt(work,0, work,0, right,1);	:BandInt(work,0, work,0, 0x0000ffff,0);	//right ^= work;	:BxorInt(right,1, right,1, work,0);	//leftt ^= (work << 16);	:LShiftInt(work,0, work,0, 16); // ok to overwrite work	:BXorInt(leftt,0, leftt,0, work,0);	//work   = ((right >>>  2) ^ leftt) & 0x33333333;	:RShiftInt(work,0, right,1, 2, false);	:BxorInt(work,0, work,0, leftt,0);	:BandInt(work,0, work,0, Hx33333333,0);	//leftt ^= work;	:BXorInt(leftt,0, leftt,0, work,0);	//right ^= (work << 2);	:LShiftInt(work,0, work,0, 2); // ok to overwrite work	:BxorInt(right,1, right,1, work,0);	//work   = ((right >>>  8) ^ leftt) & 0x00ff00ff;	:RShiftInt(work,0, right,1, 8, false);	:BxorInt(work,0, work,0, leftt,0);	:BandInt(work,0, work,0, 0x00ff00ff,0);	//leftt ^= work;	:BXorInt(leftt,0, leftt,0, work,0);	//right ^= (work << 8);	:LShiftInt(work,0, work,0, 8); // ok to overwrite work	:BxorInt(right,1, right,1, work,0);	//right  = (right << 1) | ((right >>> 31) & 1);	:LShiftInt(work,0, right,1, 1); // ok to overwrite work	:RShiftInt(fval,0, right,1, 31, false);	// ok to use fval	:BandInt(fval,0, fval,0, 0x1, 0);	:BorInt(right,1, work,0, fval,0);	//work   = (leftt ^ right) & 0xaaaaaaaa;	:BxorInt(work,0, leftt,0, right,1);	:BandInt(work,0, work,0, Hxaaaaaaaa,0);	// defined as a constant	//leftt ^= work;	:BxorInt(leftt,0, leftt,0, work,0);	//right ^= work;	:BxorInt(right,1, right,1, work,0);	//leftt  = (leftt << 1) | ((leftt >>> 31) & 1);	:LShiftInt(work,0, leftt,0, 1); // ok to overwrite work	:RShiftInt(fval,0, leftt,0, 31, false);	// ok to use fval	:BandInt(fval,0, fval,0, 0x1, 0);	:BorInt(leftt,0, work,0, fval,0);	for round := 0 to 7	do begin	    //work   = (right << 28) | (right >>> 4);		:LShiftInt(work,0, right,1, 28); // ok to overwrite work		:RShiftInt(fval,0, right,1, 4, false);	// ok to use fval		:BorInt(work,0, work,0, fval,0);	    	    //work  ^= keys[keysi++];	    :BxorInt(work,0, work,0, keys,keysi);	    keysi := keysi+1;	    //fval   = SP7[ work	     & 0x0000003f ];	    //fval  |= SP5[(work >>>  8) & 0x0000003f ];	    :BorInt(fval,0, SP7, Band(ExtractByte(work,3), 0x3f),	    				SP5, Band(ExtractByte(work,2), 0x3f));	    	    //fval  |= SP3[(work >>> 16) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP3, Band(ExtractByte(work,1), 0x3f));	    	    //fval  |= SP1[(work >>> 24) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP1, Band(ExtractByte(work,0), 0x3f));	    	    //work   = right ^ keys[keysi++];	    :BxorInt(work,0, right,1, keys,keysi);	    keysi := keysi+1;		    //fval  |= SP8[ work         & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP8, Band(ExtractByte(work,3), 0x3f));	    //fval  |= SP6[(work >>>  8) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP6, Band(ExtractByte(work,2), 0x3f));	    //fval  |= SP4[(work >>> 16) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP4, Band(ExtractByte(work,1), 0x3f));	    //fval  |= SP2[(work >>> 24) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP2, Band(ExtractByte(work,0), 0x3f));	    //leftt ^= fval;	    :BxorInt(leftt,0, leftt,0, fval,0);	  	    //work   = (leftt << 28) | (leftt >>> 4);		:LShiftInt(work,0, leftt,0, 28); // ok to overwrite work		:RShiftInt(fval,0, leftt,0, 4, false);	// ok to use fval		:BorInt(work,0, work,0, fval,0);	    //work  ^= keys[keysi++];	    :BxorInt(work,0, work,0, keys,keysi);	    keysi := keysi+1;	    //fval   = SP7[ work	     & 0x0000003f ];	    //fval  |= SP5[(work >>>  8) & 0x0000003f ];	    :BorInt(fval,0, SP7, Band(ExtractByte(work,3), 0x3f),	    				SP5, Band(ExtractByte(work,2), 0x3f));	    	    //fval  |= SP3[(work >>> 16) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP3, Band(ExtractByte(work,1), 0x3f));	    	    //fval  |= SP1[(work >>> 24) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP1, Band(ExtractByte(work,0), 0x3f));	    //work   = leftt ^ keys[keysi++];	    :BxorInt(work,0, leftt,0, keys,keysi);	    keysi := keysi+1;	    //fval  |= SP8[ work         & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP8, Band(ExtractByte(work,3), 0x3f));	    //fval  |= SP6[(work >>>  8) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP6, Band(ExtractByte(work,2), 0x3f));	    //fval  |= SP4[(work >>> 16) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP4, Band(ExtractByte(work,1), 0x3f));	    //fval  |= SP2[(work >>> 24) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP2, Band(ExtractByte(work,0), 0x3f));	    //right ^= fval;	    :BxorInt(right,1, right,1, fval,0);	    end;	//right  = (right << 31) | (right >>> 1);	:LShiftInt(work,0, right,1, 31); // ok to overwrite work	:RShiftInt(fval,0, right,1, 1, false);	// ok to use fval	:BorInt(right,1, work,0, fval,0);	//work   = (leftt ^ right) & 0xaaaaaaaa;	:BxorInt(work,0, leftt,0, right,1);	:BandInt(work,0, work,0, Hxaaaaaaaa,0);	//leftt ^= work;	:BxorInt(leftt,0, leftt,0, work,0);	//right ^= work;	:BxorInt(right,1, right,1, work,0);	//leftt  = (leftt << 31) | (leftt >>> 1);	:LShiftInt(work,0, leftt,0, 31); // ok to overwrite work	:RShiftInt(fval,0, leftt,0, 1, false);	// ok to use fval	:BorInt(leftt,0, work,0, fval,0);	//work   = ((leftt >>>  8) ^ right) & 0x00ff00ff;	:RShiftInt(work,0, leftt,0, 8, false);	:BXorInt(work,0, work,0, right,1);	:BandInt(work,0, work,0, 0x00ff00ff,0);	//right ^= work;	:BxorInt(right,1, right,1, work,0);	//leftt ^= (work << 8);	:LShiftInt(work,0, work,0, 8); // ok to overwrite work	:BxorInt(leftt,0, leftt,0, work,0);	//work   = ((leftt >>>  2) ^ right) & 0x33333333;	:RShiftInt(work,0, leftt,0, 2, false);	:BXorInt(work,0, work,0, right,1);	:BandInt(work,0, work,0, Hx33333333,0);	//right ^= work;	:BxorInt(right,1, right,1, work,0);	//leftt ^= (work << 2);	:LShiftInt(work,0, work,0, 2); // ok to overwrite work	:BxorInt(leftt,0, leftt,0, work,0);	//work   = ((right >>> 16) ^ leftt) & 0x0000ffff;	:RShiftInt(work,0, right,1, 16, false);	:BXorInt(work,0, work,0, leftt,0);	:BandInt(work,0, work,0, 0x0000ffff,0);	//leftt ^= work;	:BxorInt(leftt,0, leftt,0, work,0);	//right ^= (work << 16);	:LShiftInt(work,0, work,0, 16); // ok to overwrite work	:BxorInt(right,1, right,1, work,0);		//work   = ((right >>>  4) ^ leftt) & 0x0f0f0f0f;	:RShiftInt(work,0, right,1, 4, false);	:BXorInt(work,0, work,0, leftt,0);	:BandInt(work,0, work,0, 0x0f0f0f0f,0);		//leftt ^= work;	:BxorInt(leftt,0, leftt,0, work,0);		//right ^= (work << 4);	:LShiftInt(work,0, work,0, 4); // ok to overwrite work	:BxorInt(right,1, right,1, work,0);	//outInts[0] = right;	//outInts[1] = leftt;	//need to swap, but since array is identical. copy to temps	:StuffInt(work,0, leftt,0);	:StuffInt(fval,0, right,1);	:StuffInt(outInts,0, fval,0);	//right	:StuffInt(outInts,1, work,0);	//leftend,// Tables, permutations, S-boxes, etc./*byte[]*/ bytebit: byte:new("0102040810204080"),/*int[]*/ bigbyte: byte:new("008000000040000000200000001000000008000000040000000200000001000000008000000040000000200000001000000008000000040000000200000001000000008000000040000000200000001000000008000000040000000200000001"),/*byte[]*/ pc1: byte:new([      56, 48, 40, 32, 24, 16,  8,       0, 57, 49, 41, 33, 25, 17,	   9,  1, 58, 50, 42, 34, 26,      18, 10,  2, 59, 51, 43, 35,	  62, 54, 46, 38, 30, 22, 14,       6, 61, 53, 45, 37, 29, 21,	  13,  5, 60, 52, 44, 36, 28,      20, 12,  4, 27, 19, 11,  3,	]),/*int[]*/ totrot: [        1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28	],/*byte[]*/ pc2: byte:new([	13, 16, 10, 23,  0,  4,	 2, 27, 14,  5, 20,  9,	22, 18, 11, 3 , 25,  7,	15,  6, 26, 19, 12,  1,	40, 51, 30, 36, 46, 54,	29, 39, 50, 44, 32, 47,	43, 48, 38, 55, 33, 52,	45, 41, 49, 35, 28, 31,	]),/*int[]*/ SP1: byte:new("0101040000000000000100000101040401010004000104040000000400010000000004000101040001010404000004000100040401010004010000000000000400000404010004000100040000010400000104000101000001010000010004040001000401000004010000040001000400000000000004040001040401000000000100000101040400000004010100000101040001000000010000000000040001010004000100000001040001000004000004000000000401000404000104040101040400010004010100000100040401000004000004040001040401010400000004040100040001000400000000000001000
`4000104000000000001010004"),/*int[]*/ SP2: byte:new("8010802080008000000080000010802000100000000000208010002080008020800000208010802080108000800000008000800000100000000000208010002000108000001000208000802000000000800000000000800000108020801000000010002080000020000000000010800000008020801080008010000000008020000000000010802080100020001000008000802080100000801080000000800080100000800080000000002080108020001080200000002000008000800000000000802080108000001000008000002000100020800080208000002000100020001080000000000080008000000080208000000
`0801000208010802000108000"),/*int[]*/ SP3: byte:new("0000020808020200000000000802000808000200000000000002020808000200000200080800000808000008000200000802020800020008080200000000020808000000000000080802020000000200000202000802000008020008000202080800020800020200000200000800020800000008080202080000020008000000080202000800000000020008000002080002000008020200080002000000000000000200000200080802020808000200080000080000020000000000080200080800020800020000080000000802020800000008000202080002020008000008080200000800020800000208080200000002020
`8000000080802000800020200"),/*int[]*/ SP4: byte:new("0080200100002081000020810000008000802080008000810080000100002001000000000080200000802000008020810000008100000000008000800080000100000001000020000080000000802001000000800080000000002001000020800080008100000001000020800080008000002000008020800080208100000081008000800080000100802000008020810000008100000000000000000080200000002080008000800080008100000001008020010000208100002081000000800080208100000081000000010000200000800001000020010080208000800081000020010000208000800000008020010000008
`0008000000000200000802080"),/*int[]*/ SP5: byte:new("0000010002080100020800004200010000080000000001004000000002080000400801000008000002000100400801004200010042080000000801004000000002000000400800004008000000000000400001004208010042080100020001004208000040000100000000004200000002080100020000004200000000080100000800004200010000000100020000004000000002080000420001004008010002000100400000004208000002080100400801000000010002000000420800004208010000080100420000004208010002080000000000004008000042000000000801000200010040000100000800000000000
`0400800000208010040000100"),/*int[]*/ SP6: byte:new("2000001020400000000040002040401020400000000000102040401000400000200040000040401000400000200000100040001020004000200000000000401000000000004000102000401000004000004040002000401000000010204000102040001000000000004040102040400000004010004040002040400020000000200040000000001020400010004040002040401000400000000040102000001000400000200040002000000000004010200000102040401000404000204000000040401020404000000000002040001000000010000040002040000000404010000040000040001020004010000000002040400
`0200000000040001020004010"),/*int[]*/ SP7: byte:new("0020000004200002040008020000000000000800040008020020080204200800042008020020000000000000040000020000000204000000042000020000080204000800002008020020000204000800040000020420000004200800002000020420000000000800000008020420080200200800000000020400000000200800040000000020080000200000040008020400080204200002042000020000000200200002040000000400080000200000042008000000080200200802042008000000080204000002042008020420000000200800000000000000000204200802000000000020080204200000000008000400000
`2040008000000080000200002"),/*int[]*/ SP8: byte:new("1000104000001000000400001004104010000000100010400000004010000000000400401004000010041040000410001004100000041040000010000000004010040000100000401000100000001040000410000004004010040040100410000000104000000000000000001004004010000040100010000004104000040000000410400004000010041000000010000000004010040040000010000004104010001000000000401000004010040000100400401000000000040000100010400000000010041040000400401000004010040000100010001000104000000000100410400004100000041000000010400000104
`0000400401000000010041000"),// Routines taken from other parts of the Acme utilities.// Squash bytes down to ints.squashBytesToInts: func(/*byte[]*/ inBytes, int inOff, /*int[]*/ outInts, int outOff, int intLen )begin	// for now, outInts is pseudo-integer-array, so just copy	local int len := intLen*4; // number of bytes	BinaryMunger(outInts, outOff*4, len, inBytes, inOff, len);	/*	local int i;      for ( int i = 0; i < intLen; ++i ) {        outInts[outOff + i] =          ( ( inBytes[inOff    ] & 0xff ) << 24 ) |          ( ( inBytes[inOff + 1] & 0xff ) << 16 ) |          ( ( inBytes[inOff + 2] & 0xff ) <<  8 ) |          (   inBytes[inOff + 3] & 0xff );        inOff += 4;*/end,// Spread ints into bytes.spreadIntsToBytes: func(/*int[]*/ inInts, int inOff, /*byte[]*/ outBytes, int outOff, int intLen )begin	// for now, inInts is pseudo-integer-array, so just copy	local int len := intLen*4; // number of bytes	BinaryMunger(outBytes, outOff, len, inInts, inOff*4, len);/*	local int i, inInt;      for ( int i = 0; i < intLen; ++i ) {        int inInt = inInts[inOff + i];        outBytes[outOff    ] = (byte) ( inInt >>> 24 );        outBytes[outOff + 1] = (byte) ( inInt >>> 16 );        outBytes[outOff + 2] = (byte) ( inInt >>>  8 );        outBytes[outOff + 3] = (byte)   inInt;        outOff += 4;*/end,// == these operate on pseudo-integer-arrays (stored as bytes to avoid large int problem)/*boolean*/ EqualInt: func(/*byte[]*/ ddata, int di, /*byte[] | int*/ sdata, int si)begin // BinEqual doesn't use offset or len	local int i, val;	di := di*4;	si := si*4;	local /*boolean*/ sdataInt := IsInteger(sdata);	for i:=0 to 3	do begin		val := if sdataInt			then if sdata=0 then 0 else Band(0xFF, sdata >> (8 * (3-i)))			else ExtractByte(sdata,si+i);		if ExtractByte(ddata, di+i) <> val		then return false;		end;	return true;end,///*int*/ ExtractInt: func(/*byte[]*/ sdata, int si)//	ExtractLong(sdata, si*4),StuffInt: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si)begin	if IsInteger(sdata)	then StuffLong(ddata, di*4, sdata)	// assumes it isn't _too_ long	else BinaryMunger(ddata,di*4,4, sdata,si*4,4);/*	local int i;	di := di*4;	si := si*4;	for i:=0 to 3	do StuffByte(ddata, di+i, ExtractByte(sdata, si+i));*/end,BandInt: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si, /*byte[] | int*/ mdata, int mi):BOpInt(ddata,di,sdata,si,mdata,mi, GetGlobalFn('Band)),BorInt: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si, /*byte[] | int*/ mdata, int mi):BOpInt(ddata,di,sdata,si,mdata,mi, GetGlobalFn('Bor)),BxorInt: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si, /*byte[] | int*/ mdata, int mi)// shortcut won't work with Bxor:BOpInt(ddata,di,sdata,si,mdata,mi, GetGlobalFn('Bxor)),BOpInt: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si, /*byte[] | int*/ mdata, int mi, /*func*/ fn)begin	local int i;	di := di*4;	si := si*4;		mi := mi*4;	local /*boolean*/ mdataInt := IsInteger(mdata);		if (fn <> GetGlobalFn('Bxor)) and		Band(ExtractByte(sdata,si),0xE0)=0 and		(mdataInt or Band(ExtractByte(mdata,mi),0xE0)=0)	then StuffLong(ddata,di,			call fn with (ExtractLong(sdata,si),				if mdataInt				then mdata				else ExtractLong(mdata,mi)));	else for i:=0 to 3		 do StuffByte(ddata, di+i,				call fn with (ExtractByte(sdata, si+i),					if mdataInt					then Band(0xFF, mdata >> (8 * (3-i)))					else ExtractByte(mdata, mi+i)));end,	shiftBits: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si, int sh, /*boolean*/ signed)begin  // slow! but sure...	local /*int[]*/ array bits := Array(32,0);	local int bval, b := 0, bx;		// optim for left shift	if (sh < 0)	then begin		b := -sh;		si := si+(b div 8);		if Band(b,0x7) <> 0	// (b mod 8)		then begin			bval := ExtractByte(sdata, si);			si := si+1;			end;		end;	//get some/all current bits	for bx := b to 31	do begin		if (b := Band(bx,0x7)) = 0	// (bx mod 8)		then begin			bval := ExtractByte(sdata, si);			si := si+1;			end;		if (Band(bval, 1 << (7-b)) <> 0)		then bits[bx] := 1;		// optim for right shift		if (sh > 0) and (bx >= 31-sh)		then break;		end;	// shift them	local /*int[]*/ array newbits := Array(32, if signed and bits[0]=1 then 1 else 0);	if (sh > 0)	then ArrayMunger(newbits,sh,32-sh, bits,  0,32-sh) 	// right	else ArrayMunger(newbits,0, 32+sh, bits,-sh,32+sh);	// left	// store	bval := 0;	for bx := 0 to 31	do begin		b := Band(bx,0x7);	//bx mod 8;		if newbits[bx] = 1		then bval := Bor(bval, 1 << (7-b));		if b = 7		then begin			StuffByte(ddata, di, bval);			di := di+1;			bval := 0;			end;		end;end,RShiftInt: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si, int sh, /*boolean*/ signed)begin // assume 1 <= sh <= 31	di := di*4;	si := si*4;	local int val := ExtractByte(sdata,si);	// a few simple/safe optimizations	// pos int (no inaccessible bits or sign bit)	if (Band(val, 0xE0) = 0)	then return StuffLong(ddata,di, ExtractLong(sdata,si) >> sh);	// byte at a time (ok within 'same' number due to direction)	if Band(sh,0x7) = 0	//(sh mod 8)	then begin		local int i, fill := if signed and Band(byte0,0x80)=0x80 then 0xFF else 0;		sh := sh div 8;		for i:=3 to 0 by -1		do StuffByte(ddata,di+i, if (i >= sh) then ExtractByte(sdata,si+i-sh) else fill);		end			// do it the slow way (bit at a time)	else :shiftBits(ddata, di, sdata, si, sh, signed);end,LShiftInt: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si, int sh)begin // assume 1 <= sh <= 31	di := di*4;	si := si*4;	local int val;		// a few simple/safe optimizations	// disappearing low-order zeros?	if (sh >= 29)	then begin		val := ExtractByte(sdata,si+3);		if  (sh=31 and (Band(val, 0x1) = 0))			or			(sh=30 and (Band(val, 0x3) = 0))			or			(sh=29 and (Band(val, 0x7) = 0))		then return StuffLong(ddata,di,0);		// => bit at a time		end	// pos int (no inaccessible bits or sign bit)	else if (Band(ExtractByte(sdata,si), 0xE0) = 0)		and (val := ExtractLong(sdata,si)) <= masks[28-sh] // 29-sh can affect not only sign but also other 2 inaccessible bits!	then return StuffLong(ddata,di, val << sh);	// byte at a time (ok within 'same' number due to direction)	if Band(sh,0x7) = 0	//(sh mod 8)	then begin		local int i, fill := 0;		sh := sh div 8;		for i:=0 to 3		do StuffByte(ddata,di+i, if (i <= 3-sh) then ExtractByte(sdata,si+i+sh) else fill);		end			// do it the slow way (bit at a time)	else :shiftBits(ddata, di, sdata, si, -sh, false);end,/*int[]*/ masks: [	0x1, 		0x3, 		0x7, 		0xF,	0x1F, 		0x3F, 		0x7F, 		0xFF, 	0x1FF, 		0x3FF, 		0x7FF, 		0xFFF,	0x1FFF, 	0x3FFF, 	0x7FFF, 	0xFFFF, 	0x1FFFF,	0x3FFFF,	0x7FFFF,	0xFFFFF,	0x1FFFFF, 	0x3FFFFF, 	0x7FFFFF, 	0xFFFFFF, 	0x1FFFFFF, 	0x3FFFFFF, 	0x7FFFFFF, 	0xFFFFFFF, 	0x1FFFFFFF,	],});/*xd := MakeBinary(4,'bytes);xs := MakeBinary(4,'bytes);StuffLong(xs,0, 1);StuffByte(xs,0, 0x80F);ss:stringInt(xs,0);ss:LShiftInt(xd,0,xs,0,27); ss:StringInt(xd,0)ss:RShiftInt(xd,0,xs,0,27,false); ss:StringInt(xd,0)*/// End of text file DesCipher.ns// Beginning of text file Area.ns// this should work for regular bounds as well as AreaDefineGlobalConstant('kBoundsString, func(/*frame*/ bnds)begin	local int x := bnds.left, y := bnds.top;	"x: " & x & ", y: " & y &	", w: " & (bnds.right-x) & ", h: " & (bnds.bottom-y);end);/*Area is used to represent and iterate over rectangular areas.e.g., hextiles (16x16) or bitmap slices*/DefineGlobalConstant('Area, {// to emulate bounds frame (share frame map)/*int*/ left: 		nil,	// public vals (local rect)/*int*/ top: 		nil,/*int*/ right:		nil,	// only used by kBoundString ?/*int*/ bottom: 	nil,	// only used by kBoundString ?/*int*/ width:		nil,/*int*/ height:		nil,/*int*/ _left: 		nil,	// original vals (complete rect)/*int*/ _top: 		nil,	/*int*/ _right:		nil,/*int*/ _bottom: 	nil,/*int*/ _width: 	nil,/*int*/ _height:	nil,/*int*/ _widthInc: 	nil,/*int*/ _heightInc:	nil,_proto: nil,/*int*/ encoding: 	0,		// encoding(initially), subencoding(later)/*int*/ color: 		0,		// background/*int*/ fcolor:		0,		// foregroundnew: func(int x, int y, int w, int h, int wi, int hi)begin	if not wi	then wi := w;	if not hi	then hi := h; 	{	left: 		x, 		top:		y, 		right:		nil, 		bottom:		nil,    	width:		nil,    	height: 	nil,    	_left: 		x,	// complete rect		_top: 		y, 		_right:		x+w, 		_bottom:	y+h,    	_width: 	w,    	_height:	h,    	_widthInc: 	wi,	// typically 16 for Hex, width for raw    	_heightInc:	hi,	// typically 16 for Hex, 16 or 18 for bitmap slices 		_proto: 	self,    }:setNextsize(wi,hi);end,setNextSize: func(int wi, int hi)	// usually before 1st :next if not set correctly in :newbegin	if wi	then begin		width := min(_width, _widthInc := wi);		right := left + width;		end;	if hi	then begin		height := min(_height, _heightInc := hi);		bottom := top + height;		end;	self;end,/*string*/ toString: func()		// current local rect	//"RelBounds(" & left & $, & top & $, & width & $, & height & $),	call kBoundsString with (self),/*int*/ area: func() width * height,	// current local rect/*int*/ totalRects: func()	// # of local rects in complete rect	:rows() * :cols(),/*int*/ cols: func()	(_width + _widthInc-1) div _widthInc,/*int*/ rows: func()	(_height + _heightInc-1) div _heightInc,/*int*/ next: func()		// nil if done. otherwise 'progressHt'begin	left := left + _widthInc;    if left >= _right    then begin		top := top + _heightInc;		if top >= _bottom		then return nil;		height := min(_bottom-top, _heightInc);    	bottom := top + height;		left := _left;   		end;	width := min(_right-left, _widthInc);    right := left + width;	return					// for :setGauge		if  left = _left		then top - _top		else -1;end,});// End of text file Area.ns// Beginning of text file rfbProto.ns// VERSION STUFFconstant /*String*/ VERSIONMSG := "RFB 003.003\u000A"; // end with unicodeLF (\u000A) rather than unicodeCR (\n)// AUTHENTICATIONconstant /*int*/ ConnFailed := 0, NoAuth := 1, VncAuth := 2;constant /*int*/ VncAuthOK := 0, VncAuthFailed := 1, VncAuthTooMany := 2;// VIEWER (input) STATESconstant /*int*/ FramebufferUpdate := 0, SetColourMapEntries := 1, Bell := 2, ServerCutText := 3;constant kViewerMessageNames := '["UpdateRequest",  "ColourMap", "Bell", "Cut", "?"];	// for debuggingconstant VIEWER_STATES		 := '[GetUpdateRectsNum, ColourMap,	 GetBell, GetServerCutLen, UnknownMsg];// SERVER (input) STATESconstant /*int*/ SetPixelFormat := 0, FixColourMapEntries := 1,	SetEncodings := 2, FramebufferUpdateRequest := 3, KbdEvent := 4, // was KeyEvent	PointerEvent := 5, ClientCutText := 6;constant kServerMessageNames := '["SetPixelFormat", "ColourMap", "SetEncodings",  "UpdateRequest",  "Kbd", "Pointer", "Cut", "?"];	// for debuggingconstant SERVER_STATES		 := '[GetClientFormat,	ColourMap,	 GetEncodingsLen, GetUpdateRequest, GetKbdEvent, GetPointerEvent, GetClientCutLen, UnknownMsg];// ENCODINGS constant /*int*/ EncodingRaw := 0, EncodingCopyRect := 1, EncodingRRE := 2,	EncodingCoRRE := 4, EncodingHextile := 5, EncodingZlib := 6, EncodingZlibHex := 8;constant kNumZibFlaters := 2;// use slot if including Tight (otherwise compile flag -- see :close)/*constant EncodingTight := 7;constant TightExplicitFilter := 0x04, TightFill := 0x08,	TightMaxSubencoding := 0x08, TightFilterCopy := 0x00,	TightFilterPalette := 0x01, TightFilterGradient := 0x02;constant TightMinToCompress := 12;	// not supported	EncodingCompressLevel0 := 0xFFFFFF00, EncodingXCursor := 0xFFFFFF10,	EncodingRichCursor := 0xFFFFFF11, EncodingLastRect := 0xFFFFFF20;*/DefineGlobalConstant(/*string[]*/ 'kEncodingNames, [	LocObj("Raw",		'raw),	LocObj("CopyRect", 	'copyRect),	LocObj("RRE", 		'RRE),	"3",	LocObj("CoRRE", 	'CoRRE),	LocObj("Hextile", 	'Hextile),	LocObj("Zlib", 		'zlib),	LocObj("Tight", 	'tight),	LocObj("ZlibHex",	'zlibHex),	]);constant /*int*/ HextileRaw					:= (1 << 0);constant /*int*/ HextileBackgroundSpecified	:= (1 << 1);constant /*int*/ HextileForegroundSpecified	:= (1 << 2);constant /*int*/ HextileAnySubrects			:= (1 << 3);constant /*int*/ HextileSubrectsColoured	:= (1 << 4);//constant /*int*/ HextileZlibRaw			:= (1 << 5);//constant /*int*/ HextileZlibHex			:= (1 << 6);// PENconstant /*int*/ kBut1 	:= 1;constant /*int*/ kBut2 	:= 2;constant /*int*/ kBut3 	:= 4;constant /*int*/ kButOff := 0;constant /*int*/ kButNone := -1;// for InsertTabletSampleconstant kPenDownSample := 13;	// Flag for a pen down in the bufferconstant kPenUpSample   := 14;  // Flag for a pen up in the buffer//constant kInvalidSample := 15;// KEY STUFFconstant KEY_PRESS 	 		:= 1;	// "down"constant KEY_RELEASE 		:= 0;constant /*int*/ chDEL := 127;constant /*int*/ kOptionsModifier 	:= 1 << 28;	// should have been defined in platform fileDefineGlobalConstant('kAnyModifier, kControlModifier + kCommandModifier + kOptionsModifier+ kShiftModifier + kCapsLockModifier);DefineGlobalConstant('MODIFIERS_VNC, [0xffe3, 			0xffe1, 		0xffe7, 			0xffe9]);DefineGlobalConstant('MODIFIERS_NWT, [kControlModifier, kShiftModifier, kOptionsModifier, 	kCommandModifier]);DefineGlobalConstant('MODIFIERS_KC,  [kControlKeyCode,	kShiftKeyCode,	kOptionKeyCode,		kCommandKeyCode]);DefineGlobalConstant('F_KEYS_NWT, [	Ord($\uF721), Ord($\uF722), Ord($\uF723), Ord($\uF724), Ord($\uF725), Ord($\uF726),	//F1-F6	Ord($\uF727), Ord($\uF728), Ord($\uF729), Ord($\uF72A), Ord($\uF72B), Ord($\uF72C),	//F7-12	//Ord($\uF72D), Ord($\uF72E), Ord($\uF72F)	//F13-F15 ???	]);constant F_KEYS_VNC := 0xffbe;	//=F1constant F_KEYS_KC  := nil;		// ??? don't know these keyCodesDefineGlobalConstant('ARROW_KEYS_VNC, [0xff51, 	0xff52, 0xff53, 0xff54, 0xffff]);DefineGlobalConstant('ARROW_KEYS_NWT, [chFS, 	chRS, 	chGS, 	chUS,	chDEL]);	//left, up, right, down arrows. del incl. here for convenienceDefineGlobalConstant('ARROW_KEYS_KC,  [123,		nil,	124,	nil,	51]);		// ??? keycodes: up,downDefineGlobalConstant('SPEC_KEYS_VNC, [0xff08, 	0xff09, 0xff0d, 0xff1b, 0xff0d]);DefineGlobalConstant('SPEC_KEYS_NWT, [chBS, 	chHT, 	chCR, 	chESC, 	chETX]);	// bs, tab, cr, esc, enter(cr)DefineGlobalConstant('SPEC_KEYS_KC,  [51, 		48, 	36, 	nil, 	36]);		// ??? Escconstant CHALLENGE_LEN  := 16;constant CHALLENGE_LEN2 :=  8;constant MSG_TYPE_LEN := 1;constant kInvalidRectColor := 173;DefineGlobalConstant('kRefreshNames, [	LocObj("full", 'full),	LocObj("incr", 'incremental),	]);// -1 are set dynamically (:nextInputLen); 0 are transition states;// otherwise fixed lens (:nextInput)// since these are constants, compiler appears to substitute at build time// also used to check that necessary states exist at build-time// these are basically in sequence, with alternatives nestedDefineGlobalConstant('STATE_LEN, {//NotRunning:						-1,// VIEWER// handshakingGetServerVersion:				12, //(string) = StrLen(VERSIONMSG)SendVersionMsg:					0,	GetAuth:					4,  //(int)	GetConnFailLen:				4,  //(int)	GetConnFailReason:			-1, //(string)=GetConnFailLen	GetServerChallenge:			CHALLENGE_LEN, //(bytes)	GetServerChallengeResponse:	 4, //(int)SendClientInit:					1,	//bGetServerFormat:				24, //w(s2),h(s2),bpp(b),d(b),e(b),c(b),rx(s2),gx(s2),bx(s2),r(b),g(b),b(b),pad(3),nameLen(4)GetServerName:					-1, //(string)=nameLenSendFormat:						20,	//b,pad(3),....,-nameLen// requests to serverSendUpdateRequest:				10,	//b,b,w,w,w,wSendCutText:					8,	//b,pad(3),long,str// responses from serverGetServerMessageType:			MSG_TYPE_LEN,  //(byte)	GetServerCutLen:			7,  //pad(3),cutLen(int)	GetServerCutText:			-1, //(string): @GetServerCutLen	ColourMap:					0,	//error	UnknownMsg:					0,	//error	GetBell:					0,	//no data needed	GetUpdateRectsNum:			3,  //pad(1), rectsNum(short)	GetUpdateRects:				12, //x(s),y(s),w(s),h(s),enc(int)	//GetRawRect:				-1, //w*h	GetRawRectN:				-1, //w*16|h	GetCopyRect:				4,  //x(s),y(s)	GetSubRectsRRENum:			5,  //subrects(int),bg(b)	GetSubRectsCoRRENum:		5,  //subrects(int),bg(b)	GetSubRectsRREN:			9,  //nSubRects * pixel(b),x(s),y(s),w(s),h(s)	GetSubRectsCoRREN:			5,  //nSubRects * pixel(b),x(b),y(b),w(b),h(b)	GetHexSubEncoding:			1,  //(byte)	GetHexSubEncodingRaw:		-1, //tw*th	GetHexSubEncoding3:			-1, //b?,b?,b?	GetHexSubEncodingSubrectN:	2,	//nSubRects*b,b: 2	GetHexSubEncodingSubrectFGN:3,	//nSubRects*b,b,b: 3	GetHexSubEncodingNext:		0,  //(transition). ok to inline rather than via :nextInput()	GetUpdateRectsNext:			0,  //(transition)	GetZlibNum:					4,	//long	GetZlibBytes:				-1,	// @GetZlibNum// ADD_SERVER// handshaking//SendVersionMsgGetClientVersion:				12, // GetServerVersion	GetClientChallenge:			CHALLENGE_LEN, // GetServerChallengeGetClientInit:					 1, // SendClientInit//SendFormat// requests from viewerGetClientMessageType:			MSG_TYPE_LEN,	//b(msgType),pad(1)	GetClientFormat:			19,	//SendServerFormat-1	GetEncodingsLen:			3,	//w	GetEncodings:				-1,	//4*len	GetClientCutLen:			7,	//SendCutText-1	GetClientCutText:			-1,	//len	GetUpdateRequest:			9,	//SendUpdateRequest-1	SendUpdateRect:				4+17,	//SendBell:					1,	// events	GetPointerEvent:			5,	//b,w,w	GetKbdEvent:				7,	//b,pad(2),long	//SendCutText});DefineGlobalConstant('rfbProto, {/*Socket*/ sock: null,/*boolean*/ inNormalProtocol: false,/*vncview*/ v: nil,/*vncCanvas*/ vc: nil,/*boolean*/ server: nil,/*int*/ updateNRects: nil,/*int*/ nSubRects: nil,/*Area*/ updateArea: nil,/*string*/ password: nil,challenge: nil,/*array*/ _refreshArgs: [INCR_REFRESH, INCR_DELAY, nil],new: func(/*String*/ h, int p, /*String*/ pw, /*vncview*/ v1)	{_proto: self,	v: v1,	vc: v1.vc,	host: h,	port: p,	sock: nil,    password: pw,  // save    // for viewer, initially big enough for writeKeyEvent: <= 32*3 + 2*8    // for server, big enough to send bitmap: full width * 18 + raw header(=12)    eventBuf: byte:new(if StrFilled(h) then 112 else VBO_LEN+12),    server: not StrFilled(h),    refreshArgs: _refreshArgs,    },connect: func()begin	// this is async	sock := Socket:new(host, port, self);end,setSize: func(int w, int h)	// ADD_SERVERbegin	framebufferWidth  := w;	framebufferHeight := h;end,setName: func(/*string*/ s)	// ADD_SERVER	serverName := s,/*int*/ framebufferWidth:  0,/*int*/ framebufferHeight: 0,// these are the default settings Newton server uses. sent by viewer&server -- see checkFormat// values from viewer checked by newtVNC server; server values ignored by newtVNC viewer/*int*/ bpp: 		8,/*int*/ depth: 		8,/*int*/ bigEndian:  1,	// NA for depth=8/*int*/ trueColour: 1,	// interp pixel via max/shift rather than colourtable (which isn't supported anyway)???/*int*/ redMax:   	7,/*int*/ greenMax: 	7,/*int*/ blueMax:  	3,/*int*/ redShift:   0,/*int*/ greenShift: 3,/*int*/ blueShift:  6,/*string*/ serverName: nil,/*boolean*/ isOpen: func()	// note: rfb:?isOpen() returns nil if rfb=nil	inNormalProtocol,disconnected: func()	v:disconnected(),status: func(/*string*/ msg, arg, /*boolean*/ doLog)	v:status(msg, arg, doLog),/*boolean*/ error: func(/*string*/ msg, earg, /*boolean*/ fatal)	// fr = currentException()begin	// earg: string, int, nil or frame=currentException()	local errCode := earg, pos;	if IsFrame(earg) 	then if not (errCode := earg.error)		then if IsFrame(earg.data)			then errCode := earg.data.errorCode;	if IsInteger(errCode)	then if pos := SetContains(ROM_errorTable, errCode)		then errCode := errCode && ROM_errorTable[pos+1]		else if errCode <= -60000 and GetGlobalFnExists('InetGetErrorString)		then errCode := errCode && InetGetErrorString(errCode);	msg := $: && _inState && msg & $: && errCode;if DEBUG then Print("error" & msg);	v:status(LocObj("error", 'error), msg, DO_LOG);	if fatal	then begin		//GetRoot():Notify(kNotifyMessage, kAppName, LocObj("disconnected", 'disconnected) & msg);		PlaySound(ROM_soundOff.gongBeep);		v:disconnect(nil);		end;    nil;	// currently not used (by state machine)end,connected: func()begin	if ADD_SERVER and server and IsArray(sock._address) and Length(sock._address)=5	then begin//if DEBUG then Print(['connected, sock._address]);		sock.port := sock._address[4];		SetLength(sock._address, 4);		sock.host := InetIPAddressToString(sock._address);		end;	v:status(LocObj("connected", 'connected), sock.host & $: & sock.port, NO_LOG); // ??? _address, esp. for server	// socket has successfully connected	// server starts by sending version	// viewer starts by reading version	if ADD_SERVER and server	then :SendVersionMsg('GetClientVersion)	else :nextInputLen('GetServerVersion, STATE_LEN.GetServerVersion);end,close: func()begin	zlibFlater := zlibFlater:?close();	inNormalProtocol := _inState := _outState := nil;    sock := sock:?close();	// in case already closed    nil;end,// most transitions use :nextInputLen directly// if length is computed, or to avoid extra method call (if length lookup inlined by compiler)///*boolean*/ nextInput: func(/*symbol*/ next) :nextInputLen(next, STATE_LEN.(next)),/*symbol*/ _inState: nil,/*byte*/ _inBuf: nil,	// used only in nextInputLen/*int*/  _inLen: nil,	// set in nextInputLen, used by states -- Length(_inBuf) might be > _inLen/*boolean*/ nextInputLen: func(/*symbol*/ next, int len)begin	if not len and next	then len := STATE_LEN.(next);	//if DEBUG then Print(next && $[ & len & $]);if PROFILE then vc:testFreq(next, 1);if PROFILE then vc:testFreq('readBytes, len);if TIMING then bytesR := bytesR + len;	// record in advance    _inState := next;    if (len = _inLen)    then return true;				// SAME (still active) inputSpec (no need for readBytes)    _inLen := len;    if (len <= 0)	// a 'next' (or not running) state -- no new data needed    then return Perform(self, _inState, nil); // go immediately (no data arg)    if (_inBuf = nil)    then _inBuf := byte:new(len)	// alloc first    else if (Length(_inBuf) < len)    then if len > VBO_LEN    then _inBuf := GetDefaultStore():NewVBO('bytes, len)    else SetLength(_inBuf, len);	// make bigger	sock:?readBytes(_inBuf,0,len);    true;end,_outLen: 	nil,_outState: 	nil,_outBuf:	nil,/*byte[]*/ getOutputBuf: func(int len)begin	_outLen := len;	// reuse eventBuf when possible to avoid extra allocation	// but if Output is busy, assume eventBuf might still be in use	if _outState or len > Length(eventBuf)		then byte:new(len)		else eventBuf;end,OutputCallback: func()	// generic callback. flushes queue (if any)begin	if _outBuf	then sock:?writeBytes(_outBuf, 0, _outBuf := nil)	// _outState remains set	else _outState := nil;end,nextOutput: func(/*symbol*/ next, /*byte[]*/ data, int len)beginif TIMING then bytesW := bytesW + len;	// record in advance//if PROFILE then vc:testFreq(next, 1);	if _outState and data	// Output in progress. so queue	then beginif PROFILE then vc:testFreq('writeBytesQ, len);		if _outBuf		then BinaryMunger(_outBuf,Length(_outBuf),nil, data,0,len)		else _outBuf := ExtractBytes(data, 0, len, ClassOf(data));		end	else beginif PROFILE then vc:testFreq('writeBytes, len);		_outState := if next then next else 'OutputCallback;		if data		then sock:?writeBytes(data, 0, len)		else :OutputCallback();	// to flush, e.g. at end of SendBitmapRect		end;end,/*int*/ progRect: 	0,		// used for 'countdowns' for setGauge/*int*/ progHt:		0,		// used for 'countdowns' for setGauge// ===== STATESSendVersionMsg: func(/*symbol*/ next)	// Write our protocol version messagebegin	local /*byte*/ data := :getOutputBuf(STATE_LEN.GetServerVersion + 1);	// same as GetClientVersion	StuffCString(data, 0, VERSIONMSG);	:nextOutput(nil, data, _outLen-1);	// allocated extra for StuffCString null    :nextInputLen(next, nil);end,//GetClientVersion:	***					// ADD_SERVER.  SendVersionMsg already occurred in :connectedGetServerVersion: func(/*byte[]*/ data)	// VIEWERbegin	local c4 := ExtractChar(data,4), c5 := ExtractChar(data,5), c6  := ExtractChar(data,6);	local c8 := ExtractChar(data,8), c9 := ExtractChar(data,9), c10 := ExtractChar(data,10);	// NS note: ok to do char comparisons, but not char arithmetic	if (   (ExtractChar(data,0) <> $R) or (ExtractChar(data,1) <> $F)		or (ExtractChar(data,2) <> $B) or (ExtractChar(data,3) <> $ )        or (c4                   < $0) or (c4            		> $9)        or (c5            		 < $0) or (c5            		> $9)        or (c6            		 < $0) or (c6            		> $9)        or (ExtractChar(data,7) <> $.)        or (c8            		 < $0) or (c8            		> $9)        or (c9            		 < $0) or (c9            		> $9)		or (c10           		 < $0) or (c10           		> $9)		or (ExtractChar(data,11)<> unicodeLF) // $\0A		)	then return :error(LocObj("incompat VNC version", 'incompatVersion), :ExtractString(data,0,_inLen), FATAL_ERROR);    local /*string*/ ver := :ExtractString(data,4,7);	if ADD_SERVER and server	then beginif DEBUG then Print([_inState, ver]);    	v:status(LocObj("VNC viewer", 'vncViewer), ver, DO_LOG);		local int pwlen := StrLen(password), i;		if pwlen=0		then begin			data := :getOutputBuf(STATE_LEN.GetAuth);			StuffLong(data, 0, NoAuth);			:nextOutput(nil, data, _outLen);			:nextInputLen('GetClientInit, STATE_LEN.GetClientInit);			end		else begin			data := :getOutputBuf(STATE_LEN.GetAuth + STATE_LEN.GetServerChallenge);			StuffLong(data, 0, VncAuth);			for i := 4 to _outLen-1		// create random 16-byte challenge			do StuffByte(data, i, Random(0,255));			challenge := ExtractBytes(data, 4, CHALLENGE_LEN, 'bytes);	// save to encrypt and compare			:nextOutput(nil, data, _outLen);			:nextInputLen('GetClientChallenge, STATE_LEN.GetClientChallenge);			end;		end	else begin   		v:status(LocObj("VNC server", 'vncServer), ver, DO_LOG);		:SendVersionMsg('GetAuth);		end;end,GetClientChallenge: func(/*byte[]*/ data)	// ADD_SERVER. read the client responsebegin	local /*boolean*/ ok := BinEqual(:encryptChallenge(challenge,password), ExtractBytes(data,0,CHALLENGE_LEN,'bytes));	challenge := nil;	data := :getOutputBuf(STATE_LEN.GetServerChallengeResponse);	StuffLong(data, 0, if ok then VncAuthOK else VncAuthFailed);	:nextOutput(nil, data, _outLen);	if ok	then :nextInputLen('GetClientInit, STATE_LEN.GetClientInit)	else :error(LocObj("Authentication failed", 'authFailed), nil, FATAL_ERROR);end,GetAuth: func(/*byte[]*/ data) // readAuthSchemebegin	local int authScheme := ExtractLong(data,0);	if (authScheme = VncAuth)	then begin		v:status(LocObj("Authentication needed", 'authNeeded), nil, DO_LOG);		:nextInputLen('GetServerChallenge, STATE_LEN.GetServerChallenge);		end	else if (authScheme = NoAuth)	then begin		v:status(LocObj("No authentication needed", 'authNotNeeded), nil, NO_LOG);		:SendClientInit(nil);		end	else if (authScheme = ConnFailed)	then :nextInputLen('GetConnFailLen, STATE_LEN.GetConnFailLen)	else //default:		:error(LocObj("Unknown authentication scheme", 'authScheme), authScheme, FATAL_ERROR);end,GetServerChallenge: func(/*byte[]*/ data)begin	//In case of VncAuth the authentication scheme used is simple	//challenge/response scheme, i.e. server sends the challenge which client	//encrypts using a shared key and then waits for response from the server.	challenge := :encryptChallenge(ExtractBytes(data,0,_inLen,'bytes), password);    :nextOutput(nil, challenge, Length(challenge));	:nextInputLen('GetServerChallengeResponse, STATE_LEN.GetServerChallengeResponse);end,GetServerChallengeResponse: func(/*byte[]*/ data)begin	local int authResult := ExtractLong(data,0);	if (authResult = VncAuthOK)	then begin		v:status(LocObj("Authentication succeeded", 'authSuccess), nil, DO_LOG);		:SendClientInit(nil);		end	else if (authResult = VncAuthFailed)	then begin		v.authenticator:open();		:error(LocObj("Authentication failed", 'authFailed), nil, FATAL_ERROR);		end	else if (authResult = VncAuthTooMany)	then :error(LocObj("Authentication failed: too many tries", 'authTooMany), nil, FATAL_ERROR);	else //default:		:error(LocObj("unknown VNC auth result", 'authResult), authResult, FATAL_ERROR);end,GetConnFailLen: func(/*byte[]*/ data)	// VIEWER	:nextInputLen('GetConnFailReason, ExtractLong(data,0)),GetConnFailReason: func(/*byte[]*/ data)	// VIEWER	:error(LocObj("VNC connection failed", 'vncConnFailed), :ExtractString(data,0,_inLen), FATAL_ERROR),GetClientInit: func(/*byte[]*/ data)	// ADD_SERVER. read the client initialisation messagebegin	local int sharing := ExtractByte(data,0);if DEBUG then Print([_inState, sharing]);	v:status(LocObj("Share Desktop", 'shareDesktop), kYesNo[1-sharing], DO_LOG); // ignore....	:SendFormat('GetClientMessageType);	inNormalProtocol := true;	v:connected(sock.host & $: & sock.port, nil, nil);	//host:port cached in rfb:connectedend,SendClientInit: func(/*byte[]*/ data)	// VIEWER. write the client initialisation messagebegin	local int sharing := if v.options.shareDesktop then 1 else 0;	data := :getOutputBuf(STATE_LEN.SendClientInit);	v:status(LocObj("Share Desktop", 'shareDesktop), kYesNo[1-sharing], DO_LOG);    StuffByte(data, 0, sharing);    :nextOutput(nil, data, _outLen);    v:?disableShareDesktop();	// ?? undef for now	:nextInputLen('GetServerFormat, STATE_LEN.GetServerFormat);end,GetServerFormat: func(/*byte[]*/ data)	// VIEWERbegin	framebufferWidth  := ExtractWord(data,0);    framebufferHeight := ExtractWord(data,2);	// don't bother to check/report; assume server will conform to later viewer request    //local msg := :checkFormat(data, 4, {});    //if msg then v:status(LocObj("incompat formats", 'incompatFormats), msg, DO_LOG);  	:nextInputLen('GetServerName, ExtractLong(data,20)); // name lenend,/*boolean*/ checkFormat: func(/*byte[]*/ data, int offset, /*frame*/ checkFrame)if checkFramethen begin    checkFrame.bpp			:= ExtractByte(data, offset);    checkFrame.depth 		:= ExtractByte(data, offset+1);	checkFrame.bigEndian  	:= ExtractByte(data, offset+2);		// NA for single-byte pixels    checkFrame.trueColour 	:= ExtractByte(data, offset+3);    checkFrame.redMax 		:= ExtractWord(data, offset+4);    checkFrame.greenMax 	:= ExtractWord(data, offset+6);    checkFrame.blueMax 		:= ExtractWord(data, offset+8);    checkFrame.redShift 	:= ExtractByte(data, offset+10);    checkFrame.greenShift 	:= ExtractByte(data, offset+11);    checkFrame.blueShift 	:= ExtractByte(data, offset+12);	// ignore pad(3) at end	local slot, val, msg;	foreach slot,val in checkFrame	do if val <> self.(slot)		then beginif DEBUG then Print([slot, val, self.(slot)]);			msg := msg && slot;			end;	msg;	endelse nil,GetClientFormat: func(/*byte[]*/ data)	// ADD_SERVERbegin	// store in local frame, then compare against server preferences	local msg := :checkFormat(data, 3, {});		// msgType read in GetClientMessageType	// for now, warn if there are differences, or :error???. later try to be nicer and adjust...	if msg	then v:status(LocObj("incompat formats", 'incompatFormats), msg, DO_LOG);	:nextInputLen('GetClientMessageType, STATE_LEN.GetClientMessageType);end,SendFormat: func(/*symbol*/ next)	// VIEWER & ADD_SERVERbegin	local int offset;	local /*byte[]*/ data := :getOutputBuf(		(if ADD_SERVER and server		then STATE_LEN.GetServerFormat + StrLen(serverName)		else STATE_LEN.SendFormat) + 1);    if ADD_SERVER and server    then begin//v:status("SendFormat", serverName & $; && framebufferWidth & $x & framebufferHeight, DO_LOG);if DEBUG then Print(['SendFormat, _outLen-1, bpp, depth, framebufferWidth, framebufferHeight, serverName]);		StuffWord(data,0, framebufferWidth);	// pad: 1		StuffWord(data,2, framebufferHeight);		StuffLong(data,20, StrLen(serverName));		StuffCString(data, 24, serverName);		end    else beginif DEBUG then Print(['SendFormat, _outLen-1, bpp, depth]);		StuffByte(data,0, SetPixelFormat);  // pad: 3		end;    offset := 4;    // currently, these are rfbProto (default values)//v:status("SendFormat", bpp && depth && bigEndian && trueColour, DO_LOG);    StuffByte(data, offset, 	bpp);    StuffByte(data, offset+1, 	depth);    StuffByte(data, offset+2,	bigEndian);    StuffByte(data, offset+3,	trueColour);    StuffWord(data, offset+4,	redMax);    StuffWord(data, offset+6,	greenMax);    StuffWord(data, offset+8,	blueMax);    StuffByte(data, offset+10,	redShift);    StuffByte(data, offset+11,	greenShift);    StuffByte(data, offset+12,	blueShift);    //pad: 3//v:status("SendFormat", "output:" && _outLen-1, DO_LOG);    :nextOutput(nil, data, _outLen-1);	// -1 for StuffCString null//v:status("SendFormat", next, DO_LOG);    :nextInputLen(next, nil);end,GetServerName: func(/*byte[]*/ data)	// VIEWERbegin	serverName := :ExtractString(data,0,_inLen);	:SendFormat('GetServerMessageType);	// assume not overwritten in earlier GetServerInit ???	inNormalProtocol := true;	// this calls setEncodings, processNormalProtocolInit w/ full refresh request	v:connected(serverName, framebufferWidth, framebufferHeight);end,SetEncodings: func (/*int[]*/ array encodings)  // VIEWER. Write a SetEncodings messageif inNormalProtocolthen begin	local int len := Length(encodings);    local /*byte[]*/ data := :getOutputBuf(4 + (4 * len));//if DEBUG then Print(['setEncodings, len, _outLen]);    //StuffLong(data,0, 0);	// 0 padding    StuffByte(data,0, SetEncodings);    StuffWord(data,2, len);	local /*string*/ msg;    local int offset := 4, encoding;    foreach encoding in encodings    do begin		msg := msg && kEncodingNames[encoding] & $,;		StuffLong(data, offset, encoding);		offset := offset+4		end;     	v:status(LocObj("SetEncodings", 'setEncodings), msg, DO_LOG);    :nextOutput(nil, data, _outLen);end,SendUpdateRequest: func(/*frame*/ bnds, int refresh) // VIEWERbeginif PROFILE then vc:testFreq('writeFramebufferUpdateRequest, 1);	v:status(kRefreshNames[refresh], call kBoundsString with (bnds), NO_LOG);    local /*byte[]*/ data := :getOutputBuf(STATE_LEN.SendUpdateRequest);    StuffByte(data, 0, FramebufferUpdateRequest);    StuffByte(data, 1, refresh);    :StuffUpdateRequest(data, 2, bnds, nil);    :nextOutput(nil, data, _outLen);end,GetUpdateRequest: func(/*byte[]*/ data)	// ADD_SERVERbegin	local int refresh := ExtractByte(data,0), offset := 1;	// ignore incremental requests (basically redundant)	if refresh = FULL_REFRESH	then begin		local /*frame*/ bnds := RelBounds(			ExtractWord(data, offset),			ExtractWord(data, offset+2),			ExtractWord(data, offset+4),			ExtractWord(data, offset+6));		//if not vc.incrUpdates then	// ?? first time kludge		// v:status(kRefreshNames[refresh], call kBoundsString with (bnds), DO_LOG);		//if not :RectEqual(bnds, vc.localBounds)	// if not actually full screen, do 'incremental' on area		//then refresh := INCR_REFRESH;		vc:Refresh(refresh, if DEBUG then 'GetUpdateRequest else NO_DELAY, bnds);	// actually some delay until viewIdleScript		end;	:nextInputLen('GetClientMessageType, STATE_LEN.GetClientMessageType);end,SendCutText: func(/*string*/ text) 	// VIEWER, ADD_SERVERif inNormalProtocolthen beginif DEBUG then Print(['SendCutText, text]);    local int len := StrLen(text);    local /*byte[]*/ data := :getOutputBuf(STATE_LEN.SendCutText + len +1); // allow 1 for null for StuffCString    //StuffLong(data,0, 0);	// 0 padding    StuffByte(data,0, if server then ServerCutText else ClientCutText);    StuffLong(data,4,len);    StuffCString(data,8,text); // write unnec null    :nextOutput(nil, data, _outLen);end,ColourMap: func(/*byte[]*/ data)	:error(LocObj("Can't handle Fix/Set ColourMapEntries", 'colorMap), nil, FATAL_ERROR),UnknownMsg: func(/*byte[]*/ data)	:error(LocObj("Unknown RFB msg type", 'rfbMsgType), ExtractByte(data,0), FATAL_ERROR),// SERVERGetKbdEvent: func(/*byte*/ data)		// ADD_SERVERbegin	local int updown := ExtractByte(data,0), key := ExtractLong(data,3), i, keyCode;	local msg, modKey;	if i := SetContains(MODIFIERS_VNC, key)	then keyCode := modKey := MODIFIERS_KC[i]	else if i := SetContains(SPEC_KEYS_VNC, key)	// kStringToKeyCodesFunc does work for bs,tab,cr	then keyCode := SPEC_KEYS_KC[i]	else if i := SetContains(ARROW_KEYS_VNC, key)	then keyCode := ARROW_KEYS_KC[i]	else if 0 <= (i := key - F_KEYS_VNC) and i < 12	then keyCode := F_KEYS_KC	// note: unknown key codes	else try		begin			i := call kStringToKeyCodesFunc with ("" & Chr(key));			if IsArray(i) and Length(i)=2			then keyCode := i[1]			else if IsArray(i) and Length(i)=4			then keyCode := i[2]			else msg := i;		end		onexception |evt.ex|		do msg := "kStringToKeyCodesFunc";if DEBUG then Print(['key, (if updown=KEY_PRESS then "down" else "up"), key, keyCode, (if msg then msg else if not keyCode then "no mapping")]);	if keyCode	then begin		if updown=KEY_PRESS		then begin			keyCode := Bor(keyCode, 128);			if not modKey then PlaySound(ROM_typewriter);			end;		HandleKeyEvents([keyCode]);		end;	:nextInputLen('GetClientMessageType, STATE_LEN.GetClientMessageType);end,/*int*/ lastBut: kButOff,/*int[]*/ butX:	nil,/*int[]*/ butY:	nil,//samples: nil,GetPointerEvent: func(/*byte*/ data)	// ADD_SERVERbegin	local int but := ExtractByte(data,0);	// ...up, [down, down,...down, up],...	if but = kButOff	then begin		if lastBut <> kButOff		then begin	// sequence end//if DEBUG then Print(['Pen, Length(butX), butX, butY]);			// InsertTabletSample 'all at once' -- avoid interference with comms etc./*			local fn := GetGlobalFn('InsertTabletSample);			local array sample;			AddArraySlot(samples, [0,0, kPenUpSample,ticks()]);			foreach sample in samples			do Apply(fn, sample);			samples := nil;*/			local int i;			InsertTabletSample(0,0, kPenDownSample, 0);			for i:=0 to Length(butX)-1			do InsertTabletSample(butX[i], butY[i], 7, 0);			InsertTabletSample(0,0, kPenUpSample, 0);					butX := butY := nil;			vc:Refresh(IMMED_REFRESH, nil, nil);			end;		end	else begin		if lastBut = kButOff		then begin	// sequence start			butX := []; butY := [];			//samples := [[0,0, kPenDownSample,ticks()]];			end;		// sequence: add a point		local int x := ExtractWord(data,1), y := ExtractWord(data,3);		//AddArraySlot(samples, [x,y,7,ticks()]);		AddArraySlot(butX, x); AddArraySlot(butY, y);		end;	lastBut := but;	:nextInputLen('GetClientMessageType, STATE_LEN.GetClientMessageType);end,/*call func(x,y)beginInsertTabletSample(0,0,13, 0);	//kPenDownSampleInsertTabletSample(x,y,7, 0);InsertTabletSample(0,0,14, 0);	//kPenUpSampleend with (5,5)*/GetEncodingsLen: func(/*byte*/ data)	// ADD_SERVER	:nextInputLen('GetEncodings, 4*ExtractWord(data,1)),GetEncodings: func(/*byte*/ data)		// ADD_SERVERbegin	local int len := _inLen div 4, encoding;	local array encodings := v.encodings := Array(len,0);	local /*string*/ msg;    for i:=0 to len-1    do begin		encodings[i] := encoding := ExtractLong(data, i*4);		msg := msg && (if encoding < 0 or encoding >= Length(kEncodingNames)			then encoding			else kEncodingNames[encoding]) & $,;		end;    v:status(LocObj("Encoding", 'encoding), msg, DO_LOG);	:nextInputLen('GetClientMessageType, STATE_LEN.GetClientMessageType);end,/*int*/ preferredEncoding: func(array supported, array encodings) // ADD_SERVERbegin	local int encoding;	foreach encoding in encodings	// viewer prefs	do  if SetContains(supported, encoding)		then return encoding;	return supported[0];	// might be nilend,SendUpdateRect: func(/*frame*/ bnds)	// ADD_SERVERif sock and _inStatethen begin	if _outState 	// output busy? it generally shouldn't be since vc sends updates only after DONE_REFRESH	then begin		//things a lot simpler if it's done. so wait a littleif DEBUG then Print(['SendUpdateRect, "WARNING", _outState]);		return AddDelayedSend(self, 'SendUpdateRect, [bnds], 100);		end;  	// already clipped, non-empty	local int x := bnds.left, y := bnds.top, w := bnds.right - x, h := bnds.bottom - y;//if DEBUG then Print(['SendUpdateRect, x,y,w,h]);	// make it easier. adjust x&w to even boundaries. assume bpp=4	if Band(x,0x1)=1	then begin		x := x-1;		w := w+1;		end;		if Band(w,0x1)=1	then w := w+1;	updateArea := Area:new(x, y, w, h, w, h);	// use viewer preferences -- if supported by newtVNC	local int encoding := updateArea.encoding := EncodingRaw;		//:preferredEncoding([EncodingRaw, EncodingHextile, /*if v.options.encoding = EncodingZlib then EncodingZlib*/], v.encodings);	updateNRects := 1;	local int fillEncoding := updateArea.fillEncoding :=		if v.options.encoding <> EncodingRaw then :preferredEncoding([nil, EncodingRRE, EncodingCoRRE], v.encodings);	local /*sym*/ next;	/*if encoding = EncodingHextile	then begin		next := 'SendHextileRect;		updateArea:setNextSize(16,16);		updateNRects := updateArea:rows();	// entire row of hextiles at a time (otherwise too slow)		if fillEncoding and updateNRects > 2		then updateNRects := updateNRects+1		else fillEncoding := nil;		end	else*/ begin // Raw (or Zlib?)		next := 'SendBitmapRect;		local int ht := h;		if (w*h > VBO_LEN)	// Raw or Zlib [big]		then begin			updateArea:setNextSize(nil, ht := VBO_LEN div w);			updateNRects := updateArea:totalRects();	// send as separate rects			if fillEncoding then updateNRects := updateNRects+1;			end		else fillEncoding := nil;	// no prog if single bm		//tmpBitmap := MakeBitmap(w, ht, {depth: _BPP});	// can't be reused, e.g., modeOr problems in datePicker		end;	local int offset := 4; 	local /*byte[]*/ data := :getOutputBuf(offset + (if fillEncoding then 17 else 0));	StuffByte(data, 0, FramebufferUpdate);	//  & pad	StuffWord(data, 2, updateNRects);	if fillEncoding	then begin // clear area when longer refresh, e.g., multiple bitmap slices		:StuffUpdateRequest(data, offset, bnds, fillEncoding);		//+5. RRE or CoRRE		StuffLong(data, offset+12, 0);	// no subrects		StuffByte(data, offset+16, kInvalidRectColor);		//offset := offset+17;		end;	//if encoding=EncodingHextile then :StuffUpdateRequest(data, offset, x, y, w, h, encoding);if DEBUG then Print(['SendUpdateRect, kEncodingNames[encoding], x,y,w,h]);if TIMING then bytesW := 0;	:nextOutput(next, data, _outLen);	//data follows incrementally via SendBitmapRect (or other encoding, e.g., SendHextileRect?)end,StuffUpdateRequest: func(/*byte[]*/ data, int offset, /*frame*/ bnds, int encoding)begin	local int x, y;	StuffWord(data, offset,    x := bnds.left);	StuffWord(data, offset+2,  y := bnds.top);	StuffWord(data, offset+4,  bnds.right - x);	StuffWord(data, offset+6,  bnds.bottom - y);	if encoding	then StuffLong(data, offset+8,  encoding);end,//tmpBitmap: nil,SendUpdateRectDone: func()		// ADD_SERVERbegin//if DEBUG then Print('SendUpdateRectDone);	// this flushes in case anything arrived during refresh. and resets _outState	//tmpBitmap := nil;	:nextOutput(nil,nil,0);	vc:Refresh(DONE_REFRESH,nil,true); // this allows updates to resumes	//input spec never stopped runningend,SendBitmapRect: func()		// ADD_SERVERbegin	local int w := updateArea.width, h := updateArea.height; //x := updateArea.left, y := updateArea.topif DEBUG then Print(['SendBitmapRect, updateArea]);	local int encoding := updateArea.encoding;	local int offset := 12 /*if encoding = EncodingRaw then 12 else 0*/, len := (w*h) + offset;	_outState := nil;	// avoid realloc buf	local /*byte[]*/ data := :getOutputBuf(len);	local int color := vc:bitmapToRaw(data, offset, updateArea); //tmpBitmap, 	if color and updateArea.fillEncoding		// area all same color (and viewer can handle RRE or CoRRE)	then begin		encoding := updateArea.fillEncoding;	// for :StuffUpdateRequest below		StuffLong(data, offset,   0);			// no subrects		StuffByte(data, offset+4, color);		len := offset+5;		end;/*	if encoding = EncodingZlib	then begin	// (inLevel) or (inLevel, inMethod, inWindowBits, inMemLevel, inStrategy)		local zlibFlater := :getZlibFlater(0, Deflater, [nil,nil,nil,v.zlibMemory,nil]);		if zlibFlater		then begin			zlibFlater:setInput(data, 0, _outLen);			offset := 16;			local zdata := byte:new(offset + (_outLen div 2)); // assume at least 2x compression			if zlibFlater:flate(zdata, offset, Length(zdata))			then begin				len := zlibFlater:length();	// incl. 16 offset				StuffLong(data := zdata, offset-4, len-offset); // zlib compressed len				end			else return NIL;			end		else return NIL;		// Deflate already reported init error		end;*/	// add update header	:StuffUpdateRequest(data, 0, updateArea, encoding);	:nextOutput(if updateArea:next() then 'SendBitmapRect else 'SendUpdateRectDone, data, len);	// since _outState=nilend,/*SendBell: func()	// ADD_SERVERbegin	local data := :getOutputBuf(STATE_LEN.SendBell);	StuffByte(data, 0, Bell);	:nextOutput(nil, data, _outLen);end,*/// VIEWER// GetClientMessageType:			// *** ADD_SERVERGetServerMessageType: func(/*byte[]*/ data)	// MAIN DISPATCH LOOP FOR VIEWERbegin	local array states := if ADD_SERVER and _inState = 'GetClientMessageType then SERVER_STATES else VIEWER_STATES;	local int msgType := min(ExtractByte(data,0), Length(states)-1);//if DEBUG then Print([_inState, (if _inState = 'GetClientMessageType then kServerMessageNames else kViewerMessageNames)[msgType]]);	:nextInputLen(states[msgType], nil);end,GetBell: func(/*byte[]*/ data)begin//if DEBUG then Print("msgType: Bell");	PlaySound(ROM_simpleBeep); // ??ROM_plinkBeep	//:nextInputLen('GetServerMessageType, STATE_LEN.GetServerMessageType)	// same state&lenend,//GetClientCutLen:			// *** ADD_SERVERGetServerCutLen: func(/*byte[]*/ data)begin	:nextInputLen(		if ADD_SERVER and _inState='GetClientCutLen then 'GetClientCutText else 'GetServerCutText,		ExtractLong(data,3));end,//GetClientCutText: func(/*byte*/ data)	// *** ADD_SERVERGetServerCutText: func(/*byte[]*/ data)begin	v.clipboard:?setCutText(:ExtractString(data,0,_inLen));	:nextInputLen(		if ADD_SERVER and _inState = 'GetClientCutText then 'GetClientMessageType else 'GetServerMessageType,		nil);end,GetUpdateRectsNum: func(/*byte[]*/ data)begin	if TIMING then bytesR := 0;	vc:setGauge(0);	progRect := updateNRects := ExtractWord(data,1); //readFramebufferUpdate;//if DEBUG then Print(_inState && "rects#" & updateNRects);	if (updateNRects = 0)		// shouldn't happen?		then :GetUpdateRectsNext();		else :nextInputLen('GetUpdateRects, STATE_LEN.GetUpdateRects);end,GetUpdateRects: func(/*byte[]*/ data) // called only by GetUpdateRectsNext or GetUpdateRectsNumbegin	updateArea := Area:new(		ExtractWord(data, 0),		ExtractWord(data, 2),		ExtractWord(data, 4),		ExtractWord(data, 6),		nil,nil);	if (updateArea.right > framebufferWidth) or (updateArea.bottom > framebufferHeight)	then return :error(LocObj("Update rectangle too large", 'largeRect),		updateArea:toString(), FATAL_ERROR);    local int updateRectEncoding := /*updateArea.encoding :=*/ ExtractLong(data, 8);	local /*string*/ ename := LocObj("Encoding", 'encoding) & $: &&		(if updateRectEncoding < 0 or updateRectEncoding >= Length(kEncodingNames)			then updateRectEncoding			else kEncodingNames[updateRectEncoding]);	v:status(ename && LocObj("rect", 'rect), updateNRects, NO_LOG);//if DEBUG then Print([ename, updateArea:toString()]);   	local int viewOriginY := vc.viewOriginY;	if (updateRectEncoding = EncodingHextile) //or (updateRectEncoding = EncodingZlibHex)	then begin		progHt := updateArea.bottom - viewOriginY;		updateArea:setNextSize(16, 16);		:nextInputLen('GetHexSubEncoding, STATE_LEN.GetHexSubEncoding);		end	else if (updateRectEncoding = EncodingRaw)	then begin		progHt := updateArea.bottom - viewOriginY;		if (updateArea:area() > VBO_LEN)		then updateArea:setNextSize(nil,16);		:nextInputLen('GetRawRectN, updateArea:area());		end	else if (updateRectEncoding = EncodingCoRRE)	then begin		local int diff := progRect-updateNRects;		if diff > 0 and Band(diff,0x3)=0	// every ~4		then vc:setGauge(diff / progRect);		:nextInputLen('GetSubRectsCoRRENum, STATE_LEN.GetSubRectsCoRRENum);		end	else if (updateRectEncoding = EncodingRRE)	then :nextInputLen('GetSubRectsRRENum, STATE_LEN.GetSubRectsRRENum);	else if (updateRectEncoding = EncodingCopyRect)	then :nextInputLen('GetCopyRect, STATE_LEN.GetCopyRect)	else if (updateRectEncoding = EncodingZlib)	then begin		if (updateArea:area() > VBO_LEN)		then updateArea:setNextSize(nil, 18);		progHt := vc.viewHeight;		:nextInputLen('GetZlibNum, STATE_LEN.GetZlibNum);		end/*	else if (updateRectEncoding = EncodingTight)	then begin		progHt := vc.viewHeight;		:nextInputLen('GetTightRectControl, STATE_LEN.GetTightRectControl);		end*/	else	 // default		:error(LocObj("Unknown rect encoding", 'rectEncoding), updateRectEncoding, FATAL_ERROR);end,GetUpdateRectsNext: func()begin	if ((updateNRects := updateNRects-1) <= 0)	then begin		v:status("", nil, NO_LOG);		vc:setGauge(1);							// update finished		Perform(vc, 'Refresh, refreshArgs); 	// setup next incremental update (now or later)		refreshArgs := _refreshArgs;			// reset (CopyRect might have changed)		:nextInputLen('GetServerMessageType, STATE_LEN.GetServerMessageType);		end	else :nextInputLen('GetUpdateRects, STATE_LEN.GetUpdateRects);end,GetZlibNum: func(/*byte[]*/ data)	:nextInputLen('GetZlibBytes, ExtractLong(data, 0)),GetZlibBytes: func(/*byte[]*/ data)begin	if (zlibFlater or zlibFlater := Inflater:new(self,nil)) and	//:getZlibFlater(0, Inflater, nil)		:drawZlibRect(zlibFlater, data, _inLen)	then begin		local fval := (updateArea.top - vc.viewOriginY) / progHt;		if fval > 0 and fval < 1		then vc:setGauge(fval);		:GetUpdateRectsNext();		end;	//else return NIL;	// Inflate(in drawZlibRect) already reported errorend,zlibFlater: 		nil,		// used in GetZlibBytes, close/*byte[]*/ tempData: nil,		// used by drawZlibRect, GetTightFilter3getTempBuf: func(int size)begin	if tempData	then if size <= Length(tempData)		then tempData		else SetLength(tempData, size)	else tempData := byte:new(size);end,Inflater: {	// more compatible with Java API and hides more zlib details	_proto: UR(kZLibSymbol, 'ProtoInflateStream),	obj: 		nil,	zstreamf: 	{},	// created by init	// a few params so code can be shared with Deflater	initMsg: 	'InflateInit,	initLen:	0,				// length of args for initMsg	initMsg2:	'InflateInit2,	initLen2:	1,				// length of args for initMsg2	flateMsg:	'Inflate,	endMsg:		'InflateEnd,	//resetMsg:	'InflateReset,		new: func(obj, array args)	// [-15] for no zlib header (e.g., .zip)		begin			local inf :=				{_proto: self,				obj: obj,		// for status, error				closed: nil,				};			local int argLen := if args then Length(args) else 0;			//or could use GetFunctionArgCount			local /*symbol*/ msg := if argLen=initLen then initMsg else if argLen=initLen2 then initMsg2;			local int err := if msg then Perform(inf, msg, args) else "#args:" & argLen;			if err			then inf:error(msg, err, FATAL_ERROR)			else inf;		end,	error: func(/*symbol*/ msg, earg, /*boolean*/ fatal)		obj:?error(msg && zstreamf.msg, earg, fatal),	close: func()		begin			local err;			if not closed			then try begin					closed := true;					err := Perform(self, endMsg, nil);					end				onexception |evt.ex|				do err := currentException();			if err			then :error(endMsg, err, IGNORE_ERROR);			nil;		end,	setInput: func(/*byte[]*/ data, int offset, int len)		begin			zstreamf.bin_in 	:= data;			zstreamf.next_in 	:= offset;			zstreamf.avail_in 	:= len;		end,	flate: func(/*byte[]*/ data, int offset, int len)		begin			zstreamf.bin_out 	:= data;			zstreamf.next_out 	:= offset;			zstreamf.avail_out 	:= len;			local int err := Perform(self, flateMsg, ['sync]);	// 'finish ??? does Perform(inherited, work?)			if err and (err <> Z_STREAM_END or zstreamf.avail_out <> 0)			then :error(flateMsg, err, FATAL_ERROR);			else true;		end,},  // bitmap is compressed/*boolean*/ drawZlibRect: func(/*Inflater*/ zlibFlater, /*byte[]*/ data, int len)begin//if DEBUG then Print(['drawZlibRect, 'data, data, len, updateArea:area(), updateArea]);	zlibFlater:setInput(data, 0, len);			local /*byte[]*/ rowData := :getTempBuf(updateArea:area());	repeat begin		len := updateArea:area();//if DEBUG then Print(['drawZlibRect, 'rowData, rowData, len, updateArea]);		if zlibFlater:flate(rowData, 0, len)		then vc:drawRawRect(rowData, updateArea)		else return NIL;	// Inflate already reported error		end	until not updateArea:next();	//zlibFlater:reset();	TRUE;end,// else nil = no inflater// for Tight, see rfbProto_Tight.txt (it works, but looks slower than Zlib)GetRawRectN: func(/*byte[]*/ data)begin//if DEBUG then Print([_inState, updateArea]);	vc:drawRawRect(data, updateArea);	local int y := updateArea:next();	if y	then begin		if y > 0 and y < progHt	// should always be true, but just in case...		then vc:setGauge(y / progHt);		:nextInputLen(_inState, updateArea:area());		end	else :GetUpdateRectsNext();end,RectEqual: kRectEqual,GetCopyRect: func(/*byte[]*/ data)begin	local int sx := ExtractWord(data,0), sy := ExtractWord(data,2);	local int dx := updateArea.left,  dy := updateArea.top;	local int w  := updateArea.width, h  := updateArea.height;	local /*frame*/ vbnds := vc.remoteBounds, sbnds := RelBounds(sx, sy, w, h);	local /*frame*/ dbnds := updateArea, dibnds;	if not :RectEqual(dibnds := SectRect(vbnds,dbnds), kRect0)	then begin	// dest is at least partially on screen		refreshArgs := Clone(refreshArgs);		refreshArgs[1] := NO_DELAY; // start next update asap (since there might be holes)			if :RectEqual(sbnds, SectRect(vbnds,sbnds))		then begin			if not :RectEqual(dbnds, dibnds)			then begin // dest not entirely on screen. adjust bounds				local int left := dibnds.left, top := dibnds.top;				local int dim  := dibnds.right - left;				if dx < left				then begin // moved left off screen					dx := left;					sx := sx + w - dim;					end;				w := dim;				dim := dibnds.bottom - top;				if dy < top				then begin // moved up off screen					dy := top;					sy := sy + h - dim;					end;				h := dim;if DEBUG then Print([_inState, "adjust (clip src,dst)", sx, sy, dx, dy, w, h]);				dbnds := RelBounds(dx, dy, w, h);				end			else if DEBUG then Print([_inState, "normal", dx, dy, w, h]);			vc:copyRect(sx, sy, dbnds);			end				else begin // source not entirely on screen. so, do a full refresh on destination rectangle			// this assumes only one copyRect per update ???if DEBUG then Print([_inState, "full refresh (src partly off)", sx, sy, dbnds]);			refreshArgs[0] := FULL_REFRESH;			refreshArgs[2] := dbnds;			// no copy			end;		end	else if DEBUG then Print([_inState, "no copy (dest off screen)", dbnds]);	:GetUpdateRectsNext();end,//GetSubRectsRRENum:GetSubRectsCoRRENum: func(/*byte[]*/ data)begin	updateArea.color := ExtractByte(data,4);	vc:fillRectA(updateArea);	nSubRects := ExtractLong(data,0);	if _inState = 'GetSubRectsRRENum	then progRect := nSubRects; // use updateNRects for CoRRE//if DEBUG then Print([_inState, "subrects#", nSubRects, $@, updateArea:toString()]);if PROFILE then vc:testFreq('nSubRects, nSubRects);	if (nSubRects = 0) // unlikely?	then return :GetUpdateRectsNext();	local /*symbol*/ next := if (_inState = 'GetSubRectsCoRRENum) then 'GetSubRectsCoRREN else 'GetSubRectsRREN;	local int itemSize := STATE_LEN.(next);	// pre-a1 = 1 rect at a time; a2 = all rects; a3 = intermediate # to avoid heap/VBO problems and show progress	:nextInputLen(next, itemSize*min(nSubRects, VBO_LEN div itemSize));end,fillSubrects: func(/*byte[]*/ data, int inc, int nrects, /*boolean*/ getColor, /*func*/ fn)begin // shared by GetHexSubEncodingSubrectN, ...FGN; GetSubRectsRREN, ...CoRREN	local /*frame*/ vbnds := vc.remoteBounds;	local x := vbnds.left, y := vbnds.top;	local int left := updateArea.left, top := updateArea.top, w := updateArea.width, h := updateArea.height;	if left < x	then begin		w := w - (x - left);		left := x;		end;	if top < y	then begin		h := h - (y - top);		top := y;		end;	if w <= 0 or h <= 0	then return if DEBUG then Print([_inState, "skipping rects#", nrects, $@, updateArea:toString()]);	local int hstate := 0;	// for Hextile: x=0,y=1,w=2,h=3	if inc = 0	then fn := func(/*byte[]*/ d, int off)	// get 1/2 byte for Hextile		begin // define here to get closure access to hstate and inc			local int val := ExtractByte(d, off);			val := if (inc := Band(hstate,0x1)) = 1		// inc =1 y,h; =0 x,w				then Band(val, 0xF);				else val div 16;			if hstate >= 2	// w,h			then val := val+1;			hstate := if hstate >= 3 then 0 else hstate+1;			val;		end;	local int i, color, offset := 0;	for i:=1 to nrects	do begin		if getColor		then begin			color := ExtractByte(data, offset);			offset := offset+1;			end;		// else color=nil in :setColor means keep using current color		x := left + call fn with (data, offset);		offset := offset+inc;		y := top + call fn with (data, offset);		offset := offset+inc;		w := call fn with (data, offset);		offset := offset+inc;		h := call fn with (data, offset);		offset := offset+inc;		vc:fillRect(color, x, y, w, h); // clips w,h if nec		end;end,//GetSubRectsRREN:  // *** share with GetSubRectsCoRRENGetSubRectsCoRREN: func(/*byte[]*/ data)begin	local /*boolean*/ short := (_inState = 'GetSubRectsCoRREN);	local int itemSize := STATE_LEN.(_inState);	local int trects := _inLen div itemSize;	:fillSubrects(data, if short then 1 else 2, trects, true, GetGlobalFn(if short then 'ExtractByte else 'ExtractWord));	if (nSubRects := nSubRects - trects) <= 0	then return :GetUpdateRectsNext();	vc:setGauge((progRect-nSubRects) / progRect);	:nextInputLen(_inState, min(_inLen, nSubRects*itemSize));end,//GetHexSubEncodingSubrectFGN:  // *** share with GetHexSubEncodingSubrectNGetHexSubEncodingSubrectN: func(/*byte[]*/ data)begin	:fillSubrects(data, 0, nSubRects, _inState = 'GetHexSubEncodingSubrectFGN, nil);	:GetHexSubEncodingNext();end,GetHexSubEncoding: func(/*byte[]*/ data) // called only by GetHexSubEncodingNext or GetUpdateRectsbegin	local int len := 0, subencoding := updateArea.encoding := ExtractByte(data,0);	if (Band(subencoding, HextileRaw) <> 0)	then return :nextInputLen('GetHexSubEncodingRaw, updateArea:area());/*	if (Band(subencoding, HextileZlibRaw) <> 0)	then return :nextInputLen('GetHexSubEncodingZlibRawNum, STATE_LEN.GetHexSubEncodingZlibRawNum);	if (Band(subencoding, HextileZlibHex) <> 0)	then return :nextInputLen('GetHexSubEncodingZlibHexNum, STATE_LEN.GetHexSubEncodingZlibHexNum);*/	if (Band(subencoding, HextileBackgroundSpecified) <> 0)	then len := len+1;    if (Band(subencoding, HextileForegroundSpecified) <> 0)	then len := len+1;	if (Band(subencoding, HextileAnySubrects) <> 0)	then len := len+1;	if (len = 0)	then begin // just fill in background rect		vc:fillRectA(updateArea);		:GetHexSubEncodingNext();		end	else :nextInputLen('GetHexSubEncoding3, len);end,GetHexSubEncoding3: func(/*byte[]*/ data)begin	// basically repeat latter logic in GetHexSubEncoding now that up to 3 bytes of data is here	local int offset := 0, subencoding := updateArea.encoding;	if (Band(subencoding, HextileBackgroundSpecified) <> 0)	then begin		updateArea.color := ExtractByte(data, offset);		offset := offset+1;		end;	vc:fillRectA(updateArea);	if (Band(subencoding, HextileForegroundSpecified) <> 0)	then begin		updateArea.fcolor := ExtractByte(data, offset);		offset := offset+1;		end;	if (Band(subencoding, HextileAnySubrects) = 0)	then return :GetHexSubEncodingNext();	nSubRects := ExtractByte(data, offset);if PROFILE then vc:testFreq('nSubRects, nSubRects);	local /*symbol*/ next := 'GetHexSubEncodingSubrectN;	if (Band(subencoding, HextileSubrectsColoured) <> 0)	then next := 'GetHexSubEncodingSubrectFGN	else vc:setColor(updateArea.fcolor);	:nextInputLen(next, nSubRects * STATE_LEN.(next));end,GetHexSubEncodingNext: func()begin	local int y := updateArea:next();	if y	then begin		if y > 0 and y < progHt and Band(y,0x3)=0	// just every ~4 ??		then vc:setGauge(y / progHt);		// only at beginning of a row. ?? might go backwards		:nextInputLen('GetHexSubEncoding, STATE_LEN.GetHexSubEncoding);		end	else :GetUpdateRectsNext();end,GetHexSubEncodingRaw: func(/*byte[]*/ data)begin	vc:drawRawRect(data, updateArea);	:GetHexSubEncodingNext();end,// =====		encryptChallenge: func(/*byte[]*/ challenge, /*string*/ pw)begin    local int pwlen := StrLen(pw), i;    local /*byte[]*/ key := :getOutputBuf(CHALLENGE_LEN2);    for i:=0 to CHALLENGE_LEN2-1    do StuffChar(key, i, if (i < pwlen) then pw[i] else 0);//if DEBUG then call kPrintBytes with (challenge, 0,nil, "challenge(orig)");//if DEBUG then call kPrintBytes with (key, 0,nil, "key");    local /*DesCipher*/ des := DesCipher:new(key);    des:encrypt(challenge,0,challenge,0);    des:encrypt(challenge,CHALLENGE_LEN2,challenge,CHALLENGE_LEN2);//if DEBUG then Print("auth: writing challenge");//if DEBUG then call kPrintBytes with (challenge, 0,nil, "challenge(des)");	challenge;end,// A buffer for putting pointer and keyboard events before being sent.  This// is to ensure that multiple RFB events generated from a single Java Event// will all be sent in a single network packet.  The maximum possible// length is 4 modifier down events, a single key event followed by 4// modifier up events i.e. 9 key events or 72 bytes./*byte[]*/ eventBuf: nil, // reused for temp output by non-event methods too/*int*/ eventBufLen: nil,///*int*/ pointerMask: 0,// Write a pointer event message.  We may need to send modifier key events// around it to set the correct modifier state.  Also buttons 2 and 3 are// represented as having ALT and META modifiers respectively. ???/*int*/ writeButtonEvent: func(/*byte*/ data, int offset, int but, int x, int y)begin	StuffByte(data, offset,   PointerEvent);	StuffByte(data, offset+1, but);	StuffWord(data, offset+2, x);	StuffWord(data, offset+4, y);	offset+6;end,/*boolean*/ writePointerEvent: func(int modifiers, int but1, int x1, int y1, int but2, int x2, int y2)if inNormalProtocolthen begin // assume no kbd modifiersif PROFILE then vc:testFreq('writePointerEvent2, 1);	// but1, but2 are pointerMask(s)    local /*byte[]*/ data := :getOutputBuf(		(if modifiers=0 then 0 else 64) + (if but2=kButOff then 12 else 6));    eventBufLen := 0;    if (modifiers <> kNoModifiers)    then eventBufLen := :writeModifierKeyEvents(data, eventBufLen, modifiers);	eventBufLen := :writeButtonEvent(data, eventBufLen, but1, x1, y1);	// down (or up for move)	if (but2 = kButOff)	// immediately send 'up' event ?	then eventBufLen := :writeButtonEvent(data, eventBufLen, but2, x2, y2);    if (modifiers <> kNoModifiers)	// if on, release    then eventBufLen := :writeModifierKeyEvents(data, eventBufLen, 0);    :nextOutput(nil, data, eventBufLen);end,// Write a key event message.  We may need to send modifier key events// around it to set the correct modifier state.  Also we need to translate// from the Java key values to the X keysym values used by the RFB protocol./* Newton key flags:0 to 7	The keycode.8 to 23	The 16-bit character that would be inserted if none of the modifier keys were pressed.24	Indicates whether the key was delivered from an on-screen keyboard. (kIsSoftKeyboard)25	Indicates that the Command key was down. (kCommandModifier)26	Indicates that the Shift key was down. (kShiftModifier)27	Indicates that the Caps Lock key was down. (kCapsLockModifier)28	Indicates that the Option key was down. (kOptionsModifier)29	Indicates that the Control key was down. (kControlModifier)*/// used by statusView.keydown/up; send-ctrl-Alt-Del; gesture(BS)/*boolean*/ writeKeyEvent: func(int updown, int key, int modifiers)if inNormalProtocolthen beginif PROFILE then vc:testFreq('writeKeyEvent, 1);	// A 'normal' key press.  Ordinary ASCII & Latin-1 characters go straight	// through.  For CTRL-<letter>, CTRL is sent separately so just send	// <letter>.  Backspace, tab, return, escape and delete have special	// keysyms.  Anything else we ignore.	local int i;	if i := SetContains(ARROW_KEYS_NWT, key)	then key := ARROW_KEYS_VNC[i]	else if i := SetContains(F_KEYS_NWT, key)	then key := F_KEYS_VNC+i	else if (key < 32)	then begin		if (Band(modifiers, kControlModifier) <> 0)		then begin	  		key := key + 96;	  		if (key = 127) // CTRL-_			then key := 95;			end	    else if i := SetContains(SPEC_KEYS_NWT, key)	    then key := SPEC_KEYS_VNC[i];		end;/* // mapped in 'ARROW_KEYS'	else if (key < 256) then		// For Latin-1, Unicode and X keysyms should be the same...		if (key = chDEL) // except delete		then key := 0xffff;*/    eventBuf := :getOutputBuf(112); 	// <= 32*3 + 2*8. this will realloc if necessary    eventBufLen := :writeModifierKeyEvents(eventBuf, 0, modifiers);    eventBufLen := :writeKeyEventBytes	  (eventBuf, eventBufLen, key, updown); // KEY_PRESS    // also write out 'up'    eventBufLen := :writeModifierKeyEvents(eventBuf, eventBufLen, modifiers);    eventBufLen := :writeKeyEventBytes	  (eventBuf, eventBufLen, key, updown := KEY_RELEASE);    // Always release all modifiers after an 'up' Event    //if (updown = KEY_RELEASE) then     eventBufLen := :writeModifierKeyEvents(eventBuf, eventBufLen, 0);    :nextOutput(nil, eventBuf, eventBufLen);end,// Add a raw key event with the given X keysym to eventBuf./*int*/ writeKeyEventBytes: func(/*byte[]*/ data, int offset, int keysym, int updown)begin    StuffByte(data, offset,   KbdEvent);    StuffByte(data, offset+1, updown);    //StuffWord(data, offset+2, 0);	//padding    StuffLong(data, offset+4, keysym);    offset+8;end,// Write key events to set the correct modifier state./*int*/ oldModifiers: 0,/*int*/ writeModifierKeyEvents: func(/*byte[]*/ data, int offset, int newModifiers)begin    local int i, mask, nmask; // options=meta, command=alt ??    foreach i,mask in MODIFIERS_NWT    do  if (nmask := Band(newModifiers, mask)) <> Band(oldModifiers, mask)		then offset := :writeKeyEventBytes(data, offset, MODIFIERS_VNC[i], if nmask <> 0 then KEY_PRESS else KEY_RELEASE);    oldModifiers := newModifiers;    offset;end,// 8-bit chars/*string*/ ExtractString: func(/*byte[]*/ data, int offset, int len)begin	local int i;	local /*binary*/ s := MakeBinary((len*2)+2, 'string);	for i := 0 to len-1	do StuffByte(s, (i*2)+1, ExtractByte(data, offset+i));	s;end,});// *** share some methodsrfbProto.GetSubRectsRREN			:= rfbProto.GetSubRectsCoRREN;rfbProto.GetSubRectsRRENum 			:= rfbProto.GetSubRectsCoRRENum;rfbProto.GetHexSubEncodingSubrectFGN:= rfbProto.GetHexSubEncodingSubrectN;//rfbProto.GetTightNonMono			:= rfbProto.GetRawRect;if ADD_SERVERthen begin	rfbProto.GetClientVersion 		:= rfbProto.GetServerVersion;	rfbProto.GetClientCutText		:= rfbProto.GetServerCutText;	rfbProto.GetClientCutLen		:= rfbProto.GetServerCutLen;	rfbProto.GetClientMessageType	:= rfbProto.GetServerMessageType;	endelse begin	RemoveSlot(rfbProto, 'setSize);	RemoveSlot(rfbProto, 'setName);	end;if TIMINGthen begin	rfbProto.bytesR := 0;	rfbProto.bytesW := 0;	end;/*if not ADD_SERVERthen begin		call func(fr1, fr2, removeSlots)	begin		local slot;		foreach slot in removeSlots		do begin			RemoveSlot(fr1, slot);			RemoveSlot(fr2, slot);			end;	end with (STATE_LEN, rfbProto, '[SendUpdateRect,SendBitmapRect, SendBitmapRectNext		GetClientVersion, GetClientChallenge, GetClientInit,		GetClientMessageType, GetEncodingsLen, GetEncodings,		GetClientCutLen, GetClientCutText, GetUpdateRequest,		GetPointerEvent, GetKbdEvent]);	end;*/	// a little doublechecking (make sure states exist)call func(fr1, fr2)begin	local slot,val;	foreach slot,val in Clone(fr1)	do begin		if not fr2.(slot)		then Print("rfbProto missing: " & slot);		if val <= 0	// unused  (only for doc/checking)		then RemoveSlot(fr1, slot);		end;end with (STATE_LEN, rfbProto);// End of text file rfbProto.ns// Beginning of file authenticationVNC.lytauthenticationPanel :=    {viewBounds: {left: 0, top: -306, right: 280, bottom: -22},     viewJustify: 144,     viewSetupFormScript:       func()	// *** kShiftView       nil,     uiHide: -1,     _proto: @180 /* protoFloatNGo */    };title :=    {     title:       /*string*/       	LocObj("Connect", 'connect) && $/ && LocObj("Listen",  'listen),     viewBounds: {left: 0, top: 0, right: 168, bottom: 16},     _proto: @229 /* protoTitle */    };AddStepForm(authenticationPanel, title);generalDivider :=    {title: LocObj("General", 'general),     viewBounds: {left: 0, top: 18, right: 0, bottom: 34},     _proto: @172 /* protoDivider */    };AddStepForm(authenticationPanel, generalDivider);displayPort :=    {viewBounds: {left: 0, top: 34, right: 64, bottom: 90},     clusterValue: /*int:buttonValue*/ DISPLAY_RADIO,     viewSetupFormScript:       func()	// ***       begin       	clusterValue := options.(sym);       	inherited:?viewSetupFormScript();       end,     sym: 'dpRadio,     _proto: @203 /* protoRadioCluster */    };AddStepForm(authenticationPanel, displayPort);StepDeclare(authenticationPanel, displayPort, 'displayPort);displayRadio :=    {buttonValue: /*int*/ DISPLAY_RADIO,     viewBounds: {left: 8, top: 8, right: 56, bottom: 24},     text: /*string*/ LocObj("Display", 'display) & $:,     _proto: @202 /* protoRadioButton */    };AddStepForm(displayPort, displayRadio);portRadio :=    {buttonValue: /*int*/ PORT_RADIO,     viewBounds: {left: 8, top: 32, right: 56, bottom: 48},     text: /*string*/ LocObj("Port", 'port) & $:,     _proto: @202 /* protoRadioButton */    };AddStepForm(displayPort, portRadio);display :=    {viewBounds: {left: 85, top: 36, right: -3, bottom: 58},     viewJustify: 8388656,     viewSetupFormScript:       func()	// ***       begin       	text := SPrintObject(options.(sym));       	inherited:?viewSetupFormScript();       end,     sym: /*symbol*/ 'display,     _proto: @185 /* protoInputLine */    };AddStepForm(authenticationPanel, display);StepDeclare(authenticationPanel, display, 'display);port :=    {viewBounds: {left: 85, top: 60, right: -3, bottom: 82},     viewJustify: 8388656,     viewSetupFormScript:       func()	// ***       begin       	text := SPrintObject(options.(sym));       	inherited:?viewSetupFormScript();       end,     sym: /*symbol*/ 'port,     _proto: @185 /* protoInputLine */    };AddStepForm(authenticationPanel, port);StepDeclare(authenticationPanel, port, 'port);viewerServer :=    {viewBounds: {left: 0, top: 95, right: 24, bottom: 223},     clusterValue: /*int:buttonValue*/ VIEWER_RADIO,     viewSetupFormScript:       func()	// ***       begin       	clusterValue := options.(sym);       	inherited:?viewSetupFormScript();       end,     sym: 'vsRadio,     clusterChanged:       func()       SetValue(connectButton, 'text, if clusterValue = SERVER_RADIO then LocObj("Listen", 'listen) else LocObj("Connect", 'connect))     ,     _proto: @203 /* protoRadioCluster */    };AddStepForm(authenticationPanel, viewerServer);StepDeclare(authenticationPanel, viewerServer, 'viewerServer);viewerRadio :=    {buttonValue: /*int*/ VIEWER_RADIO,     viewBounds: {left: 8, top: 0, right: 26, bottom: 18},     _proto: @202 /* protoRadioButton */    };AddStepForm(viewerServer, viewerRadio);serverRadio :=    {buttonValue: /*int*/ SERVER_RADIO,     viewBounds: {left: 8, top: 86, right: 26, bottom: 104},     _proto: @202 /* protoRadioButton */    };AddStepForm(viewerServer, serverRadio);viewerDivider :=    {title: LocObj("Viewer", 'viewer),     viewBounds: {left: 26, top: 98, right: 0, bottom: 114},     _proto: @172 /* protoDivider */    };AddStepForm(authenticationPanel, viewerDivider);host :=    {viewBounds: {left: 10, top: 116, right: -3, bottom: 138},     alwaysCallPickActionScript: true,     label: /*string*/ LocObj("Host", 'host),     indent: /*int*/ 85,     viewJustify: 8388656,     labelCommands: /*string[]*/ [],     viewSetupFormScript:       func() // ***       begin       	local val := options.(sym);			// make this generic for host and serverName fields       	if IsString(val) and StrFilled(val)       	then text := Clone(val)       	else if IsArray(val) and Length(val) > 0       	then text := Clone((labelCommands := val)[0]);              	inherited:?viewSetupFormScript();       end,     labelActionScript:       /*boolean*/ func(int cmd)	// return true if selection completely handled, nil otherwise       begin       	viewerPassword:updateText(Clone(options.passwords[cmd]));       	NIL;       end,     getText:       func() entryLine.text	// ***       ,     sym: /*symbol*/ 'hosts,     _proto: @189 /* protoLabelInputLine */    };AddStepForm(authenticationPanel, host);StepDeclare(authenticationPanel, host, 'host);viewerPassword :=    {viewBounds: {left: 10, top: 146, right: -3, bottom: 170},     label: /*string*/ LocObj("Password", 'password),     viewJustify: 8388656,     indent: /*int*/ 85,     viewSetupDoneScript:       func()	// ***       begin       	SetKeyView(entryLine,0);	// ?? avoid GetCaretInfo().info.offset error in TextChanged. MP2100?              	local pw := options.(sym);	// make this generic for both password fields       	if (IsString(pw) and StrFilled(pw)) or       		(IsArray(pw) and Length(pw) > 0 and pw := pw[0])       	then AddDeferredSend(self, 'updateText, [Clone(pw)]);              	inherited:?viewSetupDoneScript();       end,     getText:       func() realText	// ***       ,     sym: 'passwords,     _proto: @552 /* protoBlindEntryLine */    };AddStepForm(authenticationPanel, viewerPassword);StepDeclare(authenticationPanel, viewerPassword, 'viewerPassword);serverDivider :=    {title: LocObj("Server", 'server),     viewBounds: {left: 26, top: 184, right: 0, bottom: 200},     _proto: @172 /* protoDivider */    };AddStepForm(authenticationPanel, serverDivider);serverName :=    {viewBounds: {left: 10, top: 202, right: -3, bottom: 224},     alwaysCallPickActionScript: true,     label: /*string*/ LocObj("Server Name", 'serverName),     indent: /*int*/ 85,     viewJustify: 8388656,     viewSetupFormScript:       func() // ***       begin       	local val := options.(sym);			// make this generic for host and serverName fields       	if IsString(val) and StrFilled(val)       	then text := Clone(val)       	else if IsArray(val) and Length(val) > 0       	then text := Clone((labelCommands := val)[0]);              	inherited:?viewSetupFormScript();       end,     getText:       func() entryLine.text	// ***       ,     sym: /*symbol*/ 'serverName,     _proto: @189 /* protoLabelInputLine */    };AddStepForm(authenticationPanel, serverName);StepDeclare(authenticationPanel, serverName, 'serverName);serverPassword :=    {viewBounds: {left: 10, top: 230, right: -3, bottom: 254},     label: /*string*/ LocObj("Password", 'password),     viewJustify: 8388656,     indent: /*int*/ 85,     viewSetupDoneScript:       func()	// ***       begin       	SetKeyView(entryLine,0);	// ?? avoid GetCaretInfo().info.offset error in TextChanged. MP2100?              	local pw := options.(sym);	// make this generic for both password fields       	if (IsString(pw) and StrFilled(pw)) or       		(IsArray(pw) and Length(pw) > 0 and pw := pw[0])       	then AddDeferredSend(self, 'updateText, [Clone(pw)]);              	inherited:?viewSetupDoneScript();       end,     getText:       func() realText		// ***       ,     sym: 'serverPassword,     _proto: @552 /* protoBlindEntryLine */    };AddStepForm(authenticationPanel, serverPassword);StepDeclare(authenticationPanel, serverPassword, 'serverPassword);prefsButton :=    {     buttonClickScript:       func() optionsFrame:open()	// ??? share w/ DoInfoPrefs?       ,     text: /*string*/ LocObj("Prefs", 'prefs),     viewBounds: {left: 5, top: -14, right: 50, bottom: -2},     viewJustify: 8388742,     _proto: @226 /* protoTextButton */    };AddStepForm(authenticationPanel, prefsButton);// After Script for prefsButtonthisView := prefsButton;thisView.buttonClickScript := kOptionsOpen;		// ***connectButton :=    {     buttonClickScript:       func()       begin       	local /*string*/ h, msg, pw;       	local int d, p, dpr := displayPort.clusterValue, vs := viewerServer.clusterValue;              	// this checks/saves/uses only d or p       	if dpr = DISPLAY_RADIO and not (d := StringToNumber(display.text))       	then msg := LocObj("Display", 'display)       	else if dpr = PORT_RADIO and not (p := StringToNumber(port.text))       	then msg := LocObj("Port", 'port)              	else if vs = VIEWER_RADIO       	then if StrLen(h := host:getText()) = 0       		then msg := LocObj("Host", 'host)       		else begin       			pw := viewerPassword:getText();       			local /*string[]*/ array hosts 	   := options.hosts;       			local /*string[]*/ array passwords := options.passwords;       			local int pos := LSearch(hosts, h, 0, '|str=|, nil);       			// move/add item to beginning.        			if pos and pos > 0       			then begin       				ArrayRemoveCount(hosts,pos,1);       				ArrayRemoveCount(passwords,pos,1);       				end;       			if pos <> 0       			then begin       				ArrayInsert(hosts,h,0);       				ArrayInsert(passwords,pw,0);       				end       			else passwords[0] := pw;              			if Length(hosts) > HOST_LENGTH       			then begin       				SetLength(hosts, 	 HOST_LENGTH);       				SetLength(passwords, HOST_LENGTH);       				end;              			options.hosts 		:= hosts;       			options.password	:= passwords;       			end              	else if ADD_SERVER       	then begin       		// h=nil       		options.serverName := serverName:getText();       		pw := options.serverPassword := serverPassword:getText();       		end;              	if msg       	then begin       		v:status(LocObj("missing", 'missing), msg, DO_LOG);       		:SysBeep();       		end              	else begin       		if d       		then begin       			options.display:= d := RIntToL(d);       			p := d + DEFAULT_PORT_INT;       			end       		else // if p then       			options.port 	:= p := RintToL(p);       		options.dpRadio		:= dpr;       		options.vsRadio		:= vs;       		EntryChangeXmit(options, nil);              		v:connect(h, p, pw);       		base:close();       		SetKeyView(paraView,0);       		end;       end,     text: /*string*/ connLabel,     viewBounds: {left: 0, top: -14, right: 60, bottom: -2},     viewJustify: 8388758,     viewSetupFormScript:       func()	// also set by viewerServer:clusterChanged()       begin       	text := if options.vsRadio = SERVER_RADIO then LocObj("Listen", 'listen) else LocObj("Connect", 'connect);       	inherited:?viewSetupFormScript();       end,     _proto: @226 /* protoTextButton */    };AddStepForm(authenticationPanel, connectButton);StepDeclare(authenticationPanel, connectButton, 'connectButton);logButton :=    {buttonClickScript: func() :clipboardOpen(),     text: /*string*/ LocObj("Log", 'log),     viewBounds: {left: -67, top: -14, right: -22, bottom: -2},     viewJustify: 8388774,     _proto: @226 /* protoTextButton */    };AddStepForm(authenticationPanel, logButton);// After Script for authenticationPanelthisView := authenticationPanel;begin	// *** share some methods (easier than defining user protos)	local array children := thisView.stepChildren;	local int dp := 2, display := 3, port := 4, vs := 5, h := 7, vpw := 8, sn := 10, spw := 11;	children[port].viewSetupFormScript 	:= children[display].viewSetupFormScript;	children[dp].viewSetupFormScript 	:=	children[vs].viewSetupFormScript;	children[sn].getText 				:= children[h].getText;	children[sn].viewSetupFormScript 	:= children[h].viewSetupFormScript;	children[spw].getText 				:= children[vpw].getText;	children[spw].viewSetupDoneScript 	:= children[vpw].viewSetupDoneScript;	thisView.viewSetupFormScript := kShiftView;	if ADD_SERVER	then thisView.viewDrawScript := kRefreshPatch.viewDrawScript;endconstant |layout_authenticationVNC.lyt| := authenticationPanel;// End of file authenticationVNC.lyt// Beginning of file optionsVNC.lytoptionsFrame :=    {viewBounds: {left: 0, top: -308, right: 240, bottom: -22},     tempOptions: /*frame*/ nil,     optionsChanged:       func()       begin       	if not nos21 and tempOptions.bpp       	then RemoveSlot(tempOptions, 'bpp); // avoid saving and possible resize              	if Length(tempOptions) = 0	// no changes?       	then return;              	local buttonBarArg := sameButtonBar;       	if nos21 and tempOptions.displaySize       	then if tempOptions.displaySize = kFullBarSize       		then buttonBarArg := noButtonBar       		else if options.displaySize = kFullBarsize       		then buttonBarArg := restoreButtonBar;              	call kFrameMunger with (options, tempOptions, 'add, nil);       	EntryChangeXmit(options, nil);                  if tempOptions.encoding or HasSlot(tempOptions, 'useCopyRect)           then v:setEncodings();                  if tempOptions.kbdMode           then begin       		v.kbd:?close();       		v.kbd := nil;       		end;              	if HasSlot(tempOptions, 'minUI)  // ?? could be tempOptions.minUI since 0-2 (not nil/true)       	then PlaySound(if options.minUI = kExpanded then ROM_draweropen else ROM_drawerclose);              	local /*boolean*/ screenChange := HasSlot(tempOptions, 'minUI) or buttonBarArg <> sameButtonBar;       	local /*boolean*/ bitmapChange := tempOptions.displaySize or tempOptions.bpp or (screenChange and options.displaySize >= kFullSize);       	if not bitmapChange and HasSlot(tempOptions, 'overview)       	then vc:setOverviewBitmap(options.overview, true); // otherwise, set during reorient/resize              	if screenChange       	then begin       		if bitmapChange       		then vc.icon := vc.screenBitmap := nil; // force realloc (otherwiswe, vc.vsf will realloc only for full)       		v:ReorientToScreen();					// basically same process as Rotate! (assume Prefs closed?)       		end       	else begin       		if HasSlot(tempOptions, 'noHWR)       		then begin // this done automatically above for screenChange       			SetValue(paraView, 'viewBounds, SetBounds(0,-16, 0, if options.noHWR then -vc:LocalBox().bottom else 0));       			paraView:SyncView();       			end;       		if bitmapChange       		then vc:setSize(rfb:?isOpen());       		end;       end       // assume rotate = nil       // rotate = true if called by a Rotate (protoOrientation) button       // but that has been disabled since if user tapped button but then did not select/do       // an actual rotation, screenBitmap (among other things) could be in an inconsistent state       ,     viewJustify: 144,     viewSetupFormScript:       func() nil	// *** kShiftView       ,     uiHide: -1,     _proto: @180 /* protoFloatNGo */    };optionsFrame_v229_0 :=    {title: /*string*/ LocObj("Prefs", 'prefs),     viewBounds: {left: 2, top: 0, right: 170, bottom: 16},     _proto: @229 /* protoTitle */    };AddStepForm(optionsFrame, optionsFrame_v229_0);encodingPicker :=    {     labelCommands:       /*string[]*/ [	// see encodingMap       	LocObj("Raw",		'raw),       	LocObj("RRE", 		'RRE),       	LocObj("CoRRE", 	'CoRRE),       	LocObj("Hextile", 	'Hextile),       	LocObj("Zlib", 		'zlib),              	//LocObj("ZlibHex", 	'zlibHex),       	//LocObj("Tight", 	'tight),       ],     text: /*string*/ LocObj("Encoding", 'encoding),     viewBounds: {left: 2, top: 19, right: -2, bottom: 33},     alwaysCallPickActionScript: true,     textSetup:       /*string*/ func()	// ***       labelCommands[curLabelCommand],     sym: /*symbol*/ 'encoding,     curLabelCommand: /*int*/ 0,     viewSetupFormScript:       func()       begin       	curLabelCommand := SetContains(encodingMap, options.(sym));       	if not zlib	// options.encoding already adjusted in v.vsf       	then labelCommands := SetLength(Clone(labelCommands), SetContains(encodingMap, EncodingZlib));       	inherited:viewSetupFormScript();       end,     labelActionScript:       func(int cmd)       tempOptions.(sym) := encodingMap[curLabelCommand := cmd],     encodingMap:       // these correspond to labelCommands order. also see vsf       /*int[]*/ [EncodingRaw, EncodingRRE, EncodingCoRRE, EncodingHextile, EncodingZlib, EncodingZlibHex]	//EncodingTight]       ,     indent: /*int*/ 120,     viewJustify: 8388656,     _proto: @190 /* protoLabelPicker */    };AddStepForm(optionsFrame, encodingPicker);copyRectPicker :=    {labelCommands: /*string[]*/ kYesNo,     text: /*string*/ LocObj("Use CopyRect", 'useCopyRect),     viewBounds: {left: 2, top: 40, right: -2, bottom: 54},     alwaysCallPickActionScript: true,     textSetup:       /*string*/ func()	// ***       labelCommands[curLabelCommand],     sym: /*symbol*/ 'useCopyRect,     curLabelCommand: /*int*/ 0,     viewSetupFormScript:       func()	// ***       begin       	curLabelCommand := if options.(sym) then boolean else 1-boolean;       	inherited:viewSetupFormScript();       end,     labelActionScript:       func(int cmd)	// ***       tempOptions.(sym) := (curLabelCommand := cmd) = boolean,     boolean: /*int:0-1*/ 0,     indent: /*int*/ 120,     viewJustify: 8388656,     _proto: @190 /* protoLabelPicker */    };AddStepForm(optionsFrame, copyRectPicker);rightClickPicker :=    {     labelCommands:       /*string[]*/ [       	LocObj("ctrl-Button 1 (Mac)",	'button1),       	LocObj("Button 2",				'button2),       	LocObj("Button 3 (Win)",		'button3),       	],     text: /*string*/ LocObj("Right Click", 'rightClickPref),     viewBounds: {left: 2, top: 61, right: -2, bottom: 75},     alwaysCallPickActionScript: true,     textSetup:       /*string*/ func()	// ***       labelCommands[curLabelCommand],     sym: /*symbol*/ 'rightClick,     curLabelCommand: /*int*/ 0,     viewSetupFormScript:       func()	// ***       begin       	curLabelCommand := options.(sym) div 2;	// 1->0, 2->1, 4->2       	inherited:viewSetupFormScript();       end,     labelActionScript:       func(int cmd)	// ***       tempOptions.(sym) := 1 << (curLabelCommand := cmd)	// 0->1, 1->2, 2->4       ,     indent: /*int*/ 120,     viewJustify: 8388656,     _proto: @190 /* protoLabelPicker */    };AddStepForm(optionsFrame, rightClickPicker);sharePicker :=    {labelCommands: /*string[]*/ kYesNo,     text: /*string*/ LocObj("Share Desktop", 'shareDesktop),     viewBounds: {left: 2, top: 82, right: -2, bottom: 96},     alwaysCallPickActionScript: true,     textSetup:       /*string*/ func()	// ***       labelCommands[curLabelCommand],     sym: /*symbol*/ 'shareDesktop,     curLabelCommand: /*int*/ 0,     viewSetupFormScript:       func()	// ***       begin       	curLabelCommand := if options.(sym) then boolean else 1-boolean;       	inherited:viewSetupFormScript();       end,     labelActionScript:       func(int cmd)	// ***       tempOptions.(sym) := (curLabelCommand := cmd) = boolean,     boolean: /*int:0-1*/ 0,     indent: /*int*/ 120,     viewJustify: 8388656,     _proto: @190 /* protoLabelPicker */    };AddStepForm(optionsFrame, sharePicker);refreshPicker :=    {labelCommands: /*string[]*/ ["1", "2", "3", "4", "5", "10"],     text: /*string*/ LocObj("Refresh(sec)", 'refreshSec),     viewBounds: {left: 2, top: 103, right: -2, bottom: 117},     alwaysCallPickActionScript: true,     textSetup:       /*string*/ func()       SPrintObject(options.(sym)),     sym: /*symbol*/ 'refresh,     curLabelCommand: /*int*/ 0,     viewSetupFormScript:       func()       begin       	curLabelCommand := LSearch(labelCommands, SPrintObject(options.(sym)), 0, '|str=|,nil);       	inherited:viewSetupFormScript();       end,     labelActionScript:       func(int cmd)       tempOptions.(sym) := RIntToL(StringToNumber(labelCommands[curLabelCommand := cmd]))     ,     indent: /*int*/ 120,     viewJustify: 8388656,     _proto: @190 /* protoLabelPicker */    };AddStepForm(optionsFrame, refreshPicker);sizePicker :=    {text: /*string*/ LocObj("Display Size", 'displaySize),     viewBounds: {left: 2, top: 124, right: -60, bottom: 138},     alwaysCallPickActionScript: true,     textSetup:       /*string*/ func()	// ***       labelCommands[curLabelCommand],     sym: /*symbol*/ 'displaySize,     curLabelCommand: /*int*/ 0,     viewSetupFormScript:       func()       begin       	curLabelCommand := options.(sym);       	local int i, len := kFullSize;	//Length(SCREEN_SIZE_X);       	labelCommands := Array(if nos21 then len+2 else len+1, nil);       	for i:=0 to len-1       	do labelCommands[i] := SCREEN_SIZE_X[i] & $x & SCREEN_SIZE_Y[i];       	labelCommands[kFullSize] := LocObj("full", 'full);       	if nos21       	then labelCommands[kFullBarSize] := LocObj("full+bar", 'fullBar);       	inherited:viewSetupFormScript();       end,     labelActionScript:       func(int cmd) // ***       tempOptions.(sym) := curLabelCommand := cmd,     indent: /*int*/ 120,     viewJustify: 8388656,     _proto: @190 /* protoLabelPicker */    };AddStepForm(optionsFrame, sizePicker);bppPicker :=    {text: /*string*/ LocObj("Gray Level", 'grayLevel),     viewBounds: {left: 2, top: 145, right: -2, bottom: 159},     alwaysCallPickActionScript: true,     textSetup:       /*string*/ func()	// ***       labelCommands[curLabelCommand],     sym: /*symbol*/ 'bpp,     curLabelCommand: /*int*/ 0,     viewSetupFormScript:       func()	// ***       begin // note: for nos21, bpp := 1 in vc.setupFormScript, checked in Apply       	curLabelCommand := options.(sym) div 2;	// 1->0, 2->1, 4->2       	inherited:viewSetupFormScript();       end,     labelActionScript:       func(int cmd)	// ***       tempOptions.(sym) := 1 << (curLabelCommand := cmd)	// 0->1, 1->2, 2->4       ,     indent: /*int*/ 120,     viewJustify: 8388656,     labelCommands:       /*string[]*/ [       	LocObj("b&w (1+ bpp)", 'bw),       	LocObj("4 gray (2 bpp)", 'gray4),       	LocObj("16 gray (4 bpp)", 'gray16),       	],     _proto: @190 /* protoLabelPicker */    };AddStepForm(optionsFrame, bppPicker);kbdPicker :=    {text: /*string*/ LocObj("Keyboard", 'keyboard),     viewBounds: {left: 2, top: 166, right: -2, bottom: 180},     alwaysCallPickActionScript: true,     textSetup:       /*string*/ func()	// ***       labelCommands[curLabelCommand],     sym: /*symbol*/ 'kbdMode,     curLabelCommand: /*int*/ 0,     viewSetupFormScript:       func() // ***       begin       	curLabelCommand := options.(sym);       	inherited:viewSetupFormScript();       end,     labelActionScript:       func(int cmd) // ***       tempOptions.(sym) := curLabelCommand := cmd,     indent: /*int*/ 120,     viewJustify: 8388656,     labelCommands:       /*string[]*/ [       	LocObj("Standard", 'standardKbd),       	$+ & LocObj("ctrl",'ctrl) & $, & LocObj("opt",'opt) & $, & LocObj("cmd",'cmd),       	$+ & LocObj("ctrl",'ctrl) & $, & LocObj("meta",'meta) & $, & LocObj("alt",'alt) & $, & LocObj("bs",'bs),       	],     _proto: @190 /* protoLabelPicker */    };AddStepForm(optionsFrame, kbdPicker);hwrPicker :=    {text: /*string*/ LocObj("Handwriting On", 'hwr),     viewBounds: {left: 2, top: 187, right: -2, bottom: 201},     alwaysCallPickActionScript: true,     textSetup:       /*string*/ func()	// ***       labelCommands[curLabelCommand],     sym: /*symbol*/ 'noHWR,     curLabelCommand: /*int*/ 0,     viewSetupFormScript:       func()	// ***       begin       	curLabelCommand := if options.(sym) then boolean else 1-boolean;       	inherited:viewSetupFormScript();       end,     labelActionScript:       func(int cmd)	// ***       tempOptions.(sym) := (curLabelCommand := cmd) = boolean,     indent: /*int*/ 120,     viewJustify: 8388656,     labelCommands: /*string[]*/ kYesNo,     boolean: /*int:0-1*/ 1,     _proto: @190 /* protoLabelPicker */    };AddStepForm(optionsFrame, hwrPicker);minuiPicker :=    {text: /*string*/ LocObj("Local UI", 'localUI),     viewBounds: {left: 2, top: 208, right: -2, bottom: 222},     alwaysCallPickActionScript: true,     textSetup:       /*string*/ func()	// ***       labelCommands[curLabelCommand],     sym: /*symbol*/ 'minUI,     curLabelCommand: /*int*/ 0,     viewSetupFormScript:       func()	// ***       begin       	curLabelCommand := options.(sym);       	inherited:viewSetupFormScript();       end,     labelActionScript:       func(int cmd) // ***       tempOptions.(sym) := curLabelCommand := cmd,     indent: /*int*/ 120,     viewJustify: 8388656,     labelCommands:       /*string[]*/ [ // NOTE: these match constants kExpanded, kCompactBot, kCompactTop       	LocObj("Expanded", 		'expanded),       	LocObj("Compact",		'compactBot),       	LocObj("Compact(top)", 	'compactTop),       	LocObj("Compact(float)",'compactFloat),       	],     _proto: @190 /* protoLabelPicker */    };AddStepForm(optionsFrame, minuiPicker);scrollPicker :=    {text: /*string*/ LocObj("Scroll Increment", 'scrollInc),     viewBounds: {left: 2, top: 230, right: -2, bottom: 244},     alwaysCallPickActionScript: true,     textSetup:       /*string*/ func()	// ***       labelCommands[curLabelCommand],     sym: /*symbol*/ 'scrollInc,     curLabelCommand: /*int*/ 0,     viewSetupFormScript:       func() // similar to refreshPicker       begin       	local val := options.(sym);	// int or sym       	curLabelCommand :=       		if val = 'full       		then Length(labelCommands)-1       		else LSearch(labelCommands, SPrintObject(val), 0, '|str=|,nil);       	inherited:viewSetupFormScript();       end,     labelActionScript:       func(int cmd)	// similar to refreshPicker       begin       	curLabelCommand := cmd;       	tempOptions.(sym) :=       		if cmd = Length(labelCommands)-1       		then 'full       		else RIntToL(StringToNumber(labelCommands[cmd]));       end,     indent: /*int*/ 120,     viewJustify: 8388656,     labelCommands: /*string[]*/ ["16", "64", LocObj("full",'full)],     _proto: @190 /* protoLabelPicker */    };AddStepForm(optionsFrame, scrollPicker);overviewPicker :=    {text: /*string*/ LocObj("Create Overview", 'createOverView),     viewBounds: {left: 2, top: 251, right: -2, bottom: 265},     alwaysCallPickActionScript: true,     textSetup:       /*string*/ func()	// ***       labelCommands[curLabelCommand],     sym: /*symbol*/ 'noHWR,     curLabelCommand: /*int*/ 0,     viewSetupFormScript:       func()	// ***       begin       	curLabelCommand := if options.(sym) then boolean else 1-boolean;       	inherited:viewSetupFormScript();       end,     labelActionScript:       func(int cmd)	// ***       tempOptions.(sym) := (curLabelCommand := cmd) = boolean,     indent: /*int*/ 120,     viewJustify: 8388656,     labelCommands: /*string[]*/ kYesNo,     boolean: /*int:0-1*/ 1,     _proto: @190 /* protoLabelPicker */    };AddStepForm(optionsFrame, overviewPicker);applyButton :=    {     buttonClickScript:       func()       begin       	base:close();       	AddDeferredSend(base, 'optionsChanged, nil);       end,     text: /*string*/ LocObj("Apply", 'apply),     viewBounds: {left: 0, top: -14, right: 60, bottom: -2},     viewJustify: 8388758,     _proto: @226 /* protoTextButton */    };AddStepForm(optionsFrame, applyButton);// After Script for optionsFramethisView := optionsFrame;begin	// each picker @ 14 + 7 spacing	// *** share some methods (easier than defining user protos)	local array children := thisView.stepChildren;	//title: 0, apply: 12	local int encoding := 1, copyrect := 2, rclick := 3, share := 4, refresh := 5;	local int size := 6, bpp := 7, kbd := 8, hwr := 9, minUI := 10, scroll := 11, overview := 12;	children[bpp].textSetup :=	// all except refresh		children[overview].textSetup :=		children[minUI].textSetup :=		children[scroll].textSetup :=		children[hwr].textSetup :=		children[kbd].textSetup :=		children[size].textSetup :=		children[share].textSetup :=		children[rclick].textSetup :=		children[copyrect].textSetup :=		children[encoding].textSetup;	// bpp, rclick map 0,1,2 <=> 1,2,4	children[rclick].labelActionScript :=		children[bpp].labelActionScript;	children[rclick].viewSetupFormScript :=		children[bpp].viewSetupFormScript;	// cmd = val	children[minUI].labelActionScript :=		children[size].labelActionScript :=		children[kbd].labelActionScript;	children[minUI].viewSetupFormScript :=		children[kbd].viewSetupFormScript;	// 'boolean'	children[share].labelActionScript :=		children[overview].labelActionScript :=		children[hwr].labelActionScript :=		children[copyrect].labelActionScript;	children[share].viewSetupFormScript :=		children[overview].viewSetupFormScript :=		children[hwr].viewSetupFormScript :=		children[copyrect].viewSetupFormScript;	thisView.viewSetupFormScript := kShiftView;	// kludge includes tempOptions init	if ADD_SERVER	then thisView.viewDrawScript := kRefreshPatch.viewDrawScript;endconstant |layout_optionsVNC.lyt| := optionsFrame;// End of file optionsVNC.lyt// Beginning of file logClipboardVNC.lytclipboardFrame :=    {viewBounds: {left: 20, top: 22, right: -20, bottom: -22},     selection: /*string*/ nil,     setCutText:       func(/*String*/ txt)       begin       if DEBUG then Print(['setCutText, txt]);           selection := txt;           if textArea           then SetValue(textArea, 'text, txt);           if nos21 and StrLen(txt) > 0           then SetClipboard({           	label: txt,           	types: '[[text]],           	data: [[{text: txt}]],           	bounds: kRect0});       end,     viewJustify: 240,     logClip: true,     logText: /*string*/ nil,     log:       func(/*string*/ txt)       begin       	txt := txt & unicodeCR;       	if logText       	then StrMunger(logText,0,0, txt, 0, nil); // insert at beginning       	else logText := txt;	// copy via & cr              	if textArea       	then SetValue(textArea, 'text, logText);       end,     clearLogText:       func()       begin       	logText := nil;       	:log("");       end,     viewSetupFormScript:       func()       begin       	viewBounds := if GetGlobalFn('InetGetIPAddress) and InetGetIPAddress('localAddress)       		then kRectNIE       		else _proto.viewBounds;       	inherited:?viewSetupFormScript();       end,     _proto: @180 /* protoFloatNGo */    };clipboardFrame_v229_0 :=    {title: /*string*/ nil,     viewBounds: {left: 0, top: 0, right: 128, bottom: 16},     viewSetupFormScript:       func()       begin       	title := if logClip then clipLabel else logLabel;       	inherited:?viewSetupFormScript();       end,     _proto: @229 /* protoTitle */    };AddStepForm(clipboardFrame, clipboardFrame_v229_0);// After Script for clipboardFrame_v229_0thisView := clipboardFrame_v229_0;begin	RemoveSlot(thisView, 'title);	RemoveSlot(thisView, 'viewSetupFormScript);endtextArea :=    {viewBounds: {left: 2, top: 20, right: -2, bottom: -22},     viewFlags: 31233,     viewFont: simpleFont12,     viewFormat: 12625,     viewLineSpacing: 14,     viewJustify: 240,     viewSetupFormScript:       func()       begin       	local /*string*/ txt := if logClip then Clone(selection) else logText; // clone to compare in Save button       	self.text := if txt then txt else "";              	//inherited:?viewSetupFormScript();       end,     viewClass: 81 /* clParagraphView */    };AddStepForm(clipboardFrame, textArea);StepDeclare(clipboardFrame, textArea, 'textArea);clearSaveButton :=    {     buttonClickScript:       func()       begin       	if logClip       	then begin       		local /*string*/ txt := textArea.text;       		if not selection or not StrEqual(selection, txt)       		then v.rfb:?setCutText(selection := txt);       		end       	else :clearLogText();       	base:close();       end,     text: /*string*/ nil,     viewBounds: {left: 0, top: -14, right: 80, bottom: -2},     viewJustify: 8388758,     viewSetupFormScript:       func()       begin       	text := if logClip then LocObj("Save to Server", 'saveServer) else LocObj("Clear", 'clear);       	//inherited:?viewSetupFormScript();       end,     _proto: @226 /* protoTextButton */    };AddStepForm(clipboardFrame, clearSaveButton);// After Script for clipboardFramethisView := clipboardFrame;begin	if ADD_SERVER	then thisView.viewDrawScript := kRefreshPatch.viewDrawScript;endconstant |layout_logClipboardVNC.lyt| := clipboardFrame;// End of file logClipboardVNC.lyt// Beginning of file aboutVNC.lytaboutLayout :=    {viewBounds: {left: 0, top: -170, right: 250, bottom: -22},     viewJustify: 144,     viewSetupFormScript:       func()	nil	// *** kShiftView       ,     uiHide: -1,     _proto: @180 /* protoFloatNGo */    };aboutLayout_v229_0 :=    {title: titleLabel,     viewBounds: {left: -4, top: 0, right: 132, bottom: 16},     _proto: @229 /* protoTitle */    };AddStepForm(aboutLayout, aboutLayout_v229_0);aboutText :=    {viewBounds: {left: 2, top: 22, right: -2, bottom: 102},     viewFlags: 3,     viewFont: editFont12,     viewFormat: 257,     viewLineSpacing: 16,     text: /*string*/ ABOUT_TEXT,     viewJustify: 48,     tabs: [20, 40,],     viewClass: 81 /* clParagraphView */    };AddStepForm(aboutLayout, aboutText);urlText :=    {viewBounds: {left: 2, top: -39, right: -2, bottom: -25},     viewFlags: 515,     viewFont: Bor(tsUnderline, userFont12),     viewFormat: 257,     viewLineSpacing: 14,     text:       /*string*/ "http://www.kagi.com/weyer/#VNC"       ,     viewClickScript:       /*boolean*/ func(unit)	// ***       begin       	GetRoot().(kNewtsCapeSymbol):?getURL(URLtext,nil);       	base:close();       	TRUE;       end,     viewJustify: 176,     viewClass: 81 /* clParagraphView */    };AddStepForm(aboutLayout, urlText);// After Script for urlTextthisView := urlText;thisView.URLtext := thisView.textmailText :=    {viewBounds: {left: 2, top: -19, right: -25, bottom: -5},     viewFlags: 515,     viewFont: Bor(tsUnderline, userFont12),     viewFormat: 257,     viewLineSpacing: 14,     text: /*string*/ "mailto:weyer@kagi.com",     viewClickScript:       /*boolean*/ func(unit)	// ***       begin       	GetRoot().(kNewtsCapeSymbol):?getURL(URLtext, nil);       	base:close();       	TRUE;       end,     viewJustify: 176,     viewClass: 81 /* clParagraphView */    };AddStepForm(aboutLayout, mailText);// After Script for mailTextthisView := mailText;thisView.URLtext :=	thisView.text &	"?subject=VNC Feedback" &	"&body=" & titleLabel;// After Script for aboutLayoutthisView := aboutLayout;begin	// *** share some methods (easier than defining user protos)	local array children := thisView.stepChildren;	local int www := 2, mail := 3;	children[mail].viewClickScript :=		children[www].viewClickScript;	thisView.viewSetupFormScript := kShiftView;	if ADD_SERVER	then thisView.viewDrawScript := kRefreshPatch.viewDrawScript;end	constant |layout_aboutVNC.lyt| := aboutLayout;// End of file aboutVNC.lyt// Beginning of file compactFloatVNC.lytcompactFloat :=    {viewBounds: {left: 7, top: -16, right: -7, bottom: 0},     title:       nil	// for title child (added later)       ,     viewJustify: 176,     uiHide:       -1		// this allows i, kbd, etc. to display here when opened       ,     _proto: @179 /* protoFloater */    };// After Script for compactFloatthisView := compactFloat;/*children will be added at run-time*/constant |layout_compactFloatVNC.lyt| := compactFloat;// End of file compactFloatVNC.lyt// Beginning of file VNCNative.ntkc/*DefConst('VNCNative,PP: Ill-placed Blank{FFillRect2: {class: BinCFunction, code: <code>, numArgs: 6, offset: 508},    FDrawRawRect: {class: BinCFunction, code: <code>, numArgs: 6, offset: 1832}    });*/// End of file VNCNative.ntkc// Beginning of file newtVNC.lyt// Before Script for vncview//  Newton version//  @author <A HREF="mailto:weyer@kagi.com">Steve Weyer</A>//  Copyright (C) 2001 S. Weyer.  All Rights Reserved.//  based loosely on://  <A HREF="http://www.uk.research.att.com/vnc/">vncviewer: original Java client</A>///*'anonymous' contributor of VNC icon:	Michael Vacik	mvacik@knowledgepoint.com, mici@metastasis.netVNCNative and Zlib libraries courtesy of:	Paul Guyot	pguyot@kallisys.net	http://www.kallisys.com/newton/zlib/*/// Copyright (c) 2001, Steve Weyer// All rights reserved.//// Redistribution and use in source and binary forms, with or without// modification, are permitted provided that the following conditions// are met://// * Redistributions of source code must retain the above copyright//   notice and the following disclaimer.// * Redistributions in binary form must reproduce the above//   copyright notice and the following disclaimer in the//   documentation and/or other materials provided with the//   distribution.// * Neither the name of TKnollSys nor the names of its contributors//   may be used to endorse or promote products derived from this//   software without specific prior written permission.//// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR// A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT// HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.vncview :=    {     disconnect:       func(/*boolean*/ q)       begin       	if not quitPending       	then quitPending := q;       	AddProcrastinatedCall(kAppSymbol, kNilFunc, nil, 0);	// cancel pending update       	if rfb       	then rfb := rfb:close()       	else :disconnected();       end,     server: nil,     viewFormat: 83951873,     Status:       func(/*string*/ txt, arg, /*boolean*/ doLog)       begin       	if arg       	then txt := txt & $: && arg;       if (DEBUG) then Print(txt);       	if doLog       	then clipboard:?log(txt);       	if statusView and options.minUI = kExpanded       	then SetValue(statusView, 'text, txt);       end,     quitPending: nil,     v: /*vncview*/ nil,     viewQuitScript:       func()	// called usually by disconnected (or indirectly by closeButton)       begin       	if rfb       	then begin       if DEBUG then Print("quit w/o earlier disconnect??");       		// this should NOT have occurred (unless something else sent :close directly)!  Rotate?       		// ?? maybe should use a ModalDialog (ala 'go away' in protoFSM)       		:disconnect(true);       		end;       	kbd:?close();       	:viewShowScript();	// hideObj cleanup       	if nos21 and options.displaySize = kFullBarSize       	then :setButtonBar(restoreButtonBar);	// restores routeScripts              	if ADD_SERVER       	then vnc := nil;       	encodings := target := targetView := v := options := rfb := kbd := nil;              	UnRegPowerOff(kAppSymbol);       	//inherited:?viewQuitScript();       end,     kbd: nil,     ViewGetDropTypesScript: func(currentPoint) '[text],     fixKeyboard:       // based on code borrowed from Newt's Cape              DefineGlobalConstant('keyFramedMask, keyFramed + (keyFramed << 1));                     DefineGlobalConstant('kKeysize1, keyHUnit + keyVUnit + keyAutoHilite + keyRoundingUnit*3);              // 'shift'(288362504) = (keyHUnit*2) + keyVUnit + (keyFramed*2) + keyAutoHilite + keyRoundingUnit*3       //DefineGlobalConstant('kkeyH38, keyHQuarter + keyHEighth);       DefineGlobalConstant('kSpaceBarBorrow,  				keyHUnit + keyHUnit);		// -2.000 to subtract from spacebar       DefineGlobalConstant('kOptionKeyBorrow, 				keyHHalf + keyHQuarter);	// -0.750 to subtract from option (opt/meta)       DefineGlobalConstant('kCmdKey, [LocObj("cmd", 'cmd),  kCommandKeyCode, kKeysize1 + keyHQuarter]);	// +1.250 for cmd/alt       DefineGlobalConstant('kCtrlKey,[LocObj("ctrl", 'ctrl), kControlKeyCode, kKeysize1 + keyHHalf]);	// +1.500 for ctrl                           DefineGlobalConstant('kKeyFrameWid, func(array keys, int offset, int wid)       begin       	local int i;       	for i:=offset to Length(keys)-1 by 3       	do keys[i+2] := Bor(keys[i+2], wid);       	keys;       end);              constant kRow0Len := 44;       constant kRow4Len := 17;              /*boolean*/ func()       begin       	SetKeyView(paraView,0);        	if options.kbdMode = 0       	then return NIL;              	local /*frame*/ akbd := GetRoot().alphaKeyboard;       	if not v.kbd       	then begin       		// use standard kbd (if child template matches)       		local /*frame*/ vb := akbd.viewBounds;       		if not vb       		then vb := akbd.saveBounds;       		local array vc, kp, kpUSdefs, kpISOdefs;                     		if IsFrame(vb) and IsArray(vc := akbd.viewChildren) and IsFrame(kp := vc[0]) and       			IsArray(kpISOdefs := kp.keyDefinitionsISO) and IsArray(kpUSdefs := kp.keyDefinitionsUS)       		then begin       			v.kbd := akbd;	// default               			local int frWid := Band(kpUSdefs[0][4], keyFramedMask);	// existing frame wid of 1st key       			local array cmdKey  := call kKeyFrameWid with (Clone(kCmdKey),  0, frWid), defs, row;       			if options.kbdMode=2 then cmdKey[0] := LocObj("alt", 'alt);         			local array ctrlKey := call kKeyFrameWid with (Clone(kCtrlKey), 0, frWid);                   			// to modify keydefs for cmdKey (maybe)       			foreach defs in [kpUSdefs := Clone(kpUSdefs), kpISOdefs := Clone(kpISOdefs)]       			do  if Length(defs) = 5        				then begin       					if Length(row := defs[4]) = kRow4Len       					then begin       						row := defs[4] := Clone(row);       						row[5]  := if options.kbdMode=1 then LocObj("opt",'opt) else LocObj("meta", 'meta);       						row[7]  := row[7]  - kOptionKeyBorrow;       						row[10] := row[10] - kSpaceBarBorrow; 	// steal width from spacebar       						ArrayMunger(row,8,0, cmdKey,0,nil);	// insert between option and spacebar       						ArrayMunger(row,5,0, ctrlKey,0,nil);	// insert before option       						end;       					if options.kbdMode=2 and Length(row := defs[0]) = kRow0Len and IsString(row[kRow0Len-3]) // bm for ISO??       					then begin       						row := defs[0] := Clone(row);       						row[kRow0Len-3] := LocObj("bs", 'bs);       						end;       					end;              			vc := Clone(vc);       			vc[0] := {       				_proto: kp,       				keyDefinitionsISO: kpISOdefs,       				keyDefinitionsUS:  kpUSdefs,       				};              			v.kbd := BuildContext({       				_proto: akbd._proto,       				viewChildren: vc,       				});       			end       		else return NIL;       		end;       	return TRUE;       end,     viewFlags: 5,     connected:       func(/*string*/ serverName, int wid, int ht)       begin       	:status(LocObj("Server Name", 'serverName), serverName, DO_LOG);       	if wid and ht       	then serverName := serverName & $; && wid & $x & ht;           :setTitle(serverName);               	clipboard:setCutText("");       	if not server       	then begin       		:status(LocObj("Remote Size", 'remoteSize), wid && $x && ht, DO_LOG);           	:setEncodings();           	end;           vc:connected(wid,ht); // more init. request/send buffer update       end,     ReorientToScreen:       func()	//ROM_DefRotateFunc	//@588       begin	// called by Rotate, or minUI preference change       	reorienting := true;	// checked only by vnc.vsf, vc.vsf       	kbd:?close();       	kbd := nil;       	:SyncView();       	:RedoChildren();	//SyncChildren doesn't remove other views       	reorienting := nil;              	// named children not reopened (when earlier hidden)       	local view;       	if options.minUI <> kCompactFloat and not call kViewIsOpenFunc with (view := title)       	then begin       		view:Open();       		view:Dirty();       		end;              	if options.minUI <> kExpanded or call kViewIsOpenFunc with (statusView)       	then return;              	foreach view in [statusView, LRslider, TBslider]       	do begin       		view:Open();       		view:Dirty();       		end;       end,     viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     SetTitle:       func(/*string*/ txt)       begin       	if title       	then SetValue(title, 'text, txt);       	if compactFloat and options.minUI = kCompactFloat       	then AddDeferredCall(func(txt) SetValue(compactFloat.title, 'text, txt), [txt]);       end,     setEncodings:       func()       begin       	// assume all to begin with (but add EncodingCopyRect at end)       	encodings := [EncodingHextile, EncodingZlib, EncodingCoRRE, EncodingRRE, EncodingRaw]; // EncodingTight,EncodingZlibHex                  	local int preferredEncoding := options.encoding;        	if not zlib        	then begin        		//SetRemove(encodings, EncodingTight);        		//SetRemove(encodings, EncodingZlibHex);        		SetRemove(encodings, EncodingZlib);        		// note: if zlib or tight was preferred, it won't be found below so Hextile will become preferred        		end;               	local int pos := SetContains(encodings, preferredEncoding);       	if pos and pos > 0       	then begin // move preferredEncoding to beginning       		ArrayRemoveCount(encodings, pos, 1);       		ArrayInsert(encodings, preferredEncoding, 0);       		end;       	if options.useCopyRect       	then ArrayInsert(encodings, EncodingCopyRect, 0);                  rfb:?SetEncodings(encodings);       end,     zlib: nil,     ViewDropScript:       func(/*symbol*/ dropType, dropData, dropPt)       begin       	if dropType='text       	then begin       		paraView.textSrc := LocObj("drop", 'drop);       		SetValue(paraView, 'text, dropData.text);       		TRUE;       		end;       end,     viewScrollDownScript:       func() // note: this is invoked repeatedly while pressed but scroll just once       begin       	// this finally runs ~1/2 sec after done       	AddProcrastinatedSend(EVENT_SCR, vc, 'SetOriginRel, '[0, 0.5, 0], EVENT_SCR_DELAY);              	// this invoked multiple times (to update #)       	vc:setOriginRel(0, 0.5, UPDATE_SCR_DELAY)       end,     viewOverviewScript:       func()       vc:viewOverviewScript(),     viewJustify: 240,     clipboardOpen:       func()       begin       	clipboard.title := if (clipboard.logClip := not server and rfb:?isOpen()) then clipLabel else logLabel;       	clipboard:open();       end,     powerOffScript:       func(/*symbol*/ what)       what = 'okToPowerOff and not rfb,     encodings: /*int[]*/ nil,     connect:       func(/*string*/ host, int port, /*string*/ pw)       begin       if (DEBUG) then Print("host:port = " & host & $: & port);       	clipboard:clearLogText();           rfb := rfbProto:new(host, port, pw, self);           server := rfb.server;           vc:setSize(true);                   if ADD_SERVER and server           then begin           	rfb:setSize(vc.viewWidth, vc.viewHeight);           	rfb:setName(options.serverName);           	//rfb:setPixelFormat(xxx); // defaults used           	end;           rfb:connect();       end,     options: /*frame*/ nil,     hideObj: nil,     viewScrollUpScript:       func() // note: this is invoked repeatedly while pressedl but scroll just once       begin       	// this finally runs when done       	AddProcrastinatedSend(EVENT_SCR, vc, 'SetOriginRel, '[0, -0.5, 0], EVENT_SCR_DELAY);              	// this invoked multiple times (to update #)       	vc:setOriginRel(0, -0.5, UPDATE_SCR_DELAY)       end,     setButtonBar:       func(array buttonBarArg)       begin       	local /*frame*/ buttonBar := GetRoot().Buttons;       	local array entries;       	if buttonBarArg = restoreButtonBar and HasSlot(self, 'routeScripts)       	then RemoveSlot(self, 'routeScripts);              	else if buttonBarArg = noButtonBar and not HasSlot(self, 'routeScripts) and (entries := if buttonBar.soft then buttonBar:GetPartEntries().mobile)       	then begin       		routeScripts := Clone(routeScripts);              		// add buttonBar items to action menu       		// so far there shouldn't be symbol conflicts... (but if so, prefix newtVNC items with _)       		//routeScripts.divider3 := nil;       		routeScripts.overview := {       			icon:  ROM_overviewbitmap.unhilited,       			title: LocObj("Overview", 'overview),       			routeScript: func(target,targetView) begin Print(targetView); targetView:viewOverviewScript(); end,       			};                     	local /*string*/ openScript := "func(t,tv)GetRoot().|^0|:?Open()";              	local /*string*/  tapScript := "func(t,tv)GetRoot().Buttons:GetPartEntries().mobile[^0]:?TapAction()";       		local /*symbol*/ sym;       		local /*frame*/ entry;       		local script, app;       		local int i;       		foreach i,entry in entries       		do begin       			// this cleaner and provides icons but omits TapAction (e.g., Undo)       			//entry := call kGetPartEntryDataFunc with (entry);       			//sym := entry.appSymbol;       			sym := app := entry.app;       			script := nil;       			if GetRoot().(sym)       			then script := openScript       			else if entry.TapAction       			then begin       				script := tapScript;       				app := i;       				end;       			if script       			then routeScripts.(sym) := {       				icon:  nil,	//entry.iconPro.unhilited,       				title: entry.text,       				routeScript: call Compile(ParamStr(script, [SPrintObject(app)])) with (),       				};       			end;       		end;              /*       	// now taken care of in v.vsf -- just adjust viewBounds       	// avoid loops. only call if necessary       	local barOpen := GetAppParams().buttonBarPosition <> 'none;	//call kViewIsOpenFunc with (buttonBar);       	if (buttonBarArg = noButtonBar and barOpen) or (buttonBarArg = restoreButtonBar and not barOpen)       	then KillStdButtonBar(buttonBarArg);       */       end,     Refresh:       func(/*frame*/ obj, /*symbol*/ sym, /*frame*/ bnds)	// called via kRefreshPatch       if server and vc and vc.refreshAccept       then vc:Refresh(INCR_REFRESH, if DEBUG then call kGetSymbol with(obj) & $: & sym else NO_DELAY, bnds)     ,     disconnected:       func()       if quitPending       then base:?close()       else begin       	vc:disconnected();       	if ADD_SERVER and server       	then begin       		:show();       		authenticator:open();       		server := nil;       		end;           :setTitle(titleLabel & $; && vc.viewWidth & $x & vc.viewHeight);           :status(LocObj("disconnected", 'disconnected), nil, NO_LOG);       	end,     viewSetupFormScript:       func()       begin       	v := self.targetView := self.target := self.base := self;       	quitPending := nil;              	options := GetAppPrefs(kAppSymbol, kDefaultPrefs);       	// set default values missing in old versions (if not nil)       	if not options.kbdMode       	then options.kbdMode := 0;		// kDefaultPrefs.kbdMode       	if not options.scrollInc       	then options.scrollInc := 16;	// kDefaultPrefs.scrollInc       	if not options.rightClick       	then options.rightClick := if options.reverseMouseButtons2And3 then kBut2 else kBut3;	// 4 = kDefaultPrefs.righClick       	// options.bpp -- NOS 2.0 below       	if options.minUI=true       	then options.minUI := kCompactBot       	else if not options.minUI       	then options.minUI := kExpanded;       	if not options.vsRadio       	then options.vsRadio := VIEWER_RADIO;       	if not options.serverName       	then options.serverName := kAppName & $: && GetUserConfig('name);              	zlib := not call kMissingImportsFunc with (ObjectPkgRef("Me"));       	if not zlib and options.encoding > EncodingHextile       	then options.encoding := EncodingHextile;              	viewJustify := _proto.viewJustify;       	viewBounds  := _proto.viewBounds;       	if nos21 and GetRoot().Buttons.soft       	then if options.displaySize = kFullBarSize       		then begin // recommended way to use button bar space (rather than "kill"). see NTJ_Behind_Bars.pdf       			viewJustify := vjParentLeftH + vjParentTopV;       			local /*frame*/ params := GetAppParams();       			viewBounds := OffsetRect(       				UnionRect(params.appAreaBounds, params.buttonBarBounds),       				-params.appAreaGlobalLeft,       				-params.appAreaGlobalTop);       			:setButtonBar(noButtonBar);		// add to routeScripts       			end       		else :setButtonBar(restoreButtonBar);              	if not reorienting and not rfb:?IsOpen()       	then begin       		AddDeferredSend(authenticator, 'open, nil);       		RegPowerOff(kAppSymbol,              		func(what,why) v:powerOffScript(what));              	end;              	if options.minUI = kCompactFloat       	then begin       		compactFloat.stepChildren := ArrayMunger([stepChildren: ],0,nil, stepChildren,0,6);       		compactFloat.stepAllocateContext := ArrayMunger(Array(2,nil),0,2, stepAllocateContext,0,2);       		compactFloat:open();       		end       	else compactFloat:?close();              	//inherited:?viewSetupFormScript();       end,     rfb: /*rfbProto*/ nil,     routeScripts:       constant kMenuLabel := LocObj("menu",'menu);              // since target:isopen only used twice (and just here), just inline.       // :GetTitle can use local context, e.g., openTitle)       DefineGlobalConstant('kGetTitleTargetOpen, func(target)       	if target.rfb:?isOpen() and not target.server then openTitle else self.notOpenTitle);              // evidently, routeScript is called as a function (or method on app)       // so not possible to use exact same code and somehow access item-specific params (charCode, modifiers, sound)       //DefineGlobalConstant('kRouteScriptKey, func(target, targetView)       //		targetView.paraView:writeKey(charCode, modifiers, nil, nil, kMenuLabel, sound));              DefineGlobalConstant('kCtrlCmdModifier, Bor(kControlModifier, kCommandModifier));       DefineGlobalConstant('kCharX, Ord($x));       DefineGlobalConstant('kCharV, Ord($v));       DefineGlobalConstant('kCharC, Ord($c));       DefineGlobalConstant('kCharZ, Ord($z));       DefineGlobalConstant('kCharA, Ord($a));              {       _connect: {       	icon: ROM_routeCallBitmap, 	//ROM_routeTransport, @599,       	GetTitle: func(target)       		if target.rfb then discLabel else connLabel,	// if not completely open, then Disconnect is appropriate       	routeScript: func(/*frame*/ target, /*frame*/ targetView)       		if targetView.rfb       		then targetView:disconnect(nil)       		else targetView.authenticator:open(),       },              _refresh: { // not really needed (once no errors, e.g., copyRect) ???       	icon: ROM_routeUpdateBitmap,       	GetTitle: kGetTitleTargetOpen,       	openTitle: LocObj("Refresh", 'refresh),       	routeScript: func(target, targetView)       		targetView.vc:refresh(FULL_REFRESH, NO_DELAY, nil),	// full,immed refresh       },              _logClip: {       	icon: ROM_routeLog,       	GetTitle: kGetTitleTargetOpen,       	openTitle: clipLabel,       	notOpenTitle: logLabel,       	routeScript: func(target, targetView)       		targetView:clipboardOpen(),       	},              _hide: {       	icon: @14,	// star       	title: LocObj("Hide",'hide),       	routeScript: func(target, targetView)       		targetView:hide(),       	},              divider1: NIL,              _undo: {       	icon: nil,       	GetTitle: kGetTitleTargetOpen,       	openTitle: LocObj("Undo", 'undo),       	routeScript: func(target, targetView)       		targetView.paraView:writeKey(kCharZ, kControlModifier, nil, nil, kMenuLabel, NO_SOUND),       	},              _cut: {       	icon: ROM_routeDeleteIcon,       	GetTitle: kGetTitleTargetOpen,       	openTitle: LocObj("Cut", 'cut),       	routeScript: func(target, targetView)       		targetView.paraView:writeKey(kCharX, kControlModifier, nil, nil, kMenuLabel, ROM_removeSound),       	},              _copy: {       	icon: ROM_routeDuplicateIcon,       	GetTitle: kGetTitleTargetOpen,       	openTitle: LocObj("Copy", 'copy),       	routeScript: func(target, targetView)       		targetView.paraView:writeKey(kCharC, kControlModifier, nil, nil, kMenuLabel, ROM_copier),       	},              _paste: {       	icon: ROM_routePasteText,       	GetTitle: kGetTitleTargetOpen,       	openTitle: LocObj("Paste", 'paste),       	routeScript: func(target, targetView)       		targetView.paraView:writeKey(kCharV, kControlModifier, nil, nil, kMenuLabel, ROM_addSound),       	},              _selectAll: {       	icon: nil,       	GetTitle: kGetTitleTargetOpen,       	openTitle: LocObj("Select All", 'selectAll),       	routeScript: func(target, targetView)       		targetView.paraView:writeKey(kCharA, kControlModifier, nil, nil, kMenuLabel, NO_SOUND),       	},              divider2: NIL,              _ctrlAltDel: {       	icon: ROM_routeMissing,		// ROM_dtmfStarBitmap       	GetTitle: kGetTitleTargetOpen,       	openTitle: LocObj("Ctrl-Alt-Del", 'cad),       	routeScript: func(target, targetView)       		targetView.paraView:writeKey(chDEL, kCtrlCmdModifier, nil, nil, kMenuLabel, ROM_bootSound), //??ROM_wakeUpBeep,       	},       }              /*       open: {       	//icon: ???,       	GetTitle: kGetTitleTargetOpen,       	openTitle: LocObj("Open", 'open),       	routeScript: func(target, targetView)       		targetView.paraView:writeKey(??, modifiers, nil, nil, kMenuLabel, sound),              	//routeScript: kRouteScriptKey,       	//charCode: Ord($o),       	//modifiers: kControlModifier,       	//sound: ROM_drawerOpen,       	},       close: {       	icon: ROM_cancelbitmap,       	GetTitle: kGetTitleTargetOpen,       	openTitle: LocObj("Close", 'close),       	routeScript: kRouteScriptKey,       	charCode: Ord($w), //??       	modifiers: kControlModifier,       	sound: ROM_drawerClose,       	},       rotate: {       	//icon: ???       	GetTitle: func(target)       		if target.nos21 then LocObj("Rotate", 'rotate),	// would need to test hack for NOS 2.0       	routeScript: func(target, targetView)       		begin       			local tmp := {       				_proto: protoOrientation,       				_parent: targetView,		// or use BuiltContext. need :PopupMenu avail       				//viewBounds: RelBounds(-16,0,50,16),	// not particular important. vj=centerH,bottomV       				};       			// :PopupMenu(tmp.popup, nil)	// ends up on left       			tmp:PopupMenu(tmp.popup, {bounds: RelBounds(targetView:LocalBox().right,0,0,0)});       		end,       	},       */,     installRefreshPatch:       func(/*boolean*/ install, /*frame*/ obj, array updates)       begin       /*       	(un)patch existing objs at runtime -- when VNC (dis)connects to send incremental updates automatically       	also patch when new apps have opened; temporary apps disappear from patches list automatically       	avoids more complex "proto patching" (which would involve closing apps, incl. the background(blessed) app & VNC indirectly)       */       	if install       	then begin       		if not patches       		then patches := NewWeakArray(20);       		local int pos;       		foreach obj in obj:childViewFrames()       		do  if not SetContains(patches, obj) and obj.appSymbol <> kAppSymbol and       				Visible(obj) and not :RectEqual(obj:LocalBox(), kRect0) // only not patched & non-empty       			then begin       				if pos := SetContains(patches,nil)	// reuse empty spots       				then patches[pos] := obj       				else AddArraySlot(patches, obj);              				call kFrameMunger with(obj, kRefreshPatch, 'add, call kGetPatchSlots with (obj));              if DEBUG then Print(["patched", pos := call kGetAppSymbol with(obj)]);       				if updates	// for vc.viewIdleScript. include frame(if any). use :Refresh to merge rects if possible       				then vc:Refresh(INCR_REFRESH, if DEBUG then pos & $: & 'install else NO_DELAY, obj:GlobalOuterBox());              				// patch each child, excluding initial rect (each main app already added entire enclosing rect)       				// ??? patch viewChildren array       				:installRefreshPatch(true, obj, nil);       				end;       		end              	else if patches       	then begin       		foreach obj in patches       		 do if obj and IsValid(obj)       		 	then try begin       if DEBUG then Print(["unpatched", call kGetAppSymbol with(obj)]);       				call kFrameMunger with(obj, kRefreshPatch, nil, call kGetPatchSlots with (obj));       				end       				onexception |evt.ex| do nil;       		patches := nil;       		end;       end,     viewHideScript:       func()       begin // based on code borrowed from Newt's Cape       	if Visible(self)       	then begin       		if not hideObj       		then hideObj := GetRoot().notifyIcon:?AddAction(       			kAppName, func() GetRoot().(kAppSymbol):open(), nil);       		SetKeyView(nil, 0);       		end;       	//inherited:?viewHideScript();       end,     viewClass: 74 /* clView */,     reorienting: /*boolean*/ nil,     viewShowScript:       func()       begin       	if hideObj       	then begin       		GetRoot().notifyIcon:?KillAction(hideObj);        		hideObj := nil;       		end;       	//SetKeyView(paraView, 0);       	//inherited:?viewShowScript();       end,     uiHide: kCompactFloat    };infoButton :=    {viewBounds: {left: 2, top: -15, right: 15, bottom: -2},     viewJustify: 134,     DoInfoPrefs: func() optionsFrame:open(),     DoInfoAbout: func() about:open(),     viewSetupFormScript:       func() nil // *** kShiftView       ,     _proto: @478 /* protoInfoButton */    };AddStepForm(vncview, infoButton);// After Script for infoButtonthisView := infoButton;thisView.DoInfoPrefs := kOptionsOpen;	// ***kbdButton :=    {viewBounds: {left: 21, top: -15, right: 39, bottom: -2},     viewJustify: 134,     buttonClickScript:       func()       begin       	if not v:fixKeyboard() or call kViewIsOpenFunc with (v.kbd)       	then return inherited:buttonClickScript()	// regular kbd or kbd menu       	else v.kbd:open();       end,     viewSetupFormScript:       func() nil // *** kShiftView       ,     _proto: @624 /* protoSmallKeyboardButton */    };AddStepForm(vncview, kbdButton);title :=    {viewBounds: {left: 44, top: -15, right: -108, bottom: -2},     text: /*string*/ titleLabel,     viewJustify: 8388784,     viewFont: ROM_fontSystem10Bold,     setGauge:       func(/*real*/ fval)       if fval = 0       then begin       	:HiliteUnique(0);			// turn 'on' title       	local /*frame*/ bnds := :LocalBox();       	lastGauge[0] := MakeRect(0,0,0,bnds.bottom);       	maxVal := bnds.right;       	end              else if fval = 1       then begin       	:HiliteUnique(nil);		// turn 'off' title       	:Dirty();       	end              else if IsReal(fval) and fval > 0 and fval < 1       then begin       	local /*byte[]*/ rect := lastGauge[0];       	local int x := RIntToL(maxVal * fval), x2 := ExtractWord(rect, 6); //x1 := ExtractWord(rect, 2),        	if x > x2       	then begin       		StuffWord(rect, 2, x2);       		StuffWord(rect, 6, x);       		end       	else if x < x2       	then StuffWord(rect, 2, x);       	else return;       	:DoDrawing('DrawShape, lastGauge);       	if x < x2       	then begin       		Stuffword(rect, 2, 0);       		StuffWord(rect, 6, x);       		end;       	end       	       else if DEBUG then Print("fval:" && fval),     lastGauge: /*array*/ nil,     viewSetupFormScript:       func()       begin       	viewFlags 	:= _proto.viewFlags;       	viewJustify := _proto.viewJustify;       	viewBounds  := _proto.viewBounds;       	local int minUI := options.minUI;       	if minUI = uiHide	// in vnc, true for minUI=kCompactFloat       	then viewFlags := Band(viewFlags, Bnot(vVisible))       	else if minUI <> kCompactBot	// 'default'  (similar to kShiftview, except move/shift/fixedSize for Expanded))       	then begin       		viewBounds := Clone(_proto.viewBounds);       		viewJustify := viewJustify - vjParentBottomV;	// vjParentTopV       		local int top 	:= viewBounds.top;       		viewBounds.top 	:= -viewBounds.bottom;       		viewBounds.bottom := -top;       		if minUI = kExpanded       		then begin       			viewJustify := Band(viewJustify, Bnot(vjParentFullH));	// regular vjParentLeftH       			viewBounds.left  := 2;       			viewBounds.right := 170;       			end;       		end;       	//inherited:?viewSetupFormScript();       	lastGauge := [nil, GAUGE_STYLE];	// for setGauge       end       ,     maxVal: /*int*/ 0,     _proto: @218 /* protoStaticText */    };AddStepForm(vncview, title);StepDeclare(vncview, title, 'title);compactScroll :=    {viewBounds: {left: -108, top: -17, right: -44, bottom: 1},     viewJustify: 160,     ViewScroll2DScript:       func(direction,extras)       begin       //if (DEBUG) then Print([direction,extras]);       	local inc := options.scrollInc;       	local int amt := extras.amount;       	if (direction='left) or (direction='right)       	then dx := dx + (Signum(amt) * (if inc='full then vc.viewWidth else inc))       	else if (direction='up) or (direction='down)       	then dy := dy + (Signum(amt) * (if inc='full then vc.viewHeight else inc));       	       	vc:setOriginRel(dx, dy, EVENT_SCR2D_DELAY); // just update coord and slow down a little       	inherited:?viewScroll2DScript(direction,extras);       end,     ViewScrollDoneScript:       func()       begin       	vc:setOriginRel(dx,dy, NO_DELAY);	// update coords and do scroll       	dx := dy := 0;						// reset       	inherited:?viewScrollDoneScript();       end,     dx: /*int*/ 0,     dy: /*int*/ 0,     viewSetupFormScript:       func()       begin       	viewFlags := _proto.viewFlags;       	local int minUI := options.minUI;       	if minUI = uiHide	// in vnc, true for minUI=kCompactFloat       	 	or minUI = kExpanded       	then viewFlags := Band(viewFlags, Bnot(vVisible))       	else begin	// like kShiftView       		viewBounds  := _proto.viewBounds;       		viewJustify := _proto.viewJustify;       		if minUI = kCompactTop	// non-default       		then begin       			viewJustify := viewJustify - vjParentBottomV; // vjParentTopV=0       			viewBounds := Clone(viewBounds);       			local int top 	:= viewBounds.top;       			viewBounds.top 	:= -viewBounds.bottom;       			viewBounds.bottom := -top;       			end;       		end;       	inherited:?viewSetupFormScript();       end,     _proto: @608 /* protoHorizontal2DScroller */    };AddStepForm(vncview, compactScroll);actionButton :=    {viewJustify: 166,     viewBounds: {left: -40, top: -15, right: -23, bottom: -2},     viewSetupFormScript:       func()	nil	// *** kShiftView       ,     _proto: @209 /* protoActionButton */    };AddStepForm(vncview, actionButton);closeButton :=    {     buttonClickScript:       func()       v:disconnect(true)	// quit (after possible disconnect)       ,     viewBounds: {left: -15, top: -15, right: -2, bottom: -2},     viewSetupFormScript:       func()	nil	// *** kShiftView       ,     _proto: @163 /* protoLargeClosebox */    };AddStepForm(vncview, closeButton);statusView :=    {viewBounds: {left: 170, top: 2, right: -2, bottom: 15},     viewFlags: 3,     viewFont: simpleFont12,     viewFormat: 305,     viewLineSpacing: 14,     viewJustify: 48,     text: /*string*/ "",     viewSetupFormScript:       func()	// ***       begin       	viewFlags := _proto.viewFlags;       	if options.minUI <> kExpanded       	then viewFlags := Band(viewFlags, Bnot(vVisible)); //Bor(viewFlags, vVisible);       	//inherited:?viewSetupFormScript();       end,     viewClass: 81 /* clParagraphView */    };AddStepForm(vncview, statusView);StepDeclare(vncview, statusView, 'statusView);leftBigScroll :=    {viewBounds: {left: 43, top: -17, right: 55, bottom: 1},     buttonClickScript:       func()	// ***       AddDeferredSend(vc, 'SetOriginRel, [dx, dy, NO_DELAY]),     viewJustify: 134,     viewFormat: 67109377,     viewSetupFormScript:       func()	// ***       begin       	local /*boolean*/ expanded := options.minUI = kExpanded;       	viewFlags := _proto.viewFlags;       	if not expanded       	then viewFlags := Band(viewFlags, Bnot(vVisible)); //Bor(viewFlags, vVisible);       	if nos21 and ricon and expanded       	then icon := OffsetShape(MungeShape(MakeShape(ricon), 'rotateRight, nil),-3,3);       		//icon := MungeBitmap(DeepClone(icon), 'rotateLeft, nil);	// doesn't seem to work              	inherited:?viewSetupFormScript();       end,     dx: /*int*/ -1,     dy: /*int*/ 0,     _proto: @198 /* protoPictureButton */    };AddStepForm(vncview, leftBigScroll);// After Script for leftBigScrollthisView := leftBigScroll;begin	thisView.icon  := ROM_leftBitmap;	// kinda small but ok for NOS 2.0	thisView.ricon := ROM_downBitmap;	// rotate right in vsfend/* try to reuse scroller arrows -- except there's a border in bitmap!setvalue(vnc.vc, 'icon, protohorizontal2dscroller.arrows)vnc.vc.testx := func(index)drawxbitmap(RelBounds(100,100,16,17), protohorizontal2dscroller.arrows, index, modeCopy)*/LRslider :=    {     changedSlider:       func()	// ***       begin	// same as trackSlider except delay       	local int val := viewValue - Band(viewValue,0xF), x, y;       	if (direction = 'x)       	then x := val       	else // if (direction = 'y) then       		 y := val;       	vc:setOrigin(x, y, nil, NO_DELAY);       end,     viewBounds: {left: 55, top: -14, right: -56, bottom: -2},     viewSetupFormScript:       func()	// ***       begin       	viewFlags := _proto.viewFlags;       	if options.minUI <> kExpanded       	then viewFlags := Band(viewFlags, Bnot(vVisible)); //Bor(viewFlags, vVisible);       	//inherited:?viewSetupFormScript();       end,     viewValue: 0,     viewJustify: 176,     viewFormat: 0,     trackSlider:       func()	// ***       begin       	local int val := viewValue - Band(viewValue,0xF), x, y;       	if (direction = 'x)       	then x := val       	else // if (direction = 'y) then       		 y := val;       	vc:setOrigin(x, y, nil, SLIDER_DELAY);       end,     direction: /*symbol*/ 'x,     _proto: @212 /* protoSlider */    };AddStepForm(vncview, LRslider);StepDeclare(vncview, LRslider, 'LRslider);rightBigScroll :=    {viewBounds: {left: -56, top: -17, right: -44, bottom: 1},     buttonClickScript:       func()	// ***       AddDeferredSend(vc, 'SetOriginRel, [dx, dy, NO_DELAY]),     viewJustify: 166,     viewFormat: 67109377,     viewSetupFormScript:       func()	// ***       begin       	local /*boolean*/ expanded := options.minUI = kExpanded;       	viewFlags := _proto.viewFlags;       	if not expanded       	then viewFlags := Band(viewFlags, Bnot(vVisible)); //Bor(viewFlags, vVisible);       	if nos21 and ricon and expanded       	then icon := OffsetShape(MungeShape(MakeShape(ricon), 'rotateRight, nil),-3,3);       		//icon := MungeBitmap(DeepClone(icon), 'rotateLeft, nil);	// doesn't seem to work              	inherited:?viewSetupFormScript();       end,     dx: /*int*/ 1,     dy: /*int*/ 0,     _proto: @198 /* protoPictureButton */    };AddStepForm(vncview, rightBigScroll);// After Script for rightBigScrollthisView := rightBigScroll;begin	thisView.icon  := ROM_rightBitmap;	// kinda small but ok for NOS 2.0	thisView.ricon := ROM_upBitmap;		// rotate right in vsfendtopBigScroll :=    {viewBounds: {left: -16, top: 18, right: 2, bottom: 30},     buttonClickScript:       func()	// ***       AddDeferredSend(vc, 'SetOriginRel, [dx, dy, NO_DELAY]),     viewJustify: 38,     viewFormat: 67109377,     dx: /*int*/ 0,     dy: /*int*/ -1,     viewSetupFormScript:       func()	// ***       begin       	local /*boolean*/ expanded := options.minUI = kExpanded;       	viewFlags := _proto.viewFlags;       	if not expanded       	then viewFlags := Band(viewFlags, Bnot(vVisible)); //Bor(viewFlags, vVisible);       	if nos21 and ricon and expanded       	then icon := OffsetShape(MungeShape(MakeShape(ricon), 'rotateRight, nil),-3,3);       		//icon := MungeBitmap(DeepClone(icon), 'rotateLeft, nil);	// doesn't seem to work              	inherited:?viewSetupFormScript();       end,     _proto: @198 /* protoPictureButton */    };AddStepForm(vncview, topBigScroll);// After Script for topBigScrollthisView := topBigScroll;begin	thisView.icon := ROM_upBitmap;	thisView.ricon := NIL;	// so vsf can be sharedend// Before Script for TBslider/*no built-in/documented vertical slider.this is based on a DTS protoVerticalSlider example- changed orientation to top-to-bottom;- added true gray fill;- tweaked coords slightly to more closely match horiz slider -- need moreassumption for this (and LRslider) that maxValue = imgHeight-viewHeight (imgWidth-viewWidth). see changedSlider/trackSlider*/TBslider :=    {     changedSlider:       func()	// ***       begin	// same as trackSlider except delay       	local int val := viewValue - Band(viewValue,0xF), x, y;       	if (direction = 'x)       	then x := val       	else // if (direction = 'y) then       		 y := val;       	vc:setOrigin(x, y, nil, NO_DELAY);	// use relative version to do bounds checking       end,     viewBounds: {left: -13, top: 30, right: -1, bottom: -34},     viewValue: 0,     viewJustify: 224,     viewFlags: 547,     viewFormat: 1,     maxValue: /*int*/ 100,     minValue: /*int*/ 0,     viewClickScript:       /*boolean*/ func(unit)       begin       	if nos21					// for 2.1?. use kShowBusyBoxFunc for 2.x?       	then BusyBoxControl(0);		// turn off the busy-indicator       	InkOff(unit);				// and don't display ink              	// cache some values for more speed       	local /*frame*/ box := :GlobalBox();       	local int y, val, top := box.top;       	local int width := box.right - box.left, height := box.bottom - top;       	local int min := minValue, max := maxValue;       		       	// keep looping in here until the user releases the pen       	while not StrokeDone(unit)       	do begin       		y := GetPoint(finalY, unit) - top;	// get the Y coordinate of the pen in local coords       		val :=       			if y < 0        			then min       			else if y > height       			then max       			else min + Floor((y/height) * (max-min));       //if (DEBUG) then Print([y, val]);              		// only redraw if things have changed       		if val <> viewValue       		then begin       			viewValue := val;       			:DoDrawing('viewDrawScript, nil);       			end;       		self:?TrackSlider();       		Sleep(SLIDER_CLICK_DELAY);						// this helps out battery life considerably       		end;       	self:?ChangedSlider();       	TRUE;	// this handled the click.       end,     viewDrawScript:       DefineGlobalConstant('kWhiteSliderStyle, {fillPattern: vfWhite,  penSize: 0, penPattern: vfNone});       DefineGlobalConstant('kFillSliderStyle,	 {fillPattern: vfBlack,  penSize: 0, penPattern: vfNone});       DefineGlobalConstant('kKnobSliderStyle,  {fillPattern: vfWhite,  penSize: [2,1], penPattern: vfBlack});       DefineGlobalConstant('kGraySliderStyle,	 {fillPattern: kRGB_Gray5, penPattern: vfNone});       constant edge := 2;	// amount the knob overlaps the line              func()       begin       	local int max := maxValue, min := minValue, val := viewValue;       	if min >= max then return;	// alternatively, throwing might be a good reaction       	       	if val < min       	then val := min       	else if val > max       	then val := max;              	local/*frame*/ bnds := :LocalBox();			// cache these values for speed       	local int right := bnds.right, top := bnds.top, bottom := bnds.bottom;       	local int width := Band(right-1, 0x0FFFE);	// make sure it's an even number       	local int middle := width div 2;       	local int pos := top + Floor((((val-min) / (max-min)) * (bottom - width -2)));       //if (DEBUG) then Print([bnds, pos]);              	:DrawShape([         		// erase the side bars       		kWhiteSliderStyle,       		MakeRect(0, 0, edge, bottom),       		MakeRect(width-edge, 0, right, bottom),              		// draw the black part (indicating value)       		kFillSliderStyle,       		MakeRect(edge, 0, width+1-edge, pos + middle),              		// draw the grey part (indicating possibility of value)       		if nos21 then kGraySliderStyle else {fillPattern: vfLtGray, penPattern: vfNone},       			//{fillPattern: SetClass("\uAA005500AA005500", 'pattern), penSize: 1, penPattern: vfWhite};       		MakeRect(edge, pos + middle, width-edge, bottom),       		       		// draw the knob       		kKnobSliderStyle,       		MakePolygon([       			middle, pos,       			width,  pos + middle,        			middle, pos + width,        			0,      pos + middle,        			middle, pos]),       		], nil);       end,     trackSlider:       func()	// ***       begin       	//PlaySound(ROM_ratchetSound);	// same as protoSlider._sound. see setOrigin       	local int val := viewValue - Band(viewValue,0xF), x, y;       	if (direction = 'x)       	then x := val       	else // if (direction = 'y) then       		 y := val;       	vc:setOrigin(x, y, nil, SLIDER_DELAY);       end,     direction: /*symbol*/ 'y,     viewSetupFormScript:       func()	// ***       begin       	viewFlags := _proto.viewFlags;       	if options.minUI <> kExpanded       	then viewFlags := Band(viewFlags, Bnot(vVisible)); //Bor(viewFlags, vVisible);       	//inherited:?viewSetupFormScript();       end,     viewClass: 74 /* clView */    };AddStepForm(vncview, TBslider);StepDeclare(vncview, TBslider, 'TBslider);bottomBigScroll :=    {viewBounds: {left: -16, top: -34, right: 2, bottom: -22},     buttonClickScript:       func()	// ***       AddDeferredSend(vc, 'SetOriginRel, [dx, dy, NO_DELAY]),     viewJustify: 166,     viewFormat: 67109377,     dx: /*int*/ 0,     dy: /*int*/ 1,     viewSetupFormScript:       func()	// ***       begin       	local /*boolean*/ expanded := options.minUI = kExpanded;       	viewFlags := _proto.viewFlags;       	if not expanded       	then viewFlags := Band(viewFlags, Bnot(vVisible)); //Bor(viewFlags, vVisible);       	if nos21 and ricon and expanded       	then icon := OffsetShape(MungeShape(MakeShape(ricon), 'rotateRight, nil),-3,3);       		//icon := MungeBitmap(DeepClone(icon), 'rotateLeft, nil);	// doesn't seem to work              	inherited:?viewSetupFormScript();       end,     _proto: @198 /* protoPictureButton */    };AddStepForm(vncview, bottomBigScroll);// After Script for bottomBigScrollthisView := bottomBigScroll;begin	thisView.icon := ROM_downBitmap;	thisView.ricon := NIL;	// so vsf can be sharedend// Before Script for vc/*potential (documented) soundsROM_addSound		action: PasteROM_alarmwakeup			"chime"ROM_bootsound		action: ctrl-alt-DelROM_click				silent?ROM_copier			action: CopyROM_crumpleROM_cuckooSound			3 beepsROM_dialtones[0-15]ROM_drawerclose		optionsFrame: CompactROM_draweropen		optionsFrame: ExpandROM_flip			setOrigin (final scroll)ROM_funbeep				...ROM_hilitesound			silent?ROM_plinkbeep			"ding"ROM_plunk			viewGestureScript: doubletap ???ROM_poof			viewGestureScript: scrubROM_ratchetSound	setOrigin (incremental scroll)ROM_removeSound		action: CutROM_simplebeep		rfb: BellROM_soundoff	.alerterBeep		"notify"	.bizarreBeep		"reverb"	.clickBeep		viewGestureScript: tap	.funBeep			(=ROM_funBeep)	.gongBeep		rfb: error	.oneBeep			"woodpecker"	.pleasantBeep		"3 chimes"	.plinkBeep		(=ROM_plinkBeep)	.simpleBeep		(=ROM_simplebeep)	.twoBeep			"whoop"	.wakeupBeep		(=ROM_wakeupbeep)	.whackyBeep			"alien(long)"	.wildBeep			"pffft"	.wilderBeep		viewGestureScript: move	.wildestBeep	viewGestureScript: move	.zapBeep			"bird?"ROM_tickSoundROM_tockSound		viewGestureScript: caret (right click)ROM_typewriter		(=protoKeypad.keySound)ROM_wakeupbeep		(=ROM_bootsound)// undoc@372					"adding machine?"*/vc :=    {overviewBitmap: /*frame*/ nil,     viewWidth: /*int*/ nil,     writeMouse:       /*boolean*/ func(int modifiers, int but1, int x1, int y1, int but2, int x2, int y2, /*string*/ msg, sound, int delay)       begin       	rfb:?writePointerEvent(modifiers, but1, x1, y1, but2, x2, y2);       	if delay       	then :refresh(INCR_REFRESH, delay, nil);	// incremental,immed(except 1st doubletap, first move), full screen       	if msg       	then :status(msg, nil, NO_LOG);       	if sound       	then PlaySound(sound);       	TRUE;       end,     localBounds:       /*Area*/ nil	// coords of local screenBitmap = ShapeBounds(screenBitmap). set by :setSize       ,     viewFormat: 257,     viewgesturescript:       /*boolean*/ func(unit, int gestureKind)	// Return true if gesture has been completely handled, nil otherwise       if not server       then begin       	local /*frame*/ gb := :GlobalBox();       	local int left := gb.left, top := gb.top;       	local int x1 := GetPoint(firstX,unit) - left;       	local int y1 := GetPoint(firstY,unit) - top;       	local int x2 := GetPoint(finalX,unit) - left;          	local int y2 := GetPoint(finalY,unit) - top;              	if icon = overviewBitmap	// displaying overview right now?       	then begin       		SetValue(self, 'icon, screenBitmap);	// switch back       		RefreshViews();							// avoid problem with refresh after interim copyRect       		if gestureKind = aeHilite or gestureKind = aeLine       		then :SetOriginRel(RIntToL((x2 - x1) * overviewScale), RIntToL((y2 - y1) * overviewScale), NO_DELAY);       		return TRUE;       		end;              	if not IsPtInRect(x1,y1,localBounds) or not IsPtInRect(x2,y2,localBounds)       	then return NIL;              	// translate to remote coordinates       	x1 := x1 + viewOriginX;       	y1 := y1 + viewOriginY;       	x2 := x2 + viewOriginX;       	y2 := y2 + viewOriginY;              	local /*string*/ coords1 := $: & x1 & $, & y1; // coords2 := x2 & $, & y2;       	if gestureKind = aeTap // tap: treat as pen down&up       	then begin       		:writeMouse(kNoModifiers, kBut1, x1, y1, kButOff, x1, y1, LocObj("left-click", 'leftClick) & coords1,       			ROM_soundOff.clickBeep, DOUBLE_CLICK_DELAY);	// allow time before update requested (in case doubletap immed follows)       		SetKeyView(paraView, 0);       		end              	else if gestureKind = aeDoubleTap       	then begin       		:writeMouse(kNoModifiers, kBut1, x1, y1, kButOff, x1, y1, NO_MSG, NO_SOUND, NO_REFRESH);       		:writeMouse(kNoModifiers, kBut1, x1, y1, kButOff, x1, y1, LocObj("double-click", 'doubleClick) & coords1,       			ROM_plunk, NO_DELAY);       		end              	else if gestureKind = aeLine 	// line: treat as remote 'drag'       	then begin       		:writeMouse(kNoModifiers, kBut1, x1, y1, kButNone, nil, nil,       			(LocObj("move", 'move) & coords1 & "->" & x2 & $, & y2),       			ROM_soundOff.(if x2 < x1 then 'wilderBeep else 'wildestBeep), NO_REFRESH);       		if MOVE_DELAY then Sleep(MOVE_DELAY);       		:writeMouse(kNoModifiers, kBut1, x2, y2, kButOff, x2, y2, NO_MSG, NO_SOUND, NO_DELAY);       		end       		       	else if gestureKind = aeCaret  // caret: treat as 'right click'       	then begin       //if (DEBUG) then Print("right-tap" & coords1 & $; & x2 & $, & y2);       		local int but := options.rightClick;       		:writeMouse(if but=kBut1 then kControlModifier else kNoModifiers, but, x1, y1, kButOff, x1, y1,       			(LocObj("right-click",'rightClick) & coords1),       			ROM_tockSound, NO_DELAY); 	//??ROM_soundOff.twoBeep, ROM_hiliteSound, ROM_draweropen       		end              	else if gestureKind = aeHilite	// hilite/drag -- trapped by paraView! ??  check options.noHWR       	then begin       //if (DEBUG) then Print("gesture: hilite");       		:SetOriginRel(x1 - x2, y1 - y2, NO_DELAY);       		end              	else if gestureKind = aeScrub    // scrub (send 'delete')          then begin       //if (DEBUG) then Print("gesture: scrub");       		paraView:writeKey(chBS, kNoModifiers, nil, nil, LocObj("gest",'gest), ROM_poof);	// status, refresh, sound & TRUE       		end       	       	else return NIL;              	TRUE;       end,     fillRectA:       func(/*Area*/ curArea)       begin       if PROFILE then vc:testFreq('fillRectA, 1);              	local int gray := :setColor(curArea.color);              	// clip, translate       	local int x := curArea.left, y := curArea.top;       	if IsPtInRect(x, y, remoteBounds)       	then begin       		screenPixels := screenPixels + curArea:area();       		call VNCNative.FFillRect2 with (       			screenBitmap.data, gray,       			x - viewOriginX, y - viewOriginY, curArea.width, curArea.height);       		end;       end,     imgHeight:       /*int*/ nil		// remove screen ht; set when connected       ,     viewDrawScript:       func()		// unused. removed in afterScript since clPictureView has its own       begin       //if (DEBUG) then begin Write("viewDrawScript: "); Print(:GetDrawBox()); end;       	if screenBitmap       	then :DrawShape(screenBitmap, BM_STYLE);	// :DoDrawing only needed outside viewDrawScript       end,     viewHeight:       /*int*/ nil		// local screen ht; via :setSize       ,     viewFlags: 2593,     connected:       func(int wid, int ht)       begin       	// this done automatically by rfbProto (since params are set)       	//int bitsPerPixel, int depth, /*boolean*/ bigEndian, /*boolean*/ trueColour,       	//int redMax, int greenMax, int blueMax, int redShift, int greenShift, int blueShift       	//rfb:writeSetPixelFormat(8, 8, 0, 1, 7, 7, 3, 0, 3, 6);              	if ADD_SERVER and server       	then begin       		v:hide();       		v:installRefreshPatch(true, GetRoot(), nil);       		refreshAccept := DONE_REFRESH;	// idle and incrUpdates enabled only after (first/any) FULL_REFRESH              		lastBacklight := nil;       		colorMap := colorMap0;	// assume backlight off (adjust in viewIdleScript)              	// wait for refresh request from viewer       		end                 else begin          		if ADD_SERVER then refreshAccept := NO_REFRESH;	// block v.viewDrawScript etc.        		SetValue(LRslider, 'maxValue, (imgWidth := wid) - viewWidth);       		SetValue(TBslider, 'maxValue, (imgHeight := ht) - viewHeight);           	:Refresh(FULL_REFRESH, NO_DELAY, nil);	// full,immed refresh from server           	end;       end,     viewIdleScript:       /*int*/ func()       begin       	// only if no refresh in progress       	if refreshAccept and refreshAccept <> HOLD_REFRESH and rfb:?isOpen() // and refreshAccept = DONE_REFRESH       	then begin       	v:installRefreshPatch(true, GetRoot(), incrUpdates);	// patch any new apps, plus refresh them              	local array BL := Gestalt(kGestaltArg_HasBackLight);       	if BL and BL[0] and BackLightStatus() <> lastBacklight       	then begin       		lastBacklight := not lastBacklight;       		colorMap := if lastBacklight then colorMapBL else colorMap0;       		incrUpdates := [localBounds]; 	// do complete refresh       		end;              	if Length(incrUpdates) > 0       	then begin       //if DEBUG then Print(['viewIdleScript, Length(incrUpdates)]);       		refreshAccept := HOLD_REFRESH;	// block other idle updates until this one is done       		local /*frame*/ rect := incrUpdates[0];       		ArrayRemoveCount(incrUpdates,0,1);       		AddProcrastinatedSend(kAppSymbol, rfb, 'SendUpdateRect, [rect], NO_DELAY);	// see Refresh(full)       		if TIMING       		then prevT := ticks();	// start timing (end in Refresh(REFRESH_DONE)       		end              	// if no display updates, then has local clipboard changed?       	else if nos21       	then begin       		local /*string*/ text, oldText := clipboard.selection;       		local /*frame*/ clip := GetClipboard();       		if not clip and StrFilled(oldText)       		then text := ""       		else if clip       		then begin       			local array types;       			local int i, pos;       			foreach i,types in clip.types       			do  if (pos := SetContains(types, 'text))       				then begin       					text := clip.data[i][pos].text;       					if IsString(oldText) and IsString(text) and StrEqual(oldText, text)       					then text := nil;       					break;       					end;       			end;       		if IsString(text)       		then begin       if DEBUG then Print(['viewIdleScript, 'cut, text]);       			AddProcrastinatedSend(kAppSymbol, rfb, 'SendCutText, [clipboard.selection := text], NO_DELAY);       			end;       		end;       	end;              	// check again sooner if there are more updates       	if Length(incrUpdates) > 0 then IMMED_REFRESH else (options.refresh * 1000);       end,     copyRect:       func(int sx, int sy, /*frame*/ dbnds)       begin       	local int dx := dbnds.left, dy := dbnds.top, w := dbnds.right - dx, h := dbnds.bottom - dy;       if (DEBUG) then Print("copyRect [" & sx & $, & sy & "]: " & dx & $, & dy & $, & w & $, & h);       if PROFILE then vc:testFreq('copyRect, 1);              	if (dx=sx and dy=sy)       	then return;              	dx := dx - viewOriginX;       	dy := dy - viewOriginY;       	if (dx >= viewWidth or dy >= viewHeight)	// IsPtInRect except ok if dx,dy < origin (clipped)       	then return;              	sx := sx - viewOriginX;		// ?? assume these are in range       	sy := sy - viewOriginY;       	w := min(w, viewWidth -dx);	// copy only as much as necessary       	h := min(h, viewHeight-dy);       	screenPixels := screenPixels + (w*h);              	// :viewIntoBitmap works if there's no overlap in source & dest              	dbnds := RelBounds(dx,dy,w,h);       	local /*frame*/ sbnds := RelBounds(sx,sy,w,h);       	if not RectsOverlap(sbnds,dbnds) // probably only small bitmap moved larger distance       	then :ViewIntoBitmap(sbnds, dbnds, screenBitmap)              	// if there is overlap, general approach is to copy either from top-to-bottom or bottom-to-top       	// some row(s) go a temporary buffer, then back to screenBitmap               	else begin       		// copy using DrawIntoBitmap into small stripes to avoid VBOs       		local style := Clone(BM_STYLE);       		local int bpp := options.bpp, bmht := min(h, abs(dy-sy));       		if bmht=0 or bmht>16       		then bmht := 16;       		local int hinc := bmht;	//+       		if sy < dy       		then begin       			// need to copy from bottom-to-top to avoid overlap problems       			dy := dy+h-bmht;       			sy := sy+h-bmht;       			hinc := -bmht;		//-       			end;       		// otherwise, top-to-bottom (ok if no change in y)       		       		local /*byte*/ bm := MakeBitmap(w, bmht, {depth: bpp});       		loop begin       			style.transform := [-sx,-sy];	//[srcBnds, tmpBnds];       			DrawIntoBitmap(screenBitmap, style, bm);       			style.transform := [dx,dy];		//[tmpBnds, dstBnds];       			// now draw it back into regular bitmap       			DrawIntoBitmap(bm, style, screenBitmap);       			if (h := h - bmht) <= 0       			then break;              			if h < bmht       			then begin // remainder strip       				hinc := (bmht := h) * Signum(hinc);       				bm := MakeBitmap(w, bmht := h, {depth: bpp});       				end;       			sy := sy + hinc;       			dy := dy + hinc;       			end;       		end;       end,     curColor: /*int:0-255*/ 0,     viewBounds: {left: 0, top: 16, right: -16, bottom: -16},     bitmapToRaw:       /*int*/ func (/*byte[]*/ pixels, int poffset, /*Area*/ sbnds)       begin       	// drawRawRect in reverse (sort of)       	// assumes x,w even; dimensions clipped. bpp=4 (i.e., uses _BPP, _PPB)              	local int w := sbnds.width, h := sbnds.height;       	       	local /*frame*/ bitmap := MakeBitmap(w, h, {depth: _BPP});       	// evidently, ViewIntoBitmap uses modeOr rather than modeCopy ?? (e.g., errors w/ monthview)       	// so if we did reuse bitmap (assuming compatible size), it would have to be erased first! (about same performance as alloc new)       	//DrawIntoBitmap(MakeShape(dbnds), BM_STYLE, bitmap);       		       	local /*byte[]*/ data := bitmap.data;       	local int rowBytes := ExtractWord(data, 4); // bytes alloc per row of Newton bitmap       	local int boffset  := BITMAP_OFFSET, gray12, i, j, sameColor := -1, color;              	i := refreshAccept;				// save       	refreshAccept := NO_REFRESH;	// block kRefreshPatch (see v.Refresh)       	GetRoot():ViewIntoBitmap(sbnds, SetBounds(0,0,w,h), bitmap);	// get bitmap from current screen       	refreshAccept := i;				// restore       	// ??? if GetCaretBox is in current rect; if so, add inverted rectangle or bitmap(?); overlap straddling boundaries?       	// ??? if GetHiliteOffsets (owner) is in current rect, invert text range (StrFontWidth; see what NC does to calc 1.x ranges)              	for i:=0 to h-1       	do begin       		for j:=0 to w-1 by _PPB       		do begin       			gray12 := ExtractByte(data, boffset + (j div _PPB));       			color := if COLOR_MAP       				then gray12 >> 4       				else colorMap[gray12 >> 4];       			StuffByte(pixels, poffset, 	color);       			if sameColor and sameColor <> color       			then sameColor := if sameColor<0 then color else nil;	// 1st time init              			color := if COLOR_MAP       				then Band(gray12,0xF)       				else colorMap[Band(gray12,0xF)];       			StuffByte(pixels, poffset+1, color);       			if sameColor and sameColor <> color       			then sameColor := nil;       			poffset := poffset + _PPB;       			end;       		boffset := boffset + rowBytes;       		end;              	sameColor;       end,     testFreq:       func(/*symbol*/ sym, int inc)       if PROFILE       then begin       	if not testFreqFrame       	then testFreqFrame := {};              	testFreqFrame.(sym) :=       		if HasSlot(testFreqFrame, sym)       		then testFreqFrame.(sym) + inc       		else inc;       end,     testRect:       func(/*symbol*/ sym, int w, int h)       if PROFILE and w >=0 and h >= 0       then begin       	local int len := 32;       	local array testRectArray := self.(sym);       	if not testRectArray       	then begin       		self.(sym) := testRectArray := Array(len+1,0);       		local int i;       		for i:=1 to len       		do testRectArray[i] := Array(len+1,0);       		end;       	if (w > len) or (h > len)       	then testRectArray[0] 	 := testRectArray[0] + 1;       	else testRectArray[w][h] := testRectArray[w][h]+1;       end,     overviewScale: /*float*/ nil,     viewOriginY: 0,     viewOverviewScript:       func()       //:setOrigin(0,0, nil, NO_DELAY);       if overviewBitmap       then begin       	SetValue(self, 'icon, overviewBitmap);       	RefreshViews();       	// temporarily draw a couple of rects on top       	:DrawShape(MakeShape(ShapeBounds(overviewBitmap)),  '{penSize: 1});	// stick a frame around entire overview       	:DrawShape(MakeShape(overviewBounds), 				'{penSize: 2});	// higlight current view       	end,     setSize:       func(/*boolean*/ isOpen)       begin       	local int dim := options.displaySize;       	if dim < kFullSize       	then begin       		viewWidth  := SCREEN_SIZE_X[dim];       		viewHeight := SCREEN_SIZE_Y[dim];       		end       	else begin       		local /*frame*/ bnds :=       			if ADD_SERVER and server       			then if dim = kFullSize       				then GetAppParams().appAreaBounds	// app area (w/o buttonbar)       				else GetRoot():LocalBox();			// entire screen       			else :LocalBox();						// space for Compact,Expanded controls. same as appAreaBounds for kCompactFloat           	viewWidth  := bnds.right;           	viewHeight := bnds.bottom;           	end;                	if not isOpen       	then v:setTitle(titleLabel & $; && viewWidth & $x & viewHeight);              	localBounds  := RelBounds(0,0, viewWidth, viewHeight);       	remoteBounds := RelBounds(viewOriginX, viewOriginY, viewWidth, viewHeight);              	icon := screenBitmap := nil;       	if not server       	then begin       		SetValue(LRslider, 'maxValue, imgWidth -viewWidth);       		SetValue(TBslider, 'maxValue, imgHeight-viewHeight);              		if isOpen       		then begin       			screenPixels := 0;       			icon := screenBitmap := MakeBitmap(viewWidth, viewHeight, {depth: options.bpp, store: GetDefaultStore()});              			:setOverviewBitmap(options.overview, nil);                  		:refresh(FULL_REFRESH, NO_DELAY, nil);	// full,immed refresh           		end;           	end;       end,     viewJustify: 240,     setColor:       /*int*/ func(int pixel /*0-255*/)       begin       //if (DEBUG) then Print("setColor: " & pixel);       	if pixel       	then curColor := pixel;       	// otherwise continue using same curColor       	       	local int /*0-15*/ gray := ExtractByte(grayMap, curColor), bpp := options.bpp;              	// now, convert for bpp       	return       		if bpp=4 then gray	// 0-15       		else if bpp=2       		then gray div 4		// 0-3       		else /*if bpp=1 then*/       			//floor( round( gray * 5 / 16 ) )       			(gray+2) div 4; // 0-4       end,     overviewBounds:       /*Area*/ nil	// coords of current remote screen(remoteBounds) scaled into overviewBitmap. set in setOverviewBitmap. used in setGauge, viewOverviewScript       ,     SetOrigin:       func(int x, int y, /*string*/ msg, int wait)       if not server       then begin       	if  not x       	then x := viewOriginX;	// e.g., from sliders       	if not y       	then y := viewOriginY;              	:status(LocObj("scroll", 'scroll), x & $, & y & msg, NO_LOG);       	if wait > 0	// wait in ticks       	then begin // e.g., from 2Dscroller, or viewUp/Down or slider. just update coords/sound       		RefreshViews();	// for status       		PlaySound(ROM_ratchetSound);       		return Sleep(wait);       		end;              if (DEBUG) then Print("SetOrigin: " & x & $, & y & "(prev: " & viewOriginX & $, & viewOriginY & $));       	// for scrolls in a single direction, less than full screen width/height       	// shift local bitmap and request only the new part       	local array cargs;       	local /*frame*/ rrect;       	local int rorg, dim, sorg, dorg;       	if x = viewOriginX       	then if y = viewOriginY       		then return nil;	// no change              		else begin	// x same. y different       			dim := viewOriginY-y;       			if dim > 0 // (y < viewOriginY)       			then begin	// shift down, update on top       				rorg := y;       				sorg := viewOriginY;       				dorg := viewOriginY + dim;       				end       			else begin	// shift up, update on bottom       				dim := -dim;       				rorg := remoteBounds.bottom;	// - dim       				sorg := y;       				dorg := viewOriginY;       				end;       			if dim < viewHeight       			then begin	       				cargs := [viewOriginX,sorg,											// sx,sy       						 RelBounds(viewOriginX,dorg, viewWidth,viewHeight-dim)];  	// dx,dy, w,h       				rrect := RelBounds(viewOriginX,rorg, viewWidth,dim); 				// server update rect       				end;       			// else all refreshed       			end;       	else if y = viewOriginY       	then begin // y same. x different (if y is different also, don't try to handle 3 pieces)       			dim := viewOriginX-x;        			if dim > 0	//(x < viewOriginX)       			then begin	// shift right, update on left       				rorg := x;       				sorg := viewOriginX;       				dorg := viewOriginX + dim;       				end       			else begin	// shift left, update on right       				dim  := -dim;       				rorg := remoteBounds.right;	// - dim       				sorg := x;       				dorg := viewOriginX;       				end;       			if dim < viewWidth       			then begin	       				cargs := [sorg,viewOriginY,											// sx,sy,       						 RelBounds(dorg,viewOriginY, viewWidth-dim,viewHeight)];	// dx,dy, w,h       				rrect := RelBounds(rorg,viewOriginY, dim,		   viewHeight); 	// server update rect       				end;       			// else all refreshed       			end;              if DEBUG then Print(['SetOrigin, rrect, cargs]);       	if cargs       	then Perform(self, 'copyRect, cargs);	// refresh below will get only new strip (rrect)              	// now, update coords (cargs, rrect used previous coords)       	remoteBounds := RelBounds((viewOriginX := x), (viewOriginY := y), viewWidth, viewHeight);              	SetValue(LRslider, 'viewValue, x);       	SetValue(TBslider, 'viewValue, y);       	PlaySound(ROM_flip);               	if rfb:?isOpen()           then return :Refresh(FULL_REFRESH, NO_DELAY, rrect);	// full,immed refresh, possibly only new portions       end,     Refresh:       func(refresh, int msec, /*frame*/ rect)       if rfb:?isOpen()       then begin       	if ADD_SERVER and server       	then begin       		if refresh = DONE_REFRESH	// after prev update (output) finished       		then begin       			if TIMING and prevT       			then begin       				Print("ticks:" && (ticks() - prevT) & "; bytesW:" && if rfb then rfb.bytesW);       				prevT := nil;       				end;       			return refreshAccept := DONE_REFRESH;       			end       		else if refresh = IMMED_REFRESH	// after click       		then return :SetupIdle(IMMED_REFRESH);              		if refreshAccept = NO_REFRESH	// this shouldn't have happened... (blocked in v.Refresh via e.g., viewDrawScript)       		then return;              		// clip to current Display Size       		if rect.left < 0       		then rect.left := 0;       		if rect.top  < 0       		then rect.top  := 0;       		if rect.right  > localBounds.right       		then rect.right  := localBounds.right;       		if rect.bottom > localBounds.bottom       		then rect.bottom := localBounds.bottom;       		if (rect.right - rect.left) <= 0 or (rect.bottom - rect.top) <= 0	// empty?       		then return;              		if refresh = FULL_REFRESH       		then begin       if DEBUG then Print(['Refresh, "full", msec, rect]);       			:SetupIdle(IMMED_REFRESH);       			if not incrUpdates or :RectEqual(rect, localBounds)       			then return incrUpdates := [rect];		// reset updates list       			// else if partial (not full screen) then just add to list below        			end;              		if incrUpdates //and refresh = INCR_REFRESH and not :RectEqual(rect, localBounds)       		then begin       			local /*frame*/ lastRect, isect;       			local int i;       			for i := Length(incrUpdates)-1 to 0 by -1       			do begin       				lastRect := incrUpdates[i];       				isect := SectRect(rect, lastRect);       				if :RectEqual(rect, isect)       				then begin       if DEBUG then Print(['Refresh, "skipping incr contained in prev rect", msec, rect]);       					return;	// rect is already contained in lastRect       					end       				else if :RectEqual(lastRect, isect)       				then begin       if DEBUG then Print(['Refresh, "removing prev", lastRect]);       					ArrayRemoveCount(incrUpdates, i, 1);	// lastRect contained in rect. remove       					end;       				end;       				       			AddArraySlot(incrUpdates, rect);       if DEBUG then Print(['Refresh, "adding incr", Length(incrUpdates), msec, rect]);       			end;       		// refresh via viewIdleScript       		end       			       	else AddProcrastinatedSend(kAppSymbol, rfb, 'SendUpdateRequest, [if rect then rect else remoteBounds, refresh],       			if msec then msec else options.refresh * 1000);	// refresh in sec       	end,     disconnected:       func()       begin       	if ADD_SERVER and server       	then begin       		incrUpdates := refreshAccept := nil;       		:setupIdle(0);       		v:installRefreshPatch(nil, nil, nil);       		end       	else vc:setGauge(1);       end,     viewSetupFormScript:       func()       begin       	// simplest if each screen dim is multiple of 16 (avoid clipping problems)       	// probably need to adjust y for portrait, x for landscape       	viewBounds := Clone(_proto.viewBounds);       	local int minUI := options.minUI;       	if minUI <> kExpanded       	then begin       		viewBounds.right := 0;       		if minUI = kCompactTop or minUI = kCompactFloat       		then viewBounds.bottom := 0;       		if minUI = kCompactBot or minUI = kCompactFloat       		then viewBounds.top := 0;       		end;              	local pbounds := v:LocalBox();       	local int dim := Band(pbounds.bottom, 0xF);       	if dim <> 0        	then begin       		//viewBounds.top    := viewBounds.top    + dim2;       		viewBounds.bottom := viewBounds.bottom - dim;       		end;       	dim := Band(pbounds.right,0xF);       	if dim <> 0        	then begin       		//viewBounds.left  := viewBounds.left  + dim2;       		viewBounds.right := viewBounds.right - dim;       		end;              	if reorienting       	then begin       		if screenBitmap and options.displaySize < kFullSize	// current display still valid       		then return;       		// otherwise, generate a full size display (but skipping other init)       		end       	else begin       		viewOriginX := viewOriginY := 0;           	imgWidth := 1024; imgHeight := 768; 	// initially -- see connected, setOrigin       		end;       	       	:setSize(rfb:?isOpen());              	//SetKeyView(paraView,0);	// authenticator usually opens anyway              	//inherited:?viewSetupFormScript();       end,     screenPixels:       /*int*/ 0	// modification count (in copyRect, fillRect, fillRect2, drawRawRect) for VBO flush (in setGauge)       ,     viewClass: 74 /* clView */,     overviewPixels: /*int*/ 0,     setOverviewBitmap:       func(/*boolean*/ create, /*boolean*/ copy) // used by :setSize, Prefs       begin       	overviewBitmap := nil;       	if not create then return;              	local /*frame*/ bnds := :LocalBox();       	overviewScale := max(imgWidth / bnds.right, imgHeight / bnds.bottom);       	overviewBitmap := MakeBitmap(       		//imgWidth div overviewScale, imgHeight div overviewScale,       		RIntToL(0.5 + (imgWidth / overviewScale)), RintToL(0.5 + (imgHeight / overviewScale)),       		{depth: options.bpp, store: GetDefaultStore()});       	overviewPixels := 0;              	overviewBounds := Area:new(       		RIntToL(0.5 + (viewOriginX	/ overviewScale)),       		RIntToL(0.5 + (viewOriginY	/ overviewScale)),       		RIntToL(0.5 + (viewWidth	/ overviewScale)),       		RIntToL(0.5 + (viewHeight	/ overviewScale)));              	if not copy then return;              	overviewPixels := overviewBounds:area();              	DrawIntoBitmap(       		screenBitmap,       		{transferMode: modeCopy, penPattern: vfNone, transform: [localBounds, overviewBounds]},       		overviewBitmap);              	// see :setGauge, :SetOrigin, :viewGestureScript, :viewOverviewsScript       end,     fillRect2:       func (int gray, int x, int y, int w, int h)	// UNUSED -- FFillRect2 called directly.  x,y already translated; w,h already 'clipped'       begin       if PROFILE then vc:testFreq('fillRect2, 1);       if PROFILE then vc:testRect('testRectArray0, w,h);	// before       //if DEBUG then Print(['fillRect2, gray, x, y, w, h]);                     	// VNCNative-20011101-1126 clips w,h       /*       	w := min(w, viewWidth-x);       	h := min(h, viewHeight-y);       	if w=0 or h=0       	then return;       */       	screenPixels := screenPixels + (w*h);              	// gray: bpp=4: 0-15; bpp=2: 0-3; bpp=1: 0-4?              if PROFILE then vc:testRect('testRectArray1, w,h);	// after       //if DEBUG then Print(['fillRect2, gray, x, y, w, h]);              	if FILL_RECT       	then begin       		// 3.3a6 VERSION uses VNCNative-20011029-1652-FFillRect2. see also fillStyles(afterScript)       		// INLINE this where :fillRect2 is used, with w,h checking ??       		call VNCNative.FFillRect2 with (screenBitmap.data, gray, x, y, w, h)		// courtesy of Paul Guyot              /*       		// 3.3a5 VERSION uses VNCNative-20011028-2220-FFillRect2 for bpp=2,4; MakeRect for bpp=1       		local int bpp := options.bpp;	// check :setColor       		if bpp <> 1 then // or (w=1 and h=1 and (gray := if gray >= 2 then 1 else 0)) then       		//if options.bpp=1 then gray := if gray >= 2 then 1 else 0;       			call VNCNative.FFillRect2 with (screenBitmap.data, gray, x, y, w, h)		// courtesy of Paul Guyot       		else DrawIntoBitmap(MakeRect(x, y, x+w, y+h), fillStyles[bpp][gray], screenBitmap);       */       		end       	       	else begin       		local /*byte[]*/ data := screenBitmap.data;       		local int bpp := options.bpp, ppb;       		if w=1 and h=1       		then begin       // FSetPixel version       			if bpp=1 then gray := if gray >= 2 then 1 else 0;       			call VNCNative.FSetPixel with (data, x, y, gray);			// courtesy of Paul Guyot       /*       // NS version: SetPixel       			// see below: rowBytes, fill, offset       			local int shift := 8 - (bpp * (xpos+1));       			if bpp=1       			then gray := if gray >= 2 then 1 << shift else 0	// threshhold; was 0-4. see :setColor       			else if gray <> 0 and shift <> 0					// test slower than just doing it?       			then gray := gray << shift;              			local int mask := ((1 << bpp) - 1) << shift;	// mask: bpp=1->0x1, 2->0x3, 4->0xF (shifted)       			fill := ExtractByte(data, offset);       			if Band(fill, mask) <> gray						// already set?  skip test and just do it??       			then StuffByte(data, offset, Bor(gray, Band(fill, Bnot(mask))));       */       			end                     		else if (x mod (ppb := 8 div bpp)) = 0 and (w mod ppb) = 0 and (bpp <> 1 or (gray := if gray >=2 then 1 else 0))       		then begin       // common setup: NS and BinFill2)       			local int rowBytes := ExtractWord(data, 4);	//Band(viewWidth+31, -32) div ppb; // bytes alloc per row of Newton bitmap       			local int offset  := BITMAP_OFFSET + (y * rowBytes) + (x div ppb), fill;       	       			// beginning of byte boundary, w full bytes       			// don't use for bpp=1 (except gray=0,4) since larger filled rect might look better due to bwStyles       			if gray = 0       			then fill := 0       			else if gray = (1 << bpp)-1       			then fill := 0xFF       			else begin       				fill := Bor(gray*16, gray);       				if bpp = 2       				then fill := Bor(fill, Bor(gray*64, gray*4));       				end;       /*		       // NS version: BinFill       			local row := data;       			local int roffset := 0, len := w div ppb;       			if h=1       			then roffset := offset;       			else row := MakeBinary(len, 'bytes);       			for i:=0 to len-1	// fill bitmap directly (h=1) or constant row to copy       			do StuffByte(row, roffset+i, fill);       			if h > 1       			then for i:=1 to h       				do begin       					BinaryMunger(data,offset,len, row,0,len);       					offset := offset + rowBytes;       					end;       */       // FBinFill2 version       			if h = 1 and w = ppb       			then StuffByte(data, offset, fill)       			else call VNCNative.FBinFill2 with (data, offset, w div ppb, fill, rowBytes, h); // courtesy of Paul Guyot       			end              // MakeRect       		else DrawIntoBitmap(MakeRect(x, y, x+w, y+h), fillStyles[bpp][gray], screenBitmap);       		end;       end,     viewOriginX: 0,     screenBitmap: /*frame*/ nil,     imgWidth: /*int*/ nil,     drawRawRect:       func (/*byte[]*/ pixels, /*Area*/ curArea)       begin       	local int x := curArea.left, y := curArea.top;       //if (DEBUG) then Print(['drawRawRect, curArea]);       //if (DEBUG) then call kPrintBytes with(pixels, 0, w*h, 'drawRawRect && curArea:toString());       if PROFILE then vc:testFreq('drawRawRect, 1);              if not IsPtInRect(x,y,remoteBounds)       then return if (DEBUG) then Print([rfb._inState, 'drawRawRect, "skipping", curArea]);              	//x := x - viewOriginX;	// translate here if not using :fillRect       	//y := y - viewOriginY;       	//local int w := curArea.width, h := curArea.height;              	screenPixels := screenPixels + curArea:area();	//(w*h);              	// tested: VNCNative-20011106-2249       	if DRAW_RECT //and self.testFDrawRawRect       	then call VNCNative.FDrawRawRect with (       			screenBitmap.data, [pixels, grayMap],       			x - viewOriginX, y - viewOriginY, curArea.width, curArea.height);              else begin       	local int bpp := options.bpp, i, j, poffset := 0;	//ppb := 8 div bpp       	// skip copying rows beyond bottom. need to test for w inside loop (read/skip pixel bytes)       	h := min(h, viewHeight-y);              	local /*byte[]*/ data := screenBitmap.data;       	if bpp = 4	//        	then begin // "FAST" (used only for bpp=4, i.e., _BPP=4, _PPB=2)       		// _BPP=4,2,1, _PPB=2,4,8       		// do our own clipping: h (above), wmin,wclip (below)       		local int rowBytes := ExtractWord(data, 4); //Band(viewWidth+31, -32) div _PPB; // bytes alloc per row of Newton bitmap       		local int wmin := min(w, viewWidth-x), wclip := w-wmin;       		w := wmin;              		local int boffset  := BITMAP_OFFSET + (y * rowBytes) + (x div _PPB), lgray, rgray;       		local int j1 := 1 - Band(x,0x1), j2 := w + Band(x+w, 0x1);       		// x, 	x+w		j1-j2       		// even,even: 	1 - w       		// odd,	even:	0 - w       		// even,odd:	1 - w+1       		// odd, odd:	0 - w+1       		local int rowDiff := rowBytes - ((j2-j1+(_PPB-1)) div _PPB);	// - bytes actually used in Newton bitmap       //if DEBUG then Print([boffset, j1, j2, wclip, w, rowBytes, rowDiff]);              		for i:=1 to h       		do begin       			for j:=j1 to j2 by _PPB // n=_PPB 8-byte remote pixels shrink to 1 local byte       			do begin       				if j=0       				then lgray := Band(ExtractByte(data,boffset), 0xF0);       				else begin       					lgray := ExtractByte(grayMap, ExtractByte(pixels,poffset)) * 16; //<< 4;       					poffset := poffset+1;       					end;       				if j=w       				then rgray := Band(ExtractByte(data,boffset), 0x0F)       				else begin       					rgray := ExtractByte(grayMap, ExtractByte(pixels,poffset));       					poffset := poffset+1;       					end;       				StuffByte(data, boffset, Bor(lgray, rgray));       				boffset := boffset+1;       				end;       			boffset := boffset + rowDiff;		// adjust for row padding (or other bytes in screenBitmap)       			if wclip > 0       			then poffset := poffset + wclip;	// skip any 'clipped' source bytes       			end;       		end              	else begin 	// "RELIABLE"       		local int gray;       		for i := y to y+h-1       		do begin       			for j := x to x+w-1	// need to read entire row. check viewWidth inside to avoid drawing       			do begin       				gray := :setColor(ExtractByte(pixels, poffset)); // rgb:0-255 => gray:0-15       				poffset := poffset+1;       				if j < viewWidth       				then //:fillRect2(gray, j, i, 1, 1);       					call VNCNative.FFillRect2 with (data, gray, j, i, 1, 1);       				// else "clip" (but keep reading&skipping rather than break)       				end;       			end;       		end;       	end;       end,     grayMap:       /*byte[]*/ nil	// map from color(0-255) to gray(0-15). created at build-(afterScript or run-time(vsf). used in setColor, drawRawRect       ,     fillRect:       func(int /*0-255*/ color, int x, int y, int w, int h) // used by GetSubRectsCoRREN, GetHexSubEncodingSubrectN       begin       //if (DEBUG) then Print("fillRect: " & x & $, & y & $, & w & $, & h & $; & curColor);       if PROFILE then vc:testFreq('fillRect, 1);              	// translate (bounds already checked)       	screenPixels := screenPixels + (w*h);       	call VNCNative.FFillRect2 with (screenBitmap.data, :setColor(color), x - viewOriginX, y - viewOriginY, w, h);       end,     setGauge:       func(/*real*/ fval)	// 0=begin, ..., 1=end       begin       	local int ppb := 8 div options.bpp;       	if (screenPixels div ppb) >= kVBOFlush	// not completely accurate (due to odd boundaries etc. but ok?       	then begin       //Print("screenFlush:" && screenPixels);       		screenPixels := 0;       		ClearVBOCache(screenBitmap.data);       		end;              	if TIMING and fval=0       	then prevT := ticks()	// start timing              	else if fval=1 	// update done       	then begin       		if TIMING and prevT       		then begin       			Print("ticks:" && (ticks() - prevT) & "; bytesR:" && if rfb then rfb.bytesR);       			prevT := nil;       			end;              		if overviewBitmap	// see :setOverviewBitmap       		then begin       			overviewPixels := overviewPixels + overviewBounds:area();       			DrawIntoBitmap(       				screenBitmap,       				{transferMode: modeCopy, penPattern: vfNone, transform: [localBounds, overviewBounds]}, // ShapeBounds(screenBitmap)       				overviewBitmap);       			if (overviewPixels div ppb) >= kVBOFlush       			then begin       //Print("overviewFlush:" && overviewPixels);       				overviewPixels := 0;       				ClearVBOCache(overviewBitmap.data);       				end;       			end;       		:Dirty();					// redraw detail screen       		end;              	(if options.minUI = kCompactFloat and compactFloat then compactFloat.title else title):?setGauge(fval);       end,     remoteBounds:       /*frame*/ nil	// absolute coords of current remote screen. set by :setSize, :setOrigin       ,     SetOriginRel:       func(int dx, int dy, int wait) // dx,dy always int except 0.5 [viewScrollUp/DownScript]. wait in ticks       begin       	// assume won't really scroll by 1 or .5 (from big arrows, viewScrollUp/DownScripts)       	// so, interpret as fraction of viewWidth or viewHeight       	if dx <> 0 and abs(dx) <= 1       	then dx := RIntToL(viewWidth * dx);       	if dy <> 0 and abs(dy) <= 1       	then dy := RIntToL(viewHeight * dy);       	       	:SetOrigin(	// clip bounds, add msg       		max(0, min(imgWidth  - viewWidth,  viewOriginX + dx)),       		max(0, min(imgHeight - viewHeight, viewOriginY + dy)),       		$; && $\u2206 & dx & $, & dy,       		wait);       end    };AddStepForm(vncview, vc);StepDeclare(vncview, vc, 'vc);paraView :=    {viewBounds: {left: 0, top: -16, right: 0, bottom: 0},     viewFlags: 64001,     viewFont: simpleFont9,     viewFormat: 0,     viewLineSpacing: 5,     viewJustify: 240,     viewChangedScript:       func(/*symbol*/ slot, view) // called by char recog only (not kbd)       if slot='text       then begin       	local /*char*/ lch, uch;       	local int i, charCode, modifiers, pos, len := StrLen(text);       	:status(textSrc, text, NO_LOG);       	textSrc := LocObj("rec", 'rec);	// reset (in case changed by drop or other)              	for i:=0 to len-1       	do begin       		charCode := Ord(uch := text[i]);       		// if :status just once (for entire text above), then no need to send lch, uch -- just modifiers       		modifiers := if ($A <= uch and uch <= $Z) or CharPos(kUppercase,uch,0) then kShiftModifier else kNoModifiers;       /*       		modifiers := kShiftModifier; // assume shift       		lch := uch;       		if ($A <= uch and uch <= $Z)       		then lch := Chr(charCode + Aadiff)       		else if pos := CharPos(kUppercase,uch,0)       		then lch := kLowerCase[pos]       		else modifiers := kNoModifiers; // no shift       */       		:writeKey(charCode, modifiers, lch, uch, NO_MSG, ROM_typewriter);	// ?? i=len-1.  feedback only on last char       		end;              	text := Clone("");       	end,     ViewKeyDownScript:       /*boolean*/ func(/*char*/ char, int flags) 	// return true if key has been completely handled, nil otherwise       begin       	// removed viewKeyUpScript. do down/up as single cmd. this also handles repeating keys              	local int plainCode := Band(flags,0xFF);              	// Option goes thru, but not Ctrl or Cmd       	if  plainCode=0 and Band(flags, kAnyModifier) <> 0       	then return NIL;	// only modifier key. real keystroke later...              	local int charCode := Ord(char);       	if charCode = chBS and Band(flags, kShiftModifier) <> 0       	then begin	// map Shift-Del(i.e, BS) to DEL       		charCode := chDEL;       		flags := flags - kShiftModifier;       		end;              //Print([charCode, char, plainCode, Chr(plainCode)]);              	local /*boolean*/ softKbd := Band(flags, kIsSoftKeyboard) <> 0;       	:writeKey(charCode, flags, Chr(plainCode), char,       		if softKbd then LocObj("skbd",'skbd) else LocObj("hkbd",'hkbd),       		if not softKbd then ROM_typewriter);       	// writeKey returns TRUE. doesn't go to viewChangedScript       end              /*       ?? cleanup viewChangedScript later       */,     text: /*string*/ "",     textFlags:       vSingleKeystrokes // +vTakesAllKeys       ,     writeKey:       /*boolean*/ func(int key, int modifiers, /*char*/ lch, /*char*/ uch, msg, sound) // used by viewGestureScript(scrub), ctrl-Alt-Del, paraView.viewChangedScript, paraView.keyDownScript       if not server       then begin       	rfb:?writeKeyEvent(KEY_PRESS, key, modifiers);	// this'll also do KEY_RELEASE       	:refresh(INCR_REFRESH, KEY_DELAY, nil);			// wait for keys to stop??              	if sound then PlaySound(sound);              	if not msg then return TRUE;							// don't display msg info (or key)              	// display status for the char       	msg := LocObj("key",'key) & $[ & msg & "]: ";			// msg was "source"              	if modifiers <> kNoModifiers       	then begin       		if Band(modifiers, kControlModifier) <> 0       		then msg := msg & LocObj("ctrl",'ctrl) & $-;       		if Band(modifiers, kOptionsModifier) <> 0       		then msg := msg & LocObj("meta",'meta) & $-;       		if Band(modifiers, kCommandModifier) <> 0       		then msg := msg & LocObj("alt",'alt) & $-;       		if Band(modifiers, kShiftModifier) <> 0       		then msg := msg & LocObj("sh",'shift) & $-;       		end;              	// ?? other special chars. see rfbProto.writeKeyEvent       	msg := msg &       			 if key=chBS  then LocObj("bs", 'bs)       		else if key=chHT  then "TAB"	//"\\t"       		else if key=chCR  then "ENTER"	// "\\n"       		else if key=chFS  then "LTAR"	// "<-"       		else if key=chGS  then "RTAR"	// "->"       		else if key=chRS  then "UPAR"       		else if key=chUS  then "DNAR"       		else if key=chDEL then "DEL"       		else lch;              	:status(msg, if uch and lch<>uch then uch, NO_LOG);       	TRUE;		// for viewKeyDownScript, viewGestureScript       end,     viewgesturescript:       func(unit, gestureKind)       NIL,     viewSetupFormScript:       func()       begin       	if options.noHWR       	then viewBounds := SetBounds(0, -16, 0, -vc:LocalBox().bottom);       	//inherited:?viewSetupFormScript();       end,     textSrc: /*string*/ LocObj("rec", 'rec),     viewClass: 81 /* clParagraphView */    };AddStepForm(vc, paraView);StepDeclare(vncview, paraView, 'paraView);// After Script for vcthisView := vc;begin	thisView.icon := nil;	thisView.viewClass := clPictureView;	RemoveSlot(thisView, 'viewDrawScript);	// experiment with eliminating paraView, except that HWR doesn't work?	// add textSrc, viewChangedScript, writeKey, viewKeyDownScript	// thisView.viewFlags := Bor(thisView.viewFlags, vCharsAllowed + vLettersAllowed + vNumbersAllowed + vPunctuationAllowed);	if TIMING	then thisView.prevT := nil;	local array grays := [ // these differ by kRGB_16GrayIncrement		//kRGB_Black=			kRGB_Gray15, kRGB_Gray14, kRGB_Gray13, kRGB_Gray12,		kRGB_Gray11, kRGB_Gray10, kRGB_Gray9,  kRGB_Gray8,		kRGB_Gray7,  kRGB_Gray6,  kRGB_Gray5,  kRGB_Gray4,		kRGB_Gray3,  kRGB_Gray2,  kRGB_Gray1,  kRGB_Gray0 //=kRGB_White		];	if FILL_RECT	then RemoveSlot(thisView, 'fillRect2);	else begin // style arrays not needed unless DrawShape used		local int i, len := Length(grays);		local array grayStyles16 := Array(len,nil);		for i:=1 to len		do grayStyles16[i-1] := {fillPattern: grays[len-i], penPattern: vfNone}; // invert order		// create grayMap at run-time.  rgb:0-255 -> gray:0-15		len := 4;		local array grayStyles4 := Array(len, nil);		for i:=0 to len-1		do grayStyles4[i] := grayStyles16[i*5];	//0-3 = 0,5,10,15			local array bwgrays := [vfBlack, vfDkGray, vfGray, vfLtGray, vfWhite];	// for bpp=1		len := Length(bwgrays);		local array bwStyles := Array(len,nil);		for i:=1 to len		do bwStyles[i-1] := {fillPattern: bwgrays[len-i], penPattern: vfNone}; // invert order		thisView.fillStyles := [nil, bwStyles, grayStyles4, nil, grayStyles16];	// index by bpp[1,2,4]		end;	local int i, r, g, b, gray;	if ADD_SERVER // just for bpp=4 (reversed). nil, [0,255], [0, 82, 173, 255], nil, ...]. see randomRect	then begin		thisView.incrUpdates	:= nil;		thisView.refreshAccept	:= nil;	// viewIdleScript, Refresh/*		// from Paul		local array k16Colors := [			[0xFFFF, 0xFFFF, 0xFFFF],			[0xEEEE, 0xEEEE, 0xEEEE],			[0xDDDD, 0xDDDD, 0xDDDD],			[0xCCCC, 0xCCCC, 0xCCCC],			[0xBBBB, 0xBBBB, 0xBBBB],			[0xAAAA, 0xAAAA, 0xAAAA],			[0x9999, 0x9999, 0x9999],			[0x8888, 0x8888, 0x8888],			[0x7777, 0x7777, 0x7777],			[0x6666, 0x6666, 0x6666],			[0x5555, 0x5555, 0x5555],			[0x4444, 0x4444, 0x4444],			[0x3333, 0x3333, 0x3333],			[0x2222, 0x2222, 0x2222],			[0x1111, 0x1111, 0x1111],			[0x0000, 0x0000, 0x0000],			];		local array k16ColorsBL := [			[0x7800, 0xFFFF, 0x7800],			[0x7000, 0xEEEE, 0x7000],			[0x6800, 0xDDDD, 0x6800],			[0x6000, 0xCCCC, 0x6000],			[0x5800, 0xBBBB, 0x5800],			[0x5000, 0xAAAA, 0x5000],			[0x4800, 0x9999, 0x4800],			[0x4000, 0x8888, 0x4000],			[0x3800, 0x7777, 0x3800],			[0x3000, 0x6666, 0x3000],			[0x2800, 0x5555, 0x2800],			[0x2000, 0x4444, 0x2000],			[0x1800, 0x3333, 0x1800],			[0x1000, 0x2222, 0x1000],			[0x0800, 0x1111, 0x0800],			[0x0000, 0x0000, 0x0000],			];		local array rgb := Array(16,0), rgbBL := Array(16,0);		local rgbFunc := func(array rgb)			begin				//??? what's reasonable inverse of Gray = 0.3R + 0.59G + 0.11B				local int r := rgb[0], g := rgb[1], b := rgb[2];				r := Floor(0.5 + 7 * r / 65535);				g := Floor(0.5 + 7 * g / 65535);				b := Floor(0.5 + 3 * b / 65535);				[r,g,b];			end;						for i:=0 to 15		do begin			rgb[i]   := call rgbFunc with (k16Colors[i]);			rgbBL[i] := call rgbFunc with (k16ColorsBL[i]);			end;		Print(rgb);[[7, 7, 3],  [7, 7, 3],  [6, 6, 3],  [6, 6, 2],  [5, 5, 2],  [5, 5, 2],  [4, 4, 2],  [4, 4, 2],  [3, 3, 1],  [3, 3, 1],  [2, 2, 1],  [2, 2, 1],  [1, 1, 1],  [1, 1, 0],  [0, 0, 0],  [0, 0, 0]]		Print(rgbBL);[[3, 7, 1],  [3, 7, 1],  [3, 6, 1],  [3, 6, 1],  [2, 5, 1],  [2, 5, 1],  [2, 4, 1],  [2, 4, 1],  [2, 3, 1],  [1, 3, 1],  [1, 2, 0],  [1, 2, 0],  [1, 1, 0],  [0, 1, 0],  [0, 0, 0],  [0, 0, 0]]*/		// e.g., http://www.kallisys.com/shots/20011122-193218.png		local array rgb := [	// do some manual adjustments to make unique 16 bbgggrrr values			[7, 7, 3], 			[7, 6, 3],	//g-1			[6, 6, 3], 			[6, 6, 2], 			[5, 5, 2], 			[5, 4, 2], 	//g-1			[4, 4, 2], 			[4, 3, 2], 	//g-1			[3, 3, 1], 			[3, 2, 1], 	//g-1			[2, 2, 1], 			[2, 1, 1], 	//g-1			[1, 1, 1], 			[1, 1, 0], 			[1, 0, 0], 	//r+1			[0, 0, 0]];		// e.g., http://www.kallisys.com/shots/20011122-193437.png		local array rgbBL := [	// some dups. make less green?			[4, 7, 2], 	//r+1,b+1			[3, 7, 1], 			[3, 6, 1], 			[3, 6, 1], 			[2, 5, 1], 			[2, 5, 1], 			[2, 4, 1], 			[2, 4, 1], 			[2, 3, 1], 			[1, 3, 1], 			[1, 2, 0], 			[1, 2, 0], 			[1, 1, 0], 			[0, 1, 0], 			[0, 0, 0], 			[0, 0, 0]];		local rgbFillFunc := func(array rgbd, array rgbs, int redShift, int greenShift, int blueShift, /*boolean*/ reverse)			begin				local int i, r, g, b, len := Length(rgbs);				local array rgb;				for i:=0 to len-1				do begin					rgb := rgbs[i];					r := rgb[0]; g := rgb[1]; b := rgb[2];					rgbd[if reverse then len-i-1 else i] := (b << blueShift) + (g << greenShift) + (r << redShift);					end;				rgbd;			end;		thisView.rgbFill := rgbFillFunc;	// for testing colors		thisView.colorMap0  := call rgbFillFunc with (Array(16,0), rgb,   0, 3, 6, nil);		thisView.colorMapBL := call rgbFillFunc with (Array(16,0), rgbBL, 0, 3, 6, nil);	// for backlight		thisView.colorMap   := thisView.colorMap0;		thisView.lastBacklight 	:= nil;			// set/change in connected, viewIdleScript		end	else begin // no server		RemoveSlot(thisView, 'viewIdleScript);		RemoveSlot(thisView, 'bitmapToRaw);		end;	// for VIEWER	//grayMap could be faster (but 8*larger as an array) or smaller(128 bytes: 2 grays/byte; but more complex)	local /*byte[]*/ grayMap := thisView.grayMap := MakeBinary(256,'bytes); // used in drawRawRect, setColor	for i:=0 to 255	do begin // see rfb:writeSetPixelFormat (called by vc:connected)		r := Band(i,      0x7);		g := Band(i >> 3, 0x7);		b := Band(i >> 6, 0x3);		/*if nos21		then begin			rgb := PackRGB(r*9362, g*9362, b*21845); // 9362 ~=65535/7, 21845 =65535/3			gray := GetTone(rgb);	// doesn't work at build-time			end		else */			//Gray = 0.3R + 0.59G + 0.11B			gray := 15 - min(15, Floor(0.5 + (0.3 * (r*15/7)) + (0.59 * (g*15/7)) + (0.11 * (b*5)))); // RIntToL (not at runtime)		StuffByte(grayMap, i, gray);	// see :setColor		end;	//thisView.testFDrawRawRect := nil;	if PROFILE	then begin		thisView.testFreqFrame := thisView.testRectArray0 := thisView.testRectArray1 := nil;		end	else begin		RemoveSlot(thisView, 'testFreq);		RemoveSlot(thisView, 'testRect);		end;endoptionsFrame := LinkedSubview(optionsFrame,    {viewBounds: {left: 8, top: 288, right: 79, bottom: 304}});AddStepForm(vncview, optionsFrame);StepDeclare(vncview, optionsFrame, 'optionsFrame);authenticator := LinkedSubview(authenticationPanel,    {viewBounds: {left: 120, top: 288, right: 208, bottom: 304}});AddStepForm(vncview, authenticator);StepDeclare(vncview, authenticator, 'authenticator);clipboard := LinkedSubview(clipboardFrame,    {viewBounds: {left: 120, top: 264, right: 208, bottom: 280}});AddStepForm(vncview, clipboard);StepDeclare(vncview, clipboard, 'clipboard);about := LinkedSubview(aboutLayout,    {viewBounds: {left: 8, top: 264, right: 80, bottom: 280}});AddStepForm(vncview, about);StepDeclare(vncview, about, 'about);compactFloat := LinkedSubview(compactFloat,    {viewBounds: {left: 64, top: 232, right: 136, bottom: 248}});AddStepForm(vncview, compactFloat);StepDeclare(vncview, compactFloat, 'compactFloat);// After Script for vncviewthisView := vncview;begin	thisView.viewBounds := kRect0;	if ADD_SERVER	then begin		thisView.viewDrawScript := kRefreshPatch.viewDrawScript;		thisView.RectEqual 		:= kRectEqual;		thisView.patches		:= nil;		//thisView.zlibMemory	:= 8;		end	else begin		RemoveSlot(thisView, 'installRefreshPatch);		RemoveSlot(thisView, 'Refresh);		RemoveSlot(thisView, 'viewDrawScript);		end;	if (DEBUG)	then begin		thisView.rfbProto 	:= rfbProto;		thisView.Socket 	:= Socket;		thisView.DesCipher 	:= DesCipher;		thisView.Area 		:= Area;		thisView.byte 		:= byte;		thisView.PrintBytes := kPrintBytes;		end;	// *** share some methods/objects (rather than go to trouble of defining user protos)	local array children := thisView.stepChildren;	//local int clen := Length(children);	// THESE OFFSETS CHANGED IF CHILDREN ARE ADDED/MOVED	local int I :=  0, K 		:=  1, A := 4,	C := 5, ST := 6; // TI := 2, SC := 3;	local int L :=  7, LRslider :=  8, R :=  9;	local int T := 10, TBslider := 11, B := 12;	// VC := 13	// info, kbd, action, close	children[I].viewSetupFormScript :=		children[K].viewSetupFormScript :=		children[A].viewSetupFormScript :=		children[C].viewSetupFormScript := kShiftView;		// big buttons	children[B].buttonClickScript := children[T].buttonClickScript :=		children[R].buttonClickScript := children[L].buttonClickScript;	children[R].viewSetupFormScript := children[L].viewSetupFormScript :=		children[B].viewSetupFormScript := children[T].viewSetupFormScript;	// sliders	children[LRslider].changedSlider 		:= children[TBslider].changedSlider;	children[LRslider].trackSlider   		:= children[TBslider].trackSlider;		children[LRslider].viewSetupFormScript  := children[TBslider].viewSetupFormScript := children[ST].viewSetupFormScript;	endconstant |layout_newtVNC.lyt| := vncview;// End of file newtVNC.lyt