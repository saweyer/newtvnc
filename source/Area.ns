// this should work for regular bounds as well as AreaDefineGlobalConstant('kBoundsString, func(/*frame*/ bnds)begin	local int x := bnds.left, y := bnds.top;	"x: " & x & ", y: " & y &	", w: " & (bnds.right-x) & ", h: " & (bnds.bottom-y);end);/*Area is used to represent and iterate over rectangular areas.e.g., hextiles (16x16) or bitmap slices*/DefineGlobalConstant('Area, {// to emulate bounds frame (share frame map)/*int*/ left: 		nil,	// public vals (local rect)/*int*/ top: 		nil,/*int*/ right:		nil,	// only used by kBoundString ?/*int*/ bottom: 	nil,	// only used by kBoundString ?/*int*/ width:		nil,/*int*/ height:		nil,/*int*/ _left: 		nil,	// original vals (complete rect)/*int*/ _top: 		nil,	/*int*/ _right:		nil,/*int*/ _bottom: 	nil,/*int*/ _width: 	nil,/*int*/ _height:	nil,/*int*/ _widthInc: 	nil,/*int*/ _heightInc:	nil,_proto: nil,/*int*/ encoding: 	0,		// encoding(initially), subencoding(later)/*int*/ color: 		0,		// background/*int*/ fcolor:		0,		// foregroundnew: func(int x, int y, int w, int h, int wi, int hi)begin	if not wi	then wi := w;	if not hi	then hi := h; 	{	left: 		x, 		top:		y, 		right:		nil, 		bottom:		nil,    	width:		nil,    	height: 	nil,    	_left: 		x,	// complete rect		_top: 		y, 		_right:		x+w, 		_bottom:	y+h,    	_width: 	w,    	_height:	h,    	_widthInc: 	wi,	// typically 16 for Hex, width for raw    	_heightInc:	hi,	// typically 16 for Hex, 16 or 18 for bitmap slices 		_proto: 	self,    }:setNextsize(wi,hi);end,setNextSize: func(int wi, int hi)	// usually before 1st :next if not set correctly in :newbegin	if wi	then begin		width := min(_width, _widthInc := wi);		right := left + width;		end;	if hi	then begin		height := min(_height, _heightInc := hi);		bottom := top + height;		end;	self;end,/*string*/ toString: func()		// current local rect	//"RelBounds(" & left & $, & top & $, & width & $, & height & $),	call kBoundsString with (self),/*int*/ area: func() width * height,	// current local rect/*int*/ totalRects: func()	// # of local rects in complete rect	:rows() * :cols(),/*int*/ cols: func()	(_width + _widthInc-1) div _widthInc,/*int*/ rows: func()	(_height + _heightInc-1) div _heightInc,/*int*/ next: func()		// nil if done. otherwise 'progressHt'begin	left := left + _widthInc;    if left >= _right    then begin		top := top + _heightInc;		if top >= _bottom		then return nil;		height := min(_bottom-top, _heightInc);    	bottom := top + height;		left := _left;   		end;	width := min(_right-left, _widthInc);    right := left + width;	return					// for :setGauge		if  left = _left		then top - _top		else -1;end,});