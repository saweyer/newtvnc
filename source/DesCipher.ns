// Newton version S. Weyer//// NOTE: NewtonScript can only handle integers up to 29-30 bits (including sign).// to avoid problems with 2 inaccessible high bits and sign bit,// this version usually operates on integers as sequence of 4 bytes// though optimizations are sometimes possible. only true int[] is 'totrot'// 0x1FFFFFFF is max pos #; 1<<29 is neg; )// although slow/ugly, this is really only used for initial authentication// so it shouldn't be a major problem (and probably not worth major rewriting)// //// This DES class has been extracted from package Acme.Crypto for use in VNC.// The bytebit[] array has been reversed so that the most significant bit// in each byte of the key is ignored, not the least significant.  Also the// unnecessary odd parity code has been removed.//// These changes are://  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.//// This software is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.//// DesCipher - the DES encryption method//// The meat of this code is by Dave Zimmerman <dzimm@widget.com>, and is://// Copyright (c) 1996 Widget Workshop, Inc. All Rights Reserved.//// Permission to use, copy, modify, and distribute this software// and its documentation for NON-COMMERCIAL or COMMERCIAL purposes and// without fee is hereby granted, provided that this copyright notice is kept// intact.//// WIDGET WORKSHOP MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY// OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED// TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A// PARTICULAR PURPOSE, OR NON-INFRINGEMENT. WIDGET WORKSHOP SHALL NOT BE LIABLE// FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR// DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.//// THIS SOFTWARE IS NOT DESIGNED OR INTENDED FOR USE OR RESALE AS ON-LINE// CONTROL EQUIPMENT IN HAZARDOUS ENVIRONMENTS REQUIRING FAIL-SAFE// PERFORMANCE, SUCH AS IN THE OPERATION OF NUCLEAR FACILITIES, AIRCRAFT// NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE// SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF THE// SOFTWARE COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR SEVERE// PHYSICAL OR ENVIRONMENTAL DAMAGE ("HIGH RISK ACTIVITIES").  WIDGET WORKSHOP// SPECIFICALLY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR// HIGH RISK ACTIVITIES.////// The rest is://// Copyright (C) 1996 by Jef Poskanzer <jef@acme.com>.  All rights reserved.//// Redistribution and use in source and binary forms, with or without// modification, are permitted provided that the following conditions// are met:// 1. Redistributions of source code must retain the above copyright//    notice, this list of conditions and the following disclaimer.// 2. Redistributions in binary form must reproduce the above copyright//    notice, this list of conditions and the following disclaimer in the//    documentation and/or other materials provided with the distribution.//// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF// SUCH DAMAGE.//// Visit the ACME Labs Java page for up-to-date versions of this and other// fine Java utilities: http://www.acme.com/java/// import java.io.*;/// The DES encryption method.// <P>// This is surprisingly fast, for pure Java.  On a SPARC 20, wrapped// in Acme.Crypto.EncryptedOutputStream or Acme.Crypto.EncryptedInputStream,// it does around 7000 bytes/second.// <P>// Most of this code is by Dave Zimmerman <dzimm@widget.com>, and is// Copyright (c) 1996 Widget Workshop, Inc.  See the source file for details.// <P>// <A HREF="/resources/classes/Acme/Crypto/DesCipher.java">Fetch the software.</A><BR>// <A HREF="/resources/classes/Acme.tar.Z">Fetch the entire Acme package.</A>// <P>// @see Des3Cipher// @see EncryptedOutputStream// @see EncryptedInputStreamDefineGlobalConstant('Hxaaaaaaaa, 	byte:new("aaaaaaaa")); // for desDefineGlobalConstant('Hx33333333, 	byte:new("33333333"));DefineGlobalConstant('DesCipher, {    new: func(/*byte[]*/ key)	// Constructor, byte-array key.begin	local obj := {		_proto: self,		/*int[]*/ encryptKeys:	int:new(32),		///*int[]*/ decryptKeys:	int:new(32),	// UNUSED		/*int[]*/ tempInts: 	int:new(2),		};	obj:setKey(key);	return obj;end,setKey: func(/*byte[]*/ key )	// Set the key.begin	:deskey( key, true,  encryptKeys );//if (DEBUG) then call kPrintBytes with (encryptKeys, 0,nil,"encryptKeys");	//:deskey( key, false, decryptKeys );	// UNUSED//if (DEBUG) then call kPrintBytes with (decryptKeys, 0,nil,"decryptKeys");end,// Turn an 8-byte key into internal keys.deskey: func(/*byte[]*/ keyBlock, /*boolean*/ encrypting, /*int[]*/ KnL )begin	local int i, j, l, m, n;	local /*int[]*/ pc1m 	:= int:new(56);	local /*int[]*/ pcr  	:= int:new(56);	local /*int[]*/ kn 		:= int:new(32);	for j:=0 to 55	do begin		l := ExtractByte(pc1,j); //pc1[j];	    m := Band(l, 0x7);	// m = l & 07	    //pc1m[j] := ( (keyBlock[l >>> 3] & bytebit[m]) != 0 )? 1: 0;	    :StuffInt(pc1m,j,	    	(if (Band(ExtractByte(keyBlock, l div 8), ExtractByte(bytebit,m)) <> 0 ) //l >> 3	    	then 1 else 0), 0);	    end;	for i := 0 to 15	do begin		m := if ( encrypting ) then i*2 else (15-i)*2;	//i << 1 else (15-i) << 1;	    n := m+1;	    :StuffInt(kn,m, 0,0); :StuffInt(kn,n, 0,0); //kn[m] := kn[n] := 0;		for j:=0 to 55		do begin			l := j+totrot[i];			:StuffInt(pcr,j, pc1m, if (if j<28 then l<28 else l<56) then l else l-28);			end;		for j:=0 to 23		do begin			if (not :EqualInt(pcr, ExtractByte(pc2,j), 0,0)) //(pcr[pc2[j]] <> 0 )		    then //kn[m] |= bigbyte[j]		    	:BorInt(kn,m, kn,m, bigbyte,j);			if (not :EqualInt(pcr, ExtractByte(pc2,j+24), 0,0)) //(pcr[pc2[j+24]] <> 0 )		    then //kn[n] |= bigbyte[j];		    	:BorInt(kn,n, kn,n, bigbyte,j);			end;	    end;	:cookey( kn, KnL );end,cookey: func(/*int[]*/ raw, /*int[]*/ KnL )begin	local int raw0, raw1, KnLx, i;	local int rawi := KnLi := 0;	local tmp := int:new(1);	for i:=0 to 15	do begin		//raw0 := raw[rawi];		raw0 := rawi;	// NS note: raw0,raw1 are used here as just 'indices' into raw		rawi := rawi+1;		//raw1 := raw[rawi];		raw1 := rawi;		rawi := rawi+1;	    //KnL[KnLi]  = (raw0 & 0x00fc0000) <<   6;		:BandInt(KnL,KnLi, raw,raw0, 0x00fc0000,0);		:LShiftInt(KnL,KnLi, KnL,KnLi, 6);	    //KnL[KnLi] |= (raw0 & 0x00000fc0) <<  10;	    :BandInt(tmp,0, raw,raw0, 0x00000fc0,0);	    :LShiftInt(tmp,0, tmp,0, 10);	    :BorInt(KnL,KnLi, KnL,KnLi, tmp,0);	    	    //KnL[KnLi] |= (raw1 & 0x00fc0000) >>> 10;	    :BandInt(tmp,0, raw,raw1, 0x00fc0000,0);	    :RShiftInt(tmp,0, tmp,0, 10, false);	    :BorInt(KnL,KnLi, KnL,KnLi, tmp,0);	    //KnL[KnLi] |= (raw1 & 0x00000fc0) >>>  6;	    :BandInt(tmp,0, raw,raw1, 0x00000fc0,0);	    :RShiftInt(tmp,0, tmp,0, 6, false);	    :BorInt(KnL,KnLi, KnL,KnLi, tmp,0);	    //++KnLi;	    KnLi := KnLi+1;	    //KnL[KnLi]  = (raw0 & 0x0003f000) <<  12;		:BandInt(KnL,KnLi, raw,raw0, 0x0003f000,0);		:LShiftInt(KnL,KnLi, KnL,KnLi, 12);	    //KnL[KnLi] |= (raw0 & 0x0000003f) <<  16;	    :BandInt(tmp,0, raw,raw0, 0x0000003f,0);	    :LShiftInt(tmp,0, tmp,0, 16);	    :BorInt(KnL,KnLi, KnL,KnLi, tmp,0);	    //KnL[KnLi] |= (raw1 & 0x0003f000) >>>  4;	    :BandInt(tmp,0, raw,raw1, 0x0003f000,0);	    :RShiftInt(tmp,0, tmp,0, 4, false);	    :BorInt(KnL,KnLi, KnL,KnLi, tmp,0);	    //KnL[KnLi] |= (raw1 & 0x0000003f);	    :BandInt(tmp,0, raw,raw1, 0x0000003f,0);	    :BorInt(KnL,KnLi, KnL,KnLi, tmp,0);	    //++KnLi;	    KnLi := KnLi+1;		end;end,// Block encryption routines.// Encrypt a block of eight bytes.encrypt: func(/*byte[]*/ clearText, int clearOff, /*byte[]*/ cipherText, int cipherOff )begin	:squashBytesToInts(clearText, clearOff, tempInts, 0, 2 );	:des( tempInts, tempInts, encryptKeys );	:spreadIntsToBytes( tempInts, 0, cipherText, cipherOff, 2 );end,// Decrypt a block of eight bytes	// UNUSED/*decrypt: func(cipherText, int cipherOff, clearText, int clearOff )begin	:squashBytesToInts( cipherText, cipherOff, tempInts, 0, 2 );	:des( tempInts, tempInts, decryptKeys );	:spreadIntsToBytes( tempInts, 0, clearText, clearOff, 2 );end,*/// The DES function.des: func(/*int[]*/ inInts, /*int[]*/ outInts, /*int[]*/ keys )begin	local int round, keysi := 0;	//leftt = inInts[0];	//right = inInts[1];	local leftt := inInts, right := inInts;	// use index: 0 for leftt, 1 for right	local fval := int:new(1), work := int:new(1);	//work   = ((leftt >>>  4) ^ right) & 0x0f0f0f0f;	:RShiftInt(work,0, leftt,0, 4, false);	:BxorInt(work,0, work,0, right,1);	:BandInt(work,0, work,0, 0x0f0f0f0f,0);	//right ^= work;	:BxorInt(right,1, right,1, work,0);	//leftt ^= (work << 4);	:LShiftInt(work,0, work,0, 4); // ok to overwrite work	:BXorInt(leftt,0, leftt,0, work,0);	//work   = ((leftt >>> 16) ^ right) & 0x0000ffff;	:RShiftInt(work,0, leftt,0, 16, false);	:BxorInt(work,0, work,0, right,1);	:BandInt(work,0, work,0, 0x0000ffff,0);	//right ^= work;	:BxorInt(right,1, right,1, work,0);	//leftt ^= (work << 16);	:LShiftInt(work,0, work,0, 16); // ok to overwrite work	:BXorInt(leftt,0, leftt,0, work,0);	//work   = ((right >>>  2) ^ leftt) & 0x33333333;	:RShiftInt(work,0, right,1, 2, false);	:BxorInt(work,0, work,0, leftt,0);	:BandInt(work,0, work,0, Hx33333333,0);	//leftt ^= work;	:BXorInt(leftt,0, leftt,0, work,0);	//right ^= (work << 2);	:LShiftInt(work,0, work,0, 2); // ok to overwrite work	:BxorInt(right,1, right,1, work,0);	//work   = ((right >>>  8) ^ leftt) & 0x00ff00ff;	:RShiftInt(work,0, right,1, 8, false);	:BxorInt(work,0, work,0, leftt,0);	:BandInt(work,0, work,0, 0x00ff00ff,0);	//leftt ^= work;	:BXorInt(leftt,0, leftt,0, work,0);	//right ^= (work << 8);	:LShiftInt(work,0, work,0, 8); // ok to overwrite work	:BxorInt(right,1, right,1, work,0);	//right  = (right << 1) | ((right >>> 31) & 1);	:LShiftInt(work,0, right,1, 1); // ok to overwrite work	:RShiftInt(fval,0, right,1, 31, false);	// ok to use fval	:BandInt(fval,0, fval,0, 0x1, 0);	:BorInt(right,1, work,0, fval,0);	//work   = (leftt ^ right) & 0xaaaaaaaa;	:BxorInt(work,0, leftt,0, right,1);	:BandInt(work,0, work,0, Hxaaaaaaaa,0);	// defined as a constant	//leftt ^= work;	:BxorInt(leftt,0, leftt,0, work,0);	//right ^= work;	:BxorInt(right,1, right,1, work,0);	//leftt  = (leftt << 1) | ((leftt >>> 31) & 1);	:LShiftInt(work,0, leftt,0, 1); // ok to overwrite work	:RShiftInt(fval,0, leftt,0, 31, false);	// ok to use fval	:BandInt(fval,0, fval,0, 0x1, 0);	:BorInt(leftt,0, work,0, fval,0);	for round := 0 to 7	do begin	    //work   = (right << 28) | (right >>> 4);		:LShiftInt(work,0, right,1, 28); // ok to overwrite work		:RShiftInt(fval,0, right,1, 4, false);	// ok to use fval		:BorInt(work,0, work,0, fval,0);	    	    //work  ^= keys[keysi++];	    :BxorInt(work,0, work,0, keys,keysi);	    keysi := keysi+1;	    //fval   = SP7[ work	     & 0x0000003f ];	    //fval  |= SP5[(work >>>  8) & 0x0000003f ];	    :BorInt(fval,0, SP7, Band(ExtractByte(work,3), 0x3f),	    				SP5, Band(ExtractByte(work,2), 0x3f));	    	    //fval  |= SP3[(work >>> 16) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP3, Band(ExtractByte(work,1), 0x3f));	    	    //fval  |= SP1[(work >>> 24) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP1, Band(ExtractByte(work,0), 0x3f));	    	    //work   = right ^ keys[keysi++];	    :BxorInt(work,0, right,1, keys,keysi);	    keysi := keysi+1;		    //fval  |= SP8[ work         & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP8, Band(ExtractByte(work,3), 0x3f));	    //fval  |= SP6[(work >>>  8) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP6, Band(ExtractByte(work,2), 0x3f));	    //fval  |= SP4[(work >>> 16) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP4, Band(ExtractByte(work,1), 0x3f));	    //fval  |= SP2[(work >>> 24) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP2, Band(ExtractByte(work,0), 0x3f));	    //leftt ^= fval;	    :BxorInt(leftt,0, leftt,0, fval,0);	  	    //work   = (leftt << 28) | (leftt >>> 4);		:LShiftInt(work,0, leftt,0, 28); // ok to overwrite work		:RShiftInt(fval,0, leftt,0, 4, false);	// ok to use fval		:BorInt(work,0, work,0, fval,0);	    //work  ^= keys[keysi++];	    :BxorInt(work,0, work,0, keys,keysi);	    keysi := keysi+1;	    //fval   = SP7[ work	     & 0x0000003f ];	    //fval  |= SP5[(work >>>  8) & 0x0000003f ];	    :BorInt(fval,0, SP7, Band(ExtractByte(work,3), 0x3f),	    				SP5, Band(ExtractByte(work,2), 0x3f));	    	    //fval  |= SP3[(work >>> 16) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP3, Band(ExtractByte(work,1), 0x3f));	    	    //fval  |= SP1[(work >>> 24) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP1, Band(ExtractByte(work,0), 0x3f));	    //work   = leftt ^ keys[keysi++];	    :BxorInt(work,0, leftt,0, keys,keysi);	    keysi := keysi+1;	    //fval  |= SP8[ work         & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP8, Band(ExtractByte(work,3), 0x3f));	    //fval  |= SP6[(work >>>  8) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP6, Band(ExtractByte(work,2), 0x3f));	    //fval  |= SP4[(work >>> 16) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP4, Band(ExtractByte(work,1), 0x3f));	    //fval  |= SP2[(work >>> 24) & 0x0000003f ];	    :BorInt(fval,0, fval,0, SP2, Band(ExtractByte(work,0), 0x3f));	    //right ^= fval;	    :BxorInt(right,1, right,1, fval,0);	    end;	//right  = (right << 31) | (right >>> 1);	:LShiftInt(work,0, right,1, 31); // ok to overwrite work	:RShiftInt(fval,0, right,1, 1, false);	// ok to use fval	:BorInt(right,1, work,0, fval,0);	//work   = (leftt ^ right) & 0xaaaaaaaa;	:BxorInt(work,0, leftt,0, right,1);	:BandInt(work,0, work,0, Hxaaaaaaaa,0);	//leftt ^= work;	:BxorInt(leftt,0, leftt,0, work,0);	//right ^= work;	:BxorInt(right,1, right,1, work,0);	//leftt  = (leftt << 31) | (leftt >>> 1);	:LShiftInt(work,0, leftt,0, 31); // ok to overwrite work	:RShiftInt(fval,0, leftt,0, 1, false);	// ok to use fval	:BorInt(leftt,0, work,0, fval,0);	//work   = ((leftt >>>  8) ^ right) & 0x00ff00ff;	:RShiftInt(work,0, leftt,0, 8, false);	:BXorInt(work,0, work,0, right,1);	:BandInt(work,0, work,0, 0x00ff00ff,0);	//right ^= work;	:BxorInt(right,1, right,1, work,0);	//leftt ^= (work << 8);	:LShiftInt(work,0, work,0, 8); // ok to overwrite work	:BxorInt(leftt,0, leftt,0, work,0);	//work   = ((leftt >>>  2) ^ right) & 0x33333333;	:RShiftInt(work,0, leftt,0, 2, false);	:BXorInt(work,0, work,0, right,1);	:BandInt(work,0, work,0, Hx33333333,0);	//right ^= work;	:BxorInt(right,1, right,1, work,0);	//leftt ^= (work << 2);	:LShiftInt(work,0, work,0, 2); // ok to overwrite work	:BxorInt(leftt,0, leftt,0, work,0);	//work   = ((right >>> 16) ^ leftt) & 0x0000ffff;	:RShiftInt(work,0, right,1, 16, false);	:BXorInt(work,0, work,0, leftt,0);	:BandInt(work,0, work,0, 0x0000ffff,0);	//leftt ^= work;	:BxorInt(leftt,0, leftt,0, work,0);	//right ^= (work << 16);	:LShiftInt(work,0, work,0, 16); // ok to overwrite work	:BxorInt(right,1, right,1, work,0);		//work   = ((right >>>  4) ^ leftt) & 0x0f0f0f0f;	:RShiftInt(work,0, right,1, 4, false);	:BXorInt(work,0, work,0, leftt,0);	:BandInt(work,0, work,0, 0x0f0f0f0f,0);		//leftt ^= work;	:BxorInt(leftt,0, leftt,0, work,0);		//right ^= (work << 4);	:LShiftInt(work,0, work,0, 4); // ok to overwrite work	:BxorInt(right,1, right,1, work,0);	//outInts[0] = right;	//outInts[1] = leftt;	//need to swap, but since array is identical. copy to temps	:StuffInt(work,0, leftt,0);	:StuffInt(fval,0, right,1);	:StuffInt(outInts,0, fval,0);	//right	:StuffInt(outInts,1, work,0);	//leftend,// Tables, permutations, S-boxes, etc./*byte[]*/ bytebit: byte:new("0102040810204080"),/*int[]*/ bigbyte: byte:new("008000000040000000200000001000000008000000040000000200000001000000008000000040000000200000001000000008000000040000000200000001000000008000000040000000200000001000000008000000040000000200000001"),/*byte[]*/ pc1: byte:new([      56, 48, 40, 32, 24, 16,  8,       0, 57, 49, 41, 33, 25, 17,	   9,  1, 58, 50, 42, 34, 26,      18, 10,  2, 59, 51, 43, 35,	  62, 54, 46, 38, 30, 22, 14,       6, 61, 53, 45, 37, 29, 21,	  13,  5, 60, 52, 44, 36, 28,      20, 12,  4, 27, 19, 11,  3,	]),/*int[]*/ totrot: [        1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28	],/*byte[]*/ pc2: byte:new([	13, 16, 10, 23,  0,  4,	 2, 27, 14,  5, 20,  9,	22, 18, 11, 3 , 25,  7,	15,  6, 26, 19, 12,  1,	40, 51, 30, 36, 46, 54,	29, 39, 50, 44, 32, 47,	43, 48, 38, 55, 33, 52,	45, 41, 49, 35, 28, 31,	]),/*int[]*/ SP1: byte:new("01010400000000000001000001010404010100040001040400000004000100000000040001010400010104040000040001000404010100040100000000000004000004040100040001000400000104000001040001010000010100000100040400010004010000040100000400010004000000000000040400010404010000000001000001010404000000040101000001010400010000000100000000000400010100040001000000010400010000040000040000000004010004040001040401010404000100040101000001000404010000040000040400010404010104000000040401000400010004000000000000010004000104000000000001010004"),/*int[]*/ SP2: byte:new("80108020800080000000800000108020001000000000002080100020800080208000002080108020801080008000000080008000001000000000002080100020001080000010002080008020000000008000000000008000001080208010000000100020800000200000000000108000000080208010800080100000000080200000000000108020801000200010000080008020801000008010800000008000801000008000800000000020801080200010802000000020000080008000000000008020801080000010000080000020001000208000802080000020001000200010800000000000800080000000802080000000801000208010802000108000"),/*int[]*/ SP3: byte:new("00000208080202000000000008020008080002000000000000020208080002000002000808000008080000080002000008020208000200080802000000000208080000000000000808020200000002000002020008020000080200080002020808000208000202000002000008000208000000080802020800000200080000000802020008000000000200080000020800020000080202000800020000000000000002000002000808020208080002000800000800000200000000000802000808000208000200000800000008020208000000080002020800020200080000080802000008000208000002080802000000020208000000080802000800020200"),/*int[]*/ SP4: byte:new("00802001000020810000208100000080008020800080008100800001000020010000000000802000008020000080208100000081000000000080008000800001000000010000200000800000008020010000008000800000000020010000208000800081000000010000208000800080000020000080208000802081000000810080008000800001008020000080208100000081000000000000000000802000000020800080008000800081000000010080200100002081000020810000008000802081000000810000000100002000008000010000200100802080008000810000200100002080008000000080200100000080008000000000200000802080"),/*int[]*/ SP5: byte:new("00000100020801000208000042000100000800000000010040000000020800004008010000080000020001004008010042000100420800000008010040000000020000004008000040080000000000004000010042080100420801000200010042080000400001000000000042000000020801000200000042000000000801000008000042000100000001000200000040000000020800004200010040080100020001004000000042080000020801004008010000000100020000004208000042080100000801004200000042080100020800000000000040080000420000000008010002000100400001000008000000000000400800000208010040000100"),/*int[]*/ SP6: byte:new("20000010204000000000400020404010204000000000001020404010004000002000400000404010004000002000001000400010200040002000000000004010000000000040001020004010000040000040400020004010000000102040001020400010000000000040401020404000000040100040400020404000200000002000400000000010204000100040400020404010004000000000401020000010004000002000400020000000000040102000001020404010004040002040000000404010204040000000000020400010000000100000400020400000004040100000400000400010200040100000000020404000200000000040001020004010"),/*int[]*/ SP7: byte:new("00200000042000020400080200000000000008000400080200200802042008000420080200200000000000000400000200000002040000000420000200000802040008000020080200200002040008000400000204200000042008000020000204200000000008000000080204200802002008000000000204000000002008000400000000200800002000000400080204000802042000020420000200000002002000020400000004000800002000000420080000000802002008020420080000000802040000020420080204200000002008000000000000000002042008020000000000200802042000000000080004000002040008000000080000200002"),/*int[]*/ SP8: byte:new("10001040000010000004000010041040100000001000104000000040100000000004004010040000100410400004100010041000000410400000100000000040100400001000004010001000000010400004100000040040100400401004100000001040000000000000000010040040100000401000100000041040000400000004104000040000100410000000100000000040100400400000100000041040100010000000004010000040100400001004004010000000000400001000104000000000100410400004004010000040100400001000100010001040000000001004104000041000000410000000104000001040000400401000000010041000"),// Routines taken from other parts of the Acme utilities.// Squash bytes down to ints.squashBytesToInts: func(/*byte[]*/ inBytes, int inOff, /*int[]*/ outInts, int outOff, int intLen )begin	// for now, outInts is pseudo-integer-array, so just copy	local int len := intLen*4; // number of bytes	BinaryMunger(outInts, outOff*4, len, inBytes, inOff, len);	/*	local int i;      for ( int i = 0; i < intLen; ++i ) {        outInts[outOff + i] =          ( ( inBytes[inOff    ] & 0xff ) << 24 ) |          ( ( inBytes[inOff + 1] & 0xff ) << 16 ) |          ( ( inBytes[inOff + 2] & 0xff ) <<  8 ) |          (   inBytes[inOff + 3] & 0xff );        inOff += 4;*/end,// Spread ints into bytes.spreadIntsToBytes: func(/*int[]*/ inInts, int inOff, /*byte[]*/ outBytes, int outOff, int intLen )begin	// for now, inInts is pseudo-integer-array, so just copy	local int len := intLen*4; // number of bytes	BinaryMunger(outBytes, outOff, len, inInts, inOff*4, len);/*	local int i, inInt;      for ( int i = 0; i < intLen; ++i ) {        int inInt = inInts[inOff + i];        outBytes[outOff    ] = (byte) ( inInt >>> 24 );        outBytes[outOff + 1] = (byte) ( inInt >>> 16 );        outBytes[outOff + 2] = (byte) ( inInt >>>  8 );        outBytes[outOff + 3] = (byte)   inInt;        outOff += 4;*/end,// == these operate on pseudo-integer-arrays (stored as bytes to avoid large int problem)/*boolean*/ EqualInt: func(/*byte[]*/ ddata, int di, /*byte[] | int*/ sdata, int si)begin // BinEqual doesn't use offset or len	local int i, val;	di := di*4;	si := si*4;	local /*boolean*/ sdataInt := IsInteger(sdata);	for i:=0 to 3	do begin		val := if sdataInt			then if sdata=0 then 0 else Band(0xFF, sdata >> (8 * (3-i)))			else ExtractByte(sdata,si+i);		if ExtractByte(ddata, di+i) <> val		then return false;		end;	return true;end,///*int*/ ExtractInt: func(/*byte[]*/ sdata, int si)//	ExtractLong(sdata, si*4),StuffInt: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si)begin	if IsInteger(sdata)	then StuffLong(ddata, di*4, sdata)	// assumes it isn't _too_ long	else BinaryMunger(ddata,di*4,4, sdata,si*4,4);/*	local int i;	di := di*4;	si := si*4;	for i:=0 to 3	do StuffByte(ddata, di+i, ExtractByte(sdata, si+i));*/end,BandInt: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si, /*byte[] | int*/ mdata, int mi):BOpInt(ddata,di,sdata,si,mdata,mi, GetGlobalFn('Band)),BorInt: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si, /*byte[] | int*/ mdata, int mi):BOpInt(ddata,di,sdata,si,mdata,mi, GetGlobalFn('Bor)),BxorInt: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si, /*byte[] | int*/ mdata, int mi)// shortcut won't work with Bxor:BOpInt(ddata,di,sdata,si,mdata,mi, GetGlobalFn('Bxor)),BOpInt: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si, /*byte[] | int*/ mdata, int mi, /*func*/ fn)begin	local int i;	di := di*4;	si := si*4;		mi := mi*4;	local /*boolean*/ mdataInt := IsInteger(mdata);		if (fn <> GetGlobalFn('Bxor)) and		Band(ExtractByte(sdata,si),0xE0)=0 and		(mdataInt or Band(ExtractByte(mdata,mi),0xE0)=0)	then StuffLong(ddata,di,			call fn with (ExtractLong(sdata,si),				if mdataInt				then mdata				else ExtractLong(mdata,mi)));	else for i:=0 to 3		 do StuffByte(ddata, di+i,				call fn with (ExtractByte(sdata, si+i),					if mdataInt					then Band(0xFF, mdata >> (8 * (3-i)))					else ExtractByte(mdata, mi+i)));end,	shiftBits: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si, int sh, /*boolean*/ signed)begin  // slow! but sure...	local /*int[]*/ array bits := Array(32,0);	local int bval, b := 0, bx;		// optim for left shift	if (sh < 0)	then begin		b := -sh;		si := si+(b div 8);		if Band(b,0x7) <> 0	// (b mod 8)		then begin			bval := ExtractByte(sdata, si);			si := si+1;			end;		end;	//get some/all current bits	for bx := b to 31	do begin		if (b := Band(bx,0x7)) = 0	// (bx mod 8)		then begin			bval := ExtractByte(sdata, si);			si := si+1;			end;		if (Band(bval, 1 << (7-b)) <> 0)		then bits[bx] := 1;		// optim for right shift		if (sh > 0) and (bx >= 31-sh)		then break;		end;	// shift them	local /*int[]*/ array newbits := Array(32, if signed and bits[0]=1 then 1 else 0);	if (sh > 0)	then ArrayMunger(newbits,sh,32-sh, bits,  0,32-sh) 	// right	else ArrayMunger(newbits,0, 32+sh, bits,-sh,32+sh);	// left	// store	bval := 0;	for bx := 0 to 31	do begin		b := Band(bx,0x7);	//bx mod 8;		if newbits[bx] = 1		then bval := Bor(bval, 1 << (7-b));		if b = 7		then begin			StuffByte(ddata, di, bval);			di := di+1;			bval := 0;			end;		end;end,RShiftInt: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si, int sh, /*boolean*/ signed)begin // assume 1 <= sh <= 31	di := di*4;	si := si*4;	local int val := ExtractByte(sdata,si);	// a few simple/safe optimizations	// pos int (no inaccessible bits or sign bit)	if (Band(val, 0xE0) = 0)	then return StuffLong(ddata,di, ExtractLong(sdata,si) >> sh);	// byte at a time (ok within 'same' number due to direction)	if Band(sh,0x7) = 0	//(sh mod 8)	then begin		local int i, fill := if signed and Band(byte0,0x80)=0x80 then 0xFF else 0;		sh := sh div 8;		for i:=3 to 0 by -1		do StuffByte(ddata,di+i, if (i >= sh) then ExtractByte(sdata,si+i-sh) else fill);		end			// do it the slow way (bit at a time)	else :shiftBits(ddata, di, sdata, si, sh, signed);end,LShiftInt: func(/*byte[]*/ ddata, int di, /*byte[]*/ sdata, int si, int sh)begin // assume 1 <= sh <= 31	di := di*4;	si := si*4;	local int val;		// a few simple/safe optimizations	// disappearing low-order zeros?	if (sh >= 29)	then begin		val := ExtractByte(sdata,si+3);		if  (sh=31 and (Band(val, 0x1) = 0))			or			(sh=30 and (Band(val, 0x3) = 0))			or			(sh=29 and (Band(val, 0x7) = 0))		then return StuffLong(ddata,di,0);		// => bit at a time		end	// pos int (no inaccessible bits or sign bit)	else if (Band(ExtractByte(sdata,si), 0xE0) = 0)		and (val := ExtractLong(sdata,si)) <= masks[28-sh] // 29-sh can affect not only sign but also other 2 inaccessible bits!	then return StuffLong(ddata,di, val << sh);	// byte at a time (ok within 'same' number due to direction)	if Band(sh,0x7) = 0	//(sh mod 8)	then begin		local int i, fill := 0;		sh := sh div 8;		for i:=0 to 3		do StuffByte(ddata,di+i, if (i <= 3-sh) then ExtractByte(sdata,si+i+sh) else fill);		end			// do it the slow way (bit at a time)	else :shiftBits(ddata, di, sdata, si, -sh, false);end,/*int[]*/ masks: [	0x1, 		0x3, 		0x7, 		0xF,	0x1F, 		0x3F, 		0x7F, 		0xFF, 	0x1FF, 		0x3FF, 		0x7FF, 		0xFFF,	0x1FFF, 	0x3FFF, 	0x7FFF, 	0xFFFF, 	0x1FFFF,	0x3FFFF,	0x7FFFF,	0xFFFFF,	0x1FFFFF, 	0x3FFFFF, 	0x7FFFFF, 	0xFFFFFF, 	0x1FFFFFF, 	0x3FFFFFF, 	0x7FFFFFF, 	0xFFFFFFF, 	0x1FFFFFFF,	],});/*xd := MakeBinary(4,'bytes);xs := MakeBinary(4,'bytes);StuffLong(xs,0, 1);StuffByte(xs,0, 0x80F);ss:stringInt(xs,0);ss:LShiftInt(xd,0,xs,0,27); ss:StringInt(xd,0)ss:RShiftInt(xd,0,xs,0,27,false); ss:StringInt(xd,0)*/